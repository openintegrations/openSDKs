/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
  '/public/interstitial': {
    /**
     * Returns the markup for the interstitial page
     * @description The Clerk interstitial endpoint serves an html page that loads clerk.js in order to check the user's authentication state.
     * It is used by Clerk SDKs when the user's authentication state cannot be immediately determined.
     */
    get: operations['GetPublicInterstitial']
  }
  '/jwks': {
    /**
     * Retrieve the JSON Web Key Set of the instance
     * @description Retrieve the JSON Web Key Set of the instance
     */
    get: operations['GetJWKS']
  }
  '/clients': {
    /**
     * List all clients
     * @deprecated
     * @description Returns a list of all clients. The clients are returned sorted by creation date,
     * with the newest clients appearing first.
     * Warning: the endpoint is being deprecated and will be removed in future versions.
     */
    get: operations['GetClientList']
  }
  '/clients/verify': {
    /**
     * Verify a client
     * @description Verifies the client in the provided token
     */
    post: operations['VerifyClient']
  }
  '/clients/{client_id}': {
    /**
     * Get a client
     * @description Returns the details of a client.
     */
    get: operations['GetClient']
  }
  '/email_addresses': {
    /**
     * Create an email address
     * @description Create a new email address
     */
    post: operations['CreateEmailAddress']
  }
  '/email_addresses/{email_address_id}': {
    /**
     * Retrieve an email address
     * @description Returns the details of an email address.
     */
    get: operations['GetEmailAddress']
    /**
     * Delete an email address
     * @description Delete the email address with the given ID
     */
    delete: operations['DeleteEmailAddress']
    /**
     * Update an email address
     * @description Updates an email address.
     */
    patch: operations['UpdateEmailAddress']
  }
  '/phone_numbers': {
    /**
     * Create a phone number
     * @description Create a new phone number
     */
    post: operations['CreatePhoneNumber']
  }
  '/phone_numbers/{phone_number_id}': {
    /**
     * Retrieve a phone number
     * @description Returns the details of a phone number
     */
    get: operations['GetPhoneNumber']
    /**
     * Delete a phone number
     * @description Delete the phone number with the given ID
     */
    delete: operations['DeletePhoneNumber']
    /**
     * Update a phone number
     * @description Updates a phone number
     */
    patch: operations['UpdatePhoneNumber']
  }
  '/sessions': {
    /**
     * List all sessions
     * @description Returns a list of all sessions.
     * The sessions are returned sorted by creation date, with the newest sessions appearing first.
     * **Deprecation Notice (2024-01-01):** All parameters were initially considered optional, however
     * moving forward at least one of `client_id` or `user_id` parameters should be provided.
     */
    get: operations['GetSessionList']
  }
  '/sessions/{session_id}': {
    /**
     * Retrieve a session
     * @description Retrieve the details of a session
     */
    get: operations['GetSession']
  }
  '/sessions/{session_id}/revoke': {
    /**
     * Revoke a session
     * @description Sets the status of a session as "revoked", which is an unauthenticated state.
     * In multi-session mode, a revoked session will still be returned along with its client object, however the user will need to sign in again.
     */
    post: operations['RevokeSession']
  }
  '/sessions/{session_id}/verify': {
    /**
     * Verify a session
     * @deprecated
     * @description Returns the session if it is authenticated, otherwise returns an error.
     * WARNING: This endpoint is deprecated and will be removed in future versions. We strongly recommend switching to networkless verification using short-lived session tokens,
     *          which is implemented transparently in all recent SDK versions (e.g. [NodeJS SDK](https://clerk.com/docs/backend-requests/handling/nodejs#clerk-express-require-auth)).
     *          For more details on how networkless verification works, refer to our [Session Tokens documentation](https://clerk.com/docs/backend-requests/resources/session-tokens).
     */
    post: operations['VerifySession']
  }
  '/sessions/{session_id}/tokens/{template_name}': {
    /**
     * Create a session token from a jwt template
     * @description Creates a JSON Web Token(JWT) based on a session and a JWT Template name defined for your instance
     */
    post: operations['CreateSessionTokenFromTemplate']
  }
  '/templates/{template_type}': {
    /**
     * List all templates
     * @deprecated
     * @description Returns a list of all templates.
     * The templates are returned sorted by position.
     */
    get: operations['GetTemplateList']
  }
  '/templates/{template_type}/{slug}': {
    /**
     * Retrieve a template
     * @deprecated
     * @description Returns the details of a template
     */
    get: operations['GetTemplate']
    /**
     * Update a template for a given type and slug
     * @deprecated
     * @description Updates the existing template of the given type and slug
     */
    put: operations['UpsertTemplate']
  }
  '/templates/{template_type}/{slug}/revert': {
    /**
     * Revert a template
     * @deprecated
     * @description Reverts an updated template to its default state
     */
    post: operations['RevertTemplate']
  }
  '/templates/{template_type}/{slug}/preview': {
    /**
     * Preview changes to a template
     * @deprecated
     * @description Returns a preview of a template for a given template_type, slug and body
     */
    post: operations['PreviewTemplate']
  }
  '/templates/{template_type}/{slug}/toggle_delivery': {
    /**
     * Toggle the delivery by Clerk for a template of a given type and slug
     * @deprecated
     * @description Toggles the delivery by Clerk for a template of a given type and slug.
     * If disabled, Clerk will not deliver the resulting email or SMS.
     * The app developer will need to listen to the `email.created` or `sms.created` webhooks in order to handle delivery themselves.
     */
    post: operations['ToggleTemplateDelivery']
  }
  '/users': {
    /**
     * List all users
     * @description Returns a list of all users.
     * The users are returned sorted by creation date, with the newest users appearing first.
     */
    get: operations['GetUserList']
    /**
     * Create a new user
     * @description Creates a new user. Your user management settings determine how you should setup your user model.
     *
     * Any email address and phone number created using this method will be marked as verified.
     *
     * Note: If you are performing a migration, check out our guide on [zero downtime migrations](https://clerk.com/docs/deployments/migrate-overview).
     *
     * A rate limit rule of 20 requests per 10 seconds is applied to this endpoint.
     */
    post: operations['CreateUser']
  }
  '/users/count': {
    /**
     * Count users
     * @description Returns a total count of all users that match the given filtering criteria.
     */
    get: operations['GetUsersCount']
  }
  '/users/{user_id}': {
    /**
     * Retrieve a user
     * @description Retrieve the details of a user
     */
    get: operations['GetUser']
    /**
     * Delete a user
     * @description Delete the specified user
     */
    delete: operations['DeleteUser']
    /**
     * Update a user
     * @description Update a user's attributes.
     *
     * You can set the user's primary contact identifiers (email address and phone numbers) by updating the `primary_email_address_id` and `primary_phone_number_id` attributes respectively.
     * Both IDs should correspond to verified identifications that belong to the user.
     *
     * You can remove a user's username by setting the username attribute to null or the blank string "".
     * This is a destructive action; the identification will be deleted forever.
     * Usernames can be removed only if they are optional in your instance settings and there's at least one other identifier which can be used for authentication.
     *
     * This endpoint allows changing a user's password. When passing the `password` parameter directly you have two further options.
     * You can ignore the password policy checks for your instance by setting the `skip_password_checks` parameter to `true`.
     * You can also choose to sign the user out of all their active sessions on any device once the password is updated. Just set `sign_out_of_other_sessions` to `true`.
     */
    patch: operations['UpdateUser']
  }
  '/users/{user_id}/ban': {
    /**
     * Ban a user
     * @description Marks the given user as banned, which means that all their sessions are revoked and they are not allowed to sign in again.
     */
    post: operations['BanUser']
  }
  '/users/{user_id}/unban': {
    /**
     * Unban a user
     * @description Removes the ban mark from the given user.
     */
    post: operations['UnbanUser']
  }
  '/users/{user_id}/lock': {
    /**
     * Lock a user
     * @description Marks the given user as locked, which means they are not allowed to sign in again until the lock expires.
     * Lock duration can be configured in the instance's restrictions settings.
     */
    post: operations['LockUser']
  }
  '/users/{user_id}/unlock': {
    /**
     * Unlock a user
     * @description Removes the lock from the given user.
     */
    post: operations['UnlockUser']
  }
  '/users/{user_id}/profile_image': {
    /**
     * Set user profile image
     * @description Update a user's profile image
     */
    post: operations['SetUserProfileImage']
    /**
     * Delete user profile image
     * @description Delete a user's profile image
     */
    delete: operations['DeleteUserProfileImage']
  }
  '/users/{user_id}/metadata': {
    /**
     * Merge and update a user's metadata
     * @description Update a user's metadata attributes by merging existing values with the provided parameters.
     *
     * This endpoint behaves differently than the *Update a user* endpoint.
     * Metadata values will not be replaced entirely.
     * Instead, a deep merge will be performed.
     * Deep means that any nested JSON objects will be merged as well.
     *
     * You can remove metadata keys at any level by setting their value to `null`.
     */
    patch: operations['UpdateUserMetadata']
  }
  '/users/{user_id}/oauth_access_tokens/{provider}': {
    /**
     * Retrieve the OAuth access token of a user
     * @description Fetch the corresponding OAuth access token for a user that has previously authenticated with a particular OAuth provider.
     * For OAuth 2.0, if the access token has expired and we have a corresponding refresh token, the access token will be refreshed transparently the new one will be returned.
     */
    get: operations['GetOAuthAccessToken']
  }
  '/users/{user_id}/organization_memberships': {
    /**
     * Retrieve all memberships for a user
     * @description Retrieve a paginated list of the user's organization memberships
     */
    get: operations['UsersGetOrganizationMemberships']
  }
  '/users/{user_id}/verify_password': {
    /**
     * Verify the password of a user
     * @description Check that the user's password matches the supplied input.
     * Useful for custom auth flows and re-verification.
     */
    post: operations['VerifyPassword']
  }
  '/users/{user_id}/verify_totp': {
    /**
     * Verify a TOTP or backup code for a user
     * @description Verify that the provided TOTP or backup code is valid for the user.
     * Verifying a backup code will result it in being consumed (i.e. it will
     * become invalid).
     * Useful for custom auth flows and re-verification.
     */
    post: operations['VerifyTOTP']
  }
  '/users/{user_id}/mfa': {
    /**
     * Disable a user's MFA methods
     * @description Disable all of a user's MFA methods (e.g. OTP sent via SMS, TOTP on their authenticator app) at once.
     */
    delete: operations['DisableMFA']
  }
  '/invitations': {
    /**
     * List all invitations
     * @description Returns all non-revoked invitations for your application, sorted by creation date
     */
    get: operations['ListInvitations']
    /**
     * Create an invitation
     * @description Creates a new invitation for the given email address and sends the invitation email.
     * Keep in mind that you cannot create an invitation if there is already one for the given email address.
     * Also, trying to create an invitation for an email address that already exists in your application will result to an error.
     */
    post: operations['CreateInvitation']
  }
  '/invitations/{invitation_id}/revoke': {
    /**
     * Revokes an invitation
     * @description Revokes the given invitation.
     * Revoking an invitation will prevent the user from using the invitation link that was sent to them.
     * However, it doesn't prevent the user from signing up if they follow the sign up flow.
     * Only active (i.e. non-revoked) invitations can be revoked.
     */
    post: operations['RevokeInvitation']
  }
  '/allowlist_identifiers': {
    /**
     * List all identifiers on the allow-list
     * @description Get a list of all identifiers allowed to sign up to an instance
     */
    get: operations['ListAllowlistIdentifiers']
    /**
     * Add identifier to the allow-list
     * @description Create an identifier allowed to sign up to an instance
     */
    post: operations['CreateAllowlistIdentifier']
  }
  '/allowlist_identifiers/{identifier_id}': {
    /**
     * Delete identifier from allow-list
     * @description Delete an identifier from the instance allow-list
     */
    delete: operations['DeleteAllowlistIdentifier']
  }
  '/blocklist_identifiers': {
    /**
     * List all identifiers on the block-list
     * @description Get a list of all identifiers which are not allowed to access an instance
     */
    get: operations['ListBlocklistIdentifiers']
    /**
     * Add identifier to the block-list
     * @description Create an identifier that is blocked from accessing an instance
     */
    post: operations['CreateBlocklistIdentifier']
  }
  '/blocklist_identifiers/{identifier_id}': {
    /**
     * Delete identifier from block-list
     * @description Delete an identifier from the instance block-list
     */
    delete: operations['DeleteBlocklistIdentifier']
  }
  '/beta_features/instance_settings': {
    /**
     * Update instance settings
     * @description Updates the settings of an instance
     */
    patch: operations['UpdateInstanceAuthConfig']
  }
  '/beta_features/domain': {
    /**
     * Update production instance domain
     * @deprecated
     * @description Change the domain of a production instance.
     *
     * Changing the domain requires updating the [DNS records](https://clerk.com/docs/deployments/overview#dns-records) accordingly, deploying new [SSL certificates](https://clerk.com/docs/deployments/overview#deploy), updating your Social Connection's redirect URLs and setting the new keys in your code.
     *
     * WARNING: Changing your domain will invalidate all current user sessions (i.e. users will be logged out). Also, while your application is being deployed, a small downtime is expected to occur.
     */
    put: operations['UpdateProductionInstanceDomain']
  }
  '/actor_tokens': {
    /**
     * Create actor token
     * @description Create an actor token that can be used to impersonate the given user.
     * The `actor` parameter needs to include at least a "sub" key whose value is the ID of the actor (impersonating) user.
     */
    post: operations['CreateActorToken']
  }
  '/actor_tokens/{actor_token_id}/revoke': {
    /**
     * Revoke actor token
     * @description Revokes a pending actor token.
     */
    post: operations['RevokeActorToken']
  }
  '/domains': {
    /**
     * List all instance domains
     * @description Use this endpoint to get a list of all domains for an instance.
     * The response will contain the primary domain for the instance and any satellite domains. Each domain in the response contains information about the URLs where Clerk operates and the required CNAME targets.
     */
    get: operations['ListDomains']
    /**
     * Add a domain
     * @description Add a new domain for your instance.
     * Useful in the case of multi-domain instances, allows adding satellite domains to an instance.
     * The new domain must have a `name`. The domain name can contain the port for development instances, like `localhost:3000`.
     * At the moment, instances can have only one primary domain, so the `is_satellite` parameter must be set to `true`.
     * If you're planning to configure the new satellite domain to run behind a proxy, pass the `proxy_url` parameter accordingly.
     */
    post: operations['AddDomain']
  }
  '/domains/{domain_id}': {
    /**
     * Delete a satellite domain
     * @description Deletes a satellite domain for the instance.
     * It is currently not possible to delete the instance's primary domain.
     */
    delete: operations['DeleteDomain']
    /**
     * Update a domain
     * @description The `proxy_url` can be updated only for production instances.
     * Update one of the instance's domains. Both primary and satellite domains can be updated.
     * If you choose to use Clerk via proxy, use this endpoint to specify the `proxy_url`.
     * Whenever you decide you'd rather switch to DNS setup for Clerk, simply set `proxy_url`
     * to `null` for the domain. When you update a production instance's primary domain name,
     * you have to make sure that you've completed all the necessary setup steps for DNS and
     * emails to work. Expect downtime otherwise. Updating a primary domain's name will also
     * update the instance's home origin, affecting the default application paths.
     */
    patch: operations['UpdateDomain']
  }
  '/instance': {
    /**
     * Update instance settings
     * @description Updates the settings of an instance
     */
    patch: operations['UpdateInstance']
  }
  '/instance/restrictions': {
    /**
     * Update instance restrictions
     * @description Updates the restriction settings of an instance
     */
    patch: operations['UpdateInstanceRestrictions']
  }
  '/instance/change_domain': {
    /**
     * Update production instance domain
     * @description Change the domain of a production instance.
     *
     * Changing the domain requires updating the [DNS records](https://clerk.com/docs/deployments/overview#dns-records) accordingly, deploying new [SSL certificates](https://clerk.com/docs/deployments/overview#deploy), updating your Social Connection's redirect URLs and setting the new keys in your code.
     *
     * WARNING: Changing your domain will invalidate all current user sessions (i.e. users will be logged out). Also, while your application is being deployed, a small downtime is expected to occur.
     */
    post: operations['ChangeProductionInstanceDomain']
  }
  '/instance/organization_settings': {
    /**
     * Update instance organization settings
     * @description Updates the organization settings of the instance
     */
    patch: operations['UpdateInstanceOrganizationSettings']
  }
  '/webhooks/svix': {
    /**
     * Create a Svix app
     * @description Create a Svix app and associate it with the current instance
     */
    post: operations['CreateSvixApp']
    /**
     * Delete a Svix app
     * @description Delete a Svix app and disassociate it from the current instance
     */
    delete: operations['DeleteSvixApp']
  }
  '/webhooks/svix_url': {
    /**
     * Create a Svix Dashboard URL
     * @description Generate a new url for accessing the Svix's management dashboard for that particular instance
     */
    post: operations['GenerateSvixAuthURL']
  }
  '/jwt_templates': {
    /** List all templates */
    get: operations['ListJWTTemplates']
    /**
     * Create a JWT template
     * @description Create a new JWT template
     */
    post: operations['CreateJWTTemplate']
  }
  '/jwt_templates/{template_id}': {
    /**
     * Retrieve a template
     * @description Retrieve the details of a given JWT template
     */
    get: operations['GetJWTTemplate']
    /** Delete a Template */
    delete: operations['DeleteJWTTemplate']
    /**
     * Update a JWT template
     * @description Updates an existing JWT template
     */
    patch: operations['UpdateJWTTemplate']
  }
  '/organizations': {
    /**
     * Get a list of organizations for an instance
     * @description This request returns the list of organizations for an instance.
     * Results can be paginated using the optional `limit` and `offset` query parameters.
     * The organizations are ordered by descending creation date.
     * Most recent organizations will be returned first.
     */
    get: operations['ListOrganizations']
    /**
     * Create an organization
     * @description Creates a new organization with the given name for an instance.
     * In order to successfully create an organization you need to provide the ID of the User who will become the organization administrator.
     * You can specify an optional slug for the new organization.
     * If provided, the organization slug can contain only lowercase alphanumeric characters (letters and digits) and the dash "-".
     * Organization slugs must be unique for the instance.
     * You can provide additional metadata for the organization and set any custom attribute you want.
     * Organizations support private and public metadata.
     * Private metadata can only be accessed from the Backend API.
     * Public metadata can be accessed from the Backend API, and are read-only from the Frontend API.
     */
    post: operations['CreateOrganization']
  }
  '/organizations/{organization_id}': {
    /**
     * Retrieve an organization by ID or slug
     * @description Fetches the organization whose ID or slug matches the provided `id_or_slug` URL query parameter.
     */
    get: operations['GetOrganization']
    /**
     * Delete an organization
     * @description Deletes the given organization.
     * Please note that deleting an organization will also delete all memberships and invitations.
     * This is not reversible.
     */
    delete: operations['DeleteOrganization']
    /**
     * Update an organization
     * @description Updates an existing organization
     */
    patch: operations['UpdateOrganization']
  }
  '/organizations/{organization_id}/metadata': {
    /**
     * Merge and update metadata for an organization
     * @description Update organization metadata attributes by merging existing values with the provided parameters.
     * Metadata values will be updated via a deep merge.
     * Deep meaning that any nested JSON objects will be merged as well.
     * You can remove metadata keys at any level by setting their value to `null`.
     */
    patch: operations['MergeOrganizationMetadata']
  }
  '/organizations/{organization_id}/logo': {
    /**
     * Upload a logo for the organization
     * @description Set or replace an organization's logo, by uploading an image file.
     * This endpoint uses the `multipart/form-data` request content type and accepts a file of image type.
     * The file size cannot exceed 10MB.
     * Only the following file content types are supported: `image/jpeg`, `image/png`, `image/gif`, `image/webp`, `image/x-icon`, `image/vnd.microsoft.icon`.
     */
    put: operations['UploadOrganizationLogo']
    /** @description Delete the organization's logo. */
    delete: operations['DeleteOrganizationLogo']
  }
  '/organizations/{organization_id}/invitations': {
    /**
     * Get a list of organization invitations
     * @description This request returns the list of organization invitations.
     * Results can be paginated using the optional `limit` and `offset` query parameters.
     * You can filter them by providing the 'status' query parameter, that accepts multiple values.
     * The organization invitations are ordered by descending creation date.
     * Most recent invitations will be returned first.
     * Any invitations created as a result of an Organization Domain are not included in the results.
     */
    get: operations['ListOrganizationInvitations']
    /**
     * Create and send an organization invitation
     * @description Creates a new organization invitation and sends an email to the provided `email_address` with a link to accept the invitation and join the organization.
     * You can specify the `role` for the invited organization member.
     *
     * New organization invitations get a "pending" status until they are revoked by an organization administrator or accepted by the invitee.
     *
     * The request body supports passing an optional `redirect_url` parameter.
     * When the invited user clicks the link to accept the invitation, they will be redirected to the URL provided.
     * Use this parameter to implement a custom invitation acceptance flow.
     *
     * You must specify the ID of the user that will send the invitation with the `inviter_user_id` parameter.
     * That user must be a member with administrator privileges in the organization.
     * Only "admin" members can create organization invitations.
     *
     * You can optionally provide public and private metadata for the organization invitation.
     * The public metadata are visible by both the Frontend and the Backend whereas the private ones only by the Backend.
     * When the organization invitation is accepted, the metadata will be transferred to the newly created organization membership.
     */
    post: operations['CreateOrganizationInvitation']
  }
  '/organizations/{organization_id}/invitations/bulk': {
    /**
     * Bulk create and send organization invitations
     * @description Creates new organization invitations in bulk and sends out emails to the provided email addresses with a link to accept the invitation and join the organization.
     * You can specify a different `role` for each invited organization member.
     * New organization invitations get a "pending" status until they are revoked by an organization administrator or accepted by the invitee.
     * The request body supports passing an optional `redirect_url` parameter for each invitation.
     * When the invited user clicks the link to accept the invitation, they will be redirected to the provided URL.
     * Use this parameter to implement a custom invitation acceptance flow.
     * You must specify the ID of the user that will send the invitation with the `inviter_user_id` parameter. Each invitation
     * can have a different inviter user.
     * Inviter users must be members with administrator privileges in the organization.
     * Only "admin" members can create organization invitations.
     * You can optionally provide public and private metadata for each organization invitation. The public metadata are visible
     * by both the Frontend and the Backend, whereas the private metadata are only visible by the Backend.
     * When the organization invitation is accepted, the metadata will be transferred to the newly created organization membership.
     */
    post: operations['CreateOrganizationInvitationBulk']
  }
  '/organizations/{organization_id}/invitations/pending': {
    /**
     * Get a list of pending organization invitations
     * @deprecated
     * @description This request returns the list of organization invitations with "pending" status.
     * These are the organization invitations that can still be used to join the organization, but have not been accepted by the invited user yet.
     * Results can be paginated using the optional `limit` and `offset` query parameters.
     * The organization invitations are ordered by descending creation date.
     * Most recent invitations will be returned first.
     * Any invitations created as a result of an Organization Domain are not included in the results.
     */
    get: operations['ListPendingOrganizationInvitations']
  }
  '/organizations/{organization_id}/invitations/{invitation_id}': {
    /**
     * Retrieve an organization invitation by ID
     * @description Use this request to get an existing organization invitation by ID.
     */
    get: operations['GetOrganizationInvitation']
  }
  '/organizations/{organization_id}/invitations/{invitation_id}/revoke': {
    /**
     * Revoke a pending organization invitation
     * @description Use this request to revoke a previously issued organization invitation.
     * Revoking an organization invitation makes it invalid; the invited user will no longer be able to join the organization with the revoked invitation.
     * Only organization invitations with "pending" status can be revoked.
     * The request needs the `requesting_user_id` parameter to specify the user which revokes the invitation.
     * Only users with "admin" role can revoke invitations.
     */
    post: operations['RevokeOrganizationInvitation']
  }
  '/organizations/{organization_id}/memberships': {
    /**
     * Get a list of all members of an organization
     * @description Retrieves all user memberships for the given organization
     */
    get: operations['ListOrganizationMemberships']
    /**
     * Create a new organization membership
     * @description Adds a user as a member to the given organization.
     * Only users in the same instance as the organization can be added as members.
     */
    post: operations['CreateOrganizationMembership']
  }
  '/organizations/{organization_id}/memberships/{user_id}': {
    /**
     * Remove a member from an organization
     * @description Removes the given membership from the organization
     */
    delete: operations['DeleteOrganizationMembership']
    /**
     * Update an organization membership
     * @description Updates the properties of an existing organization membership
     */
    patch: operations['UpdateOrganizationMembership']
  }
  '/organizations/{organization_id}/memberships/{user_id}/metadata': {
    /**
     * Merge and update organization membership metadata
     * @description Update an organization membership's metadata attributes by merging existing values with the provided parameters.
     * Metadata values will be updated via a deep merge. Deep means that any nested JSON objects will be merged as well.
     * You can remove metadata keys at any level by setting their value to `null`.
     */
    patch: operations['UpdateOrganizationMembershipMetadata']
  }
  '/proxy_checks': {
    /**
     * Verify the proxy configuration for your domain
     * @description This endpoint can be used to validate that a proxy-enabled domain is operational.
     * It tries to verify that the proxy URL provided in the parameters maps to a functional proxy that can reach the Clerk Frontend API.
     *
     * You can use this endpoint before you set a proxy URL for a domain. This way you can ensure that switching to proxy-based
     * configuration will not lead to downtime for your instance.
     *
     * The `proxy_url` parameter allows for testing proxy configurations for domains that don't have a proxy URL yet, or operate on
     * a different proxy URL than the one provided. It can also be used to re-validate a domain that is already configured to work with a proxy.
     */
    post: operations['VerifyDomainProxy']
  }
  '/redirect_urls': {
    /**
     * List all redirect URLs
     * @description Lists all whitelisted redirect_urls for the instance
     */
    get: operations['ListRedirectURLs']
    /**
     * Create a redirect URL
     * @description Create a redirect URL
     */
    post: operations['CreateRedirectURL']
  }
  '/redirect_urls/{id}': {
    /**
     * Retrieve a redirect URL
     * @description Retrieve the details of the redirect URL with the given ID
     */
    get: operations['GetRedirectURL']
    /**
     * Delete a redirect URL
     * @description Remove the selected redirect URL from the whitelist of the instance
     */
    delete: operations['DeleteRedirectURL']
  }
  '/sign_in_tokens': {
    /**
     * Create sign-in token
     * @description Creates a new sign-in token and associates it with the given user.
     * By default, sign-in tokens expire in 30 days.
     * You can optionally supply a different duration in seconds using the `expires_in_seconds` property.
     */
    post: operations['CreateSignInToken']
  }
  '/sign_in_tokens/{sign_in_token_id}/revoke': {
    /**
     * Revoke the given sign-in token
     * @description Revokes a pending sign-in token
     */
    post: operations['RevokeSignInToken']
  }
  '/sign_ups/{id}': {
    /**
     * Update a sign-up
     * @description Update the sign-up with the given ID
     */
    patch: operations['UpdateSignUp']
  }
  '/oauth_applications': {
    /**
     * Get a list of OAuth applications for an instance
     * @description This request returns the list of OAuth applications for an instance.
     * Results can be paginated using the optional `limit` and `offset` query parameters.
     * The OAuth applications are ordered by descending creation date.
     * Most recent OAuth applications will be returned first.
     */
    get: operations['ListOAuthApplications']
    /**
     * Create an OAuth application
     * @description Creates a new OAuth application with the given name and callback URL for an instance.
     * The callback URL must be a valid url.
     * All URL schemes are allowed such as `http://`, `https://`, `myapp://`, etc...
     */
    post: operations['CreateOAuthApplication']
  }
  '/oauth_applications/{oauth_application_id}': {
    /**
     * Retrieve an OAuth application by ID
     * @description Fetches the OAuth application whose ID matches the provided `id` in the path.
     */
    get: operations['GetOAuthApplication']
    /**
     * Delete an OAuth application
     * @description Deletes the given OAuth application.
     * This is not reversible.
     */
    delete: operations['DeleteOAuthApplication']
    /**
     * Update an OAuth application
     * @description Updates an existing OAuth application
     */
    patch: operations['UpdateOAuthApplication']
  }
  '/oauth_applications/{oauth_application_id}/rotate_secret': {
    /**
     * Rotate the client secret of the given OAuth application
     * @description Rotates the OAuth application's client secret.
     * When the client secret is rotated, make sure to update it in authorized OAuth clients.
     */
    post: operations['RotateOAuthApplicationSecret']
  }
  '/saml_connections': {
    /**
     * Get a list of SAML Connections for an instance
     * @description Returns the list of SAML Connections for an instance.
     * Results can be paginated using the optional `limit` and `offset` query parameters.
     * The SAML Connections are ordered by descending creation date and the most recent will be returned first.
     */
    get: operations['ListSAMLConnections']
    /**
     * Create a SAML Connection
     * @description Create a new SAML Connection.
     */
    post: operations['CreateSAMLConnection']
  }
  '/saml_connections/{saml_connection_id}': {
    /**
     * Retrieve a SAML Connection by ID
     * @description Fetches the SAML Connection whose ID matches the provided `saml_connection_id` in the path.
     */
    get: operations['GetSAMLConnection']
    /**
     * Delete a SAML Connection
     * @description Deletes the SAML Connection whose ID matches the provided `id` in the path.
     */
    delete: operations['DeleteSAMLConnection']
    /**
     * Update a SAML Connection
     * @description Updates the SAML Connection whose ID matches the provided `id` in the path.
     */
    patch: operations['UpdateSAMLConnection']
  }
  '/testing_tokens': {
    /**
     * Retrieve a new testing token
     * @description Retrieve a new testing token. Only available for development instances.
     */
    post: operations['CreateTestingToken']
  }
}

export type webhooks = Record<string, never>

export interface components {
  schemas: {
    Session: {
      /**
       * @description String representing the object's type. Objects of the same type share the same value.
       *
       * @enum {string}
       */
      object: 'session'
      id: string
      user_id: string
      client_id: string
      actor?: unknown
      /** @enum {string} */
      status:
        | 'active'
        | 'revoked'
        | 'ended'
        | 'expired'
        | 'removed'
        | 'abandoned'
        | 'replaced'
      last_active_organization_id?: string | null
      last_active_at: number
      expire_at: number
      abandon_at: number
      /**
       * Format: int64
       * @description Unix timestamp of last update.
       */
      updated_at: number
      /**
       * Format: int64
       * @description Unix timestamp of creation.
       */
      created_at: number
    }
    Client: {
      /**
       * @description String representing the object's type. Objects of the same type share the same value.
       *
       * @enum {string}
       */
      object: 'client'
      /** @description String representing the identifier of the session. */
      id: string
      session_ids: string[]
      sessions: components['schemas']['Session'][]
      sign_in_id: string | null
      sign_up_id: string | null
      /** @description Last active session_id. */
      last_active_session_id: string | null
      /**
       * Format: int64
       * @description Unix timestamp of last update.
       */
      updated_at: number
      /**
       * Format: int64
       * @description Unix timestamp of creation.
       */
      created_at: number
    }
    ClerkError: {
      message: string
      long_message: string
      code: string
      meta?: Record<string, never>
      clerk_trace_id?: string
    }
    ClerkErrors: {
      errors: components['schemas']['ClerkError'][]
      meta?: Record<string, never>
    }
    OTP: {
      /** @enum {string} */
      status: 'unverified' | 'verified' | 'failed' | 'expired'
      /** @enum {string} */
      strategy: 'phone_code' | 'email_code' | 'reset_password_email_code'
      attempts: number
      expire_at: number
    }
    Admin: {
      /** @enum {string} */
      status: 'verified'
      /** @enum {string} */
      strategy: 'admin'
      attempts?: number | null
      expire_at?: number | null
    }
    Oauth: {
      /** @enum {string} */
      status: 'unverified' | 'verified' | 'failed' | 'expired' | 'transferable'
      /** @enum {string} */
      strategy: 'oauth_google' | 'oauth_mock' | 'oauth_custom_mock'
      external_verification_redirect_url?: string
      error?: components['schemas']['ClerkError'] | null
      expire_at: number
      attempts?: number | null
    }
    IdentificationLink: {
      /** @enum {string} */
      type: 'oauth_google' | 'oauth_mock' | 'saml'
      id: string
    }
    EmailAddress: {
      id?: string
      /**
       * @description String representing the object's type. Objects of the same type share the same value.
       *
       * @enum {string}
       */
      object: 'email_address'
      email_address: string
      reserved: boolean
      verification:
        | components['schemas']['OTP']
        | components['schemas']['Admin']
        | components['schemas']['Oauth']
        | null
      linked_to: components['schemas']['IdentificationLink'][]
      /**
       * Format: int64
       * @description Unix timestamp of creation
       */
      created_at: number
      /**
       * Format: int64
       * @description Unix timestamp of creation
       */
      updated_at: number
    }
    DeletedObject: {
      object: string
      id?: string
      slug?: string
      deleted: boolean
    }
    PhoneNumber: {
      id?: string
      /**
       * @description String representing the object's type. Objects of the same type share the same value.
       *
       * @enum {string}
       */
      object: 'phone_number'
      phone_number: string
      reserved_for_second_factor?: boolean
      default_second_factor?: boolean
      reserved: boolean
      verification:
        | components['schemas']['OTP']
        | components['schemas']['Admin']
        | null
      linked_to: components['schemas']['IdentificationLink'][]
      backup_codes?: string[] | null
      /**
       * Format: int64
       * @description Unix timestamp of creation
       */
      created_at: number
      /**
       * Format: int64
       * @description Unix timestamp of creation
       */
      updated_at: number
    }
    Template: {
      id?: string
      /**
       * @description String representing the object's type. Objects of the same type share the same value.
       *
       * @enum {string}
       */
      object?: 'template'
      /** @description the id of the instance the template belongs to */
      instance_id?: string | null
      /** @description whether this is a system (default) or user overridden) template */
      resource_type?: string
      /** @description whether this is an email or SMS template */
      template_type?: string
      /** @description user-friendly name of the template */
      name?: string
      /** @description machine-friendly name of the template */
      slug?: string
      /** @description position with the listing of templates */
      position?: number
      /** @description whether this template can be reverted to the corresponding system default */
      can_revert?: boolean
      /** @description whether this template can be deleted */
      can_delete?: boolean
      /** @description whether this template can be enabled or disabled, true only for notification SMS templates */
      can_toggle?: boolean
      /** @description email subject */
      subject?: string | null
      /** @description the editor markup used to generate the body of the template */
      markup?: string
      /** @description the template body before variable interpolation */
      body?: string
      /** @description list of variables that are available for use in the template body */
      available_variables?: string[]
      /** @description list of variables that must be contained in the template body */
      required_variables?: string[]
      from_email_name?: string
      reply_to_email_name?: string
      delivered_by_clerk?: boolean
      enabled?: boolean
      /**
       * Format: int64
       * @description Unix timestamp of last update.
       */
      updated_at?: number
      /**
       * Format: int64
       * @description Unix timestamp of creation.
       */
      created_at?: number
    }
    Web3Signature: {
      /** @enum {string} */
      status: 'verified'
      /** @enum {string} */
      strategy: 'web3_metamask_signature'
      /** @enum {string} */
      nonce: 'nonce'
      attempts?: number | null
      expire_at?: number | null
    }
    Web3Wallet: {
      id?: string
      /**
       * @description String representing the object's type. Objects of the same type share the same value.
       *
       * @enum {string}
       */
      object: 'web3_wallet'
      web3_wallet: string
      verification:
        | components['schemas']['Web3Signature']
        | components['schemas']['Admin']
        | null
      /**
       * Format: int64
       * @description Unix timestamp of creation
       */
      created_at: number
      /**
       * Format: int64
       * @description Unix timestamp of creation
       */
      updated_at: number
    }
    Passkey: {
      /** @enum {string} */
      status: 'verified'
      /** @enum {string} */
      strategy: 'passkey'
      /** @enum {string} */
      nonce?: 'nonce'
      attempts?: number | null
      expire_at?: number | null
    }
    'schemas-Passkey': {
      id?: string
      /**
       * @description String representing the object's type. Objects of the same type share the same value.
       *
       * @enum {string}
       */
      object: 'passkey'
      name: string
      /**
       * Format: int64
       * @description Unix timestamp of when the passkey was last used.
       */
      last_used_at: number
      verification: components['schemas']['Passkey'] | null
    }
    SAML: {
      /** @enum {string} */
      status: 'unverified' | 'verified' | 'failed' | 'expired' | 'transferable'
      /** @enum {string} */
      strategy: 'saml'
      external_verification_redirect_url: string | null
      error?: components['schemas']['ClerkError'] | null
      expire_at: number
      attempts?: number | null
    }
    Ticket: {
      /** @enum {string} */
      status: 'unverified' | 'verified' | 'expired'
      /** @enum {string} */
      strategy: 'ticket'
      attempts?: number | null
      expire_at?: number | null
    }
    SAMLAccount: {
      id: string
      /**
       * @description String representing the object's type. Objects of the same type share the same value.
       *
       * @enum {string}
       */
      object: 'saml_account'
      provider: string
      active: boolean
      email_address: string
      first_name?: string | null
      last_name?: string | null
      provider_user_id?: string | null
      public_metadata?: Record<string, never>
      verification:
        | components['schemas']['SAML']
        | components['schemas']['Ticket']
        | null
    }
    User: {
      id?: string
      /**
       * @description String representing the object's type. Objects of the same type share the same value.
       *
       * @enum {string}
       */
      object?: 'user'
      external_id?: string | null
      primary_email_address_id?: string | null
      primary_phone_number_id?: string | null
      primary_web3_wallet_id?: string | null
      username?: string | null
      first_name?: string | null
      last_name?: string | null
      /** @deprecated */
      profile_image_url?: string
      image_url?: string
      has_image?: boolean
      public_metadata?: Record<string, never>
      private_metadata?: unknown
      unsafe_metadata?: Record<string, never>
      email_addresses?: components['schemas']['EmailAddress'][]
      phone_numbers?: components['schemas']['PhoneNumber'][]
      web3_wallets?: components['schemas']['Web3Wallet'][]
      passkeys?: components['schemas']['schemas-Passkey'][]
      password_enabled?: boolean
      two_factor_enabled?: boolean
      totp_enabled?: boolean
      backup_code_enabled?: boolean
      /**
       * Format: int64
       * @description Unix timestamp of when MFA was last enabled for this user. It should be noted that this field is not nullified if MFA is disabled.
       */
      mfa_enabled_at?: number | null
      /**
       * Format: int64
       * @description Unix timestamp of when MFA was last disabled for this user. It should be noted that this field is not nullified if MFA is enabled again.
       */
      mfa_disabled_at?: number | null
      external_accounts?: Record<string, never>[]
      saml_accounts?: components['schemas']['SAMLAccount'][]
      /**
       * Format: int64
       * @description Unix timestamp of last sign-in.
       */
      last_sign_in_at?: number | null
      /** @description Flag to denote whether user is banned or not. */
      banned?: boolean
      /** @description Flag to denote whether user is currently locked, i.e. restricted from signing in or not. */
      locked?: boolean
      /**
       * Format: int64
       * @description The number of seconds remaining until the lockout period expires for a locked user. A null value for a locked user indicates that lockout never expires.
       */
      lockout_expires_in_seconds?: number | null
      /**
       * Format: int64
       * @description The number of verification attempts remaining until the user is locked. Null if account lockout is not enabled. Note: if a user is locked explicitly via the Backend API, they may still have verification attempts remaining.
       */
      verification_attempts_remaining?: number | null
      /**
       * Format: int64
       * @description Unix timestamp of last update.
       */
      updated_at?: number
      /**
       * Format: int64
       * @description Unix timestamp of creation.
       */
      created_at?: number
      /** @description If enabled, user can delete themselves via FAPI. */
      delete_self_enabled?: boolean
      /** @description If enabled, user can create organizations via FAPI. */
      create_organization_enabled?: boolean
      /**
       * Format: int64
       * @description Unix timestamp of the latest session activity, with day precision.
       *
       * @example 1700690400000
       */
      last_active_at?: number | null
    }
    TotalCount: {
      /**
       * @description String representing the object's type. Objects of the same type share the same value.
       *
       * @enum {string}
       */
      object: 'total_count'
      /** Format: int64 */
      total_count: number
    }
    Organization: {
      /** @enum {string} */
      object: 'organization'
      id: string
      name: string
      slug: string
      members_count?: number | null
      max_allowed_memberships: number
      admin_delete_enabled?: boolean
      public_metadata: Record<string, never>
      private_metadata: Record<string, never>
      created_by?: string
      /**
       * Format: int64
       * @description Unix timestamp of creation.
       */
      created_at: number
      /**
       * Format: int64
       * @description Unix timestamp of last update.
       */
      updated_at: number
    }
    /** @description Hello world */
    OrganizationMembership: {
      id?: string
      /**
       * @description String representing the object's type. Objects of the same type share the same value.
       *
       * @enum {string}
       */
      object?: 'organization_membership'
      role?: string
      permissions?: string[]
      /** @description Metadata saved on the organization membership, accessible from both Frontend and Backend APIs */
      public_metadata?: Record<string, never>
      /** @description Metadata saved on the organization membership, accessible only from the Backend API */
      private_metadata?: Record<string, never>
      organization?: components['schemas']['Organization']
      public_user_data?: {
        user_id?: string
        first_name?: string | null
        last_name?: string | null
        /** @deprecated */
        profile_image_url?: string | null
        image_url?: string
        has_image?: boolean
        identifier?: string | null
      }
      /**
       * Format: int64
       * @description Unix timestamp of creation.
       */
      created_at?: number
      /**
       * Format: int64
       * @description Unix timestamp of last update.
       */
      updated_at?: number
    }
    OrganizationMemberships: {
      data: components['schemas']['OrganizationMembership'][]
      /**
       * Format: int64
       * @description Total number of organization memberships
       */
      total_count: number
    }
    Invitation: {
      /** @enum {string} */
      object: 'invitation'
      id: string
      /** Format: email */
      email_address: string
      public_metadata?: Record<string, never>
      /** @example false */
      revoked?: boolean
      /**
       * @example pending
       * @enum {string}
       */
      status: 'pending' | 'accepted' | 'revoked'
      url?: string | null
      /**
       * Format: int64
       * @description Unix timestamp of creation.
       */
      created_at: number
      /**
       * Format: int64
       * @description Unix timestamp of last update.
       */
      updated_at: number
    }
    AllowlistIdentifier: {
      /**
       * @description String representing the object's type. Objects of the same type share the same value.
       *
       * @enum {string}
       */
      object?: 'allowlist_identifier'
      id?: string
      invitation_id?: string
      /** @description An email address or a phone number. */
      identifier?: string
      /** @enum {string} */
      identifier_type?: 'email_address' | 'phone_number' | 'web3_wallet'
      instance_id?: string
      /**
       * Format: int64
       * @description Unix timestamp of creation
       */
      created_at?: number
      /**
       * Format: int64
       * @description Unix timestamp of last update.
       */
      updated_at?: number
    }
    BlocklistIdentifier: {
      /**
       * @description String representing the object's type. Objects of the same type share the same value.
       *
       * @enum {string}
       */
      object?: 'blocklist_identifier'
      id?: string
      /** @description An email address, email domain, phone number or web3 wallet. */
      identifier?: string
      /** @enum {string} */
      identifier_type?: 'email_address' | 'phone_number' | 'web3_wallet'
      instance_id?: string
      /**
       * Format: int64
       * @description Unix timestamp of creation
       */
      created_at?: number
      /**
       * Format: int64
       * @description Unix timestamp of last update.
       */
      updated_at?: number
    }
    BlocklistIdentifiers: {
      data: components['schemas']['BlocklistIdentifier'][]
      /**
       * Format: int64
       * @description Total number of blocklist identifiers
       */
      total_count: number
    }
    ActorToken: {
      /** @enum {string} */
      object: 'actor_token'
      id: string
      /** @enum {string} */
      status: 'pending' | 'accepted' | 'revoked'
      user_id: string
      actor: Record<string, never>
      token?: string | null
      url?: string | null
      /**
       * Format: int64
       * @description Unix timestamp of creation.
       */
      created_at: number
      /**
       * Format: int64
       * @description Unix timestamp of last update.
       */
      updated_at: number
    }
    CNameTarget: {
      host: string
      value: string
      /** @description Denotes whether this CNAME target is required to be set in order for the domain to be considered deployed. */
      required: boolean
    }
    Domain: {
      /** @enum {string} */
      object: 'domain'
      id: string
      name: string
      is_satellite: boolean
      frontend_api_url: string
      /** @description Null for satellite domains. */
      accounts_portal_url?: string | null
      proxy_url?: string | null
      development_origin: string
      cname_targets?: components['schemas']['CNameTarget'][] | null
    }
    Domains: {
      data: components['schemas']['Domain'][]
      /**
       * Format: int64
       * @description Total number of domains
       */
      total_count: number
    }
    InstanceRestrictions: {
      /**
       * @description String representing the object's type. Objects of the same type share the same value.
       * @enum {string}
       */
      object?: 'instance_restrictions'
      allowlist?: boolean
      blocklist?: boolean
      block_email_subaddresses?: boolean
      ignore_dots_for_gmail_addresses?: boolean
    }
    OrganizationSettings: {
      /**
       * @description String representing the object's type. Objects of the same type share the same value.
       * @enum {string}
       */
      object: 'organization_settings'
      enabled: boolean
      max_allowed_memberships: number
      max_allowed_roles?: number
      max_allowed_permissions?: number
      /** @description The role key that a user will be assigned after creating an organization. */
      creator_role: string
      /** @description The default for whether an admin can delete an organization with the Frontend API. */
      admin_delete_enabled: boolean
      domains_enabled: boolean
      domains_enrollment_modes: (
        | 'manual_invitation'
        | 'automatic_invitation'
        | 'automatic_suggestion'
      )[]
      /** @description The role key that it will be used in order to create an organization invitation or suggestion. */
      domains_default_role: string
    }
    SvixURL: {
      svix_url: string
    }
    JWTTemplate: {
      /** @enum {string} */
      object: 'jwt_template'
      id: string
      name: string
      claims: Record<string, never>
      lifetime: number
      allowed_clock_skew: number
      custom_signing_key?: boolean
      signing_algorithm?: string
      /**
       * Format: int64
       * @description Unix timestamp of creation.
       */
      created_at: number
      /**
       * Format: int64
       * @description Unix timestamp of last update.
       */
      updated_at: number
    }
    Organizations: {
      data: components['schemas']['Organization'][]
      /**
       * Format: int64
       * @description Total number of organizations
       */
      total_count: number
    }
    OrganizationWithLogo: components['schemas']['Organization'] & {
      /** @deprecated */
      logo_url?: string
      image_url: string
      has_image?: boolean
    }
    /** @description An organization invitation */
    OrganizationInvitation: {
      id?: string
      /**
       * @description String representing the object's type. Objects of the same type share the same value.
       *
       * @enum {string}
       */
      object?: 'organization_invitation'
      email_address?: string
      role?: string
      organization_id?: string
      status?: string
      public_metadata?: Record<string, never>
      private_metadata?: Record<string, never>
      /**
       * Format: int64
       * @description Unix timestamp of creation.
       */
      created_at?: number
      /**
       * Format: int64
       * @description Unix timestamp of last update.
       */
      updated_at?: number
    }
    OrganizationInvitations: {
      data: components['schemas']['OrganizationInvitation'][]
      /**
       * Format: int64
       * @description Total number of organization invitations
       */
      total_count: number
    }
    ProxyCheck: {
      /** @enum {string} */
      object: 'proxy_check'
      id: string
      domain_id: string
      last_run_at: number
      proxy_url: string
      successful: boolean
      created_at: number
      updated_at: number
    }
    RedirectURL: {
      /** @enum {string} */
      object: 'redirect_url'
      id: string
      url: string
      /**
       * Format: int64
       * @description Unix timestamp of creation.
       */
      created_at: number
      /**
       * Format: int64
       * @description Unix timestamp of last update.
       */
      updated_at: number
    }
    SignInToken: {
      /** @enum {string} */
      object: 'sign_in_token'
      id: string
      /** @enum {string} */
      status: 'pending' | 'accepted' | 'revoked'
      user_id: string
      token?: string
      url?: string | null
      /**
       * Format: int64
       * @description Unix timestamp of creation.
       */
      created_at: number
      /**
       * Format: int64
       * @description Unix timestamp of last update.
       */
      updated_at: number
    }
    SignUp: {
      /** @enum {string} */
      object: 'sign_up_attempt'
      id: string
      /** @enum {string} */
      status: 'missing_requirements' | 'complete' | 'abandoned'
      required_fields?: string[]
      optional_fields?: string[]
      missing_fields?: string[]
      unverified_fields?: string[]
      verifications?: Record<string, never>
      username?: string | null
      email_address?: string | null
      phone_number?: string | null
      web3_wallet?: string | null
      password_enabled: boolean
      first_name?: string | null
      last_name?: string | null
      unsafe_metadata?: Record<string, never>
      public_metadata?: Record<string, never>
      custom_action: boolean
      external_id?: string | null
      created_session_id?: string | null
      created_user_id?: string | null
      abandon_at: number
      external_account?: Record<string, never>
    }
    OAuthApplication: {
      /** @enum {string} */
      object: 'oauth_application'
      id: string
      instance_id: string
      name: string
      client_id: string
      public: boolean
      scopes: string
      callback_url: string
      authorize_url: string
      token_fetch_url: string
      user_info_url: string
      /**
       * Format: int64
       * @description Unix timestamp of creation.
       */
      created_at: number
      /**
       * Format: int64
       * @description Unix timestamp of last update.
       */
      updated_at: number
    }
    OAuthApplications: {
      data: components['schemas']['OAuthApplication'][]
      /**
       * Format: int64
       * @description Total number of OAuth applications
       */
      total_count: number
    }
    OAuthApplicationWithSecret: components['schemas']['OAuthApplication'] & {
      /** @description Empty if public client. */
      client_secret?: string
    }
    SAMLConnection: {
      /** @enum {string} */
      object: 'saml_connection'
      id: string
      name: string
      domain: string
      idp_entity_id: string | null
      idp_sso_url: string | null
      idp_certificate: string | null
      idp_metadata_url?: string | null
      idp_metadata?: string | null
      acs_url: string
      sp_entity_id: string
      sp_metadata_url: string
      attribute_mapping?: {
        user_id?: string
        email_address?: string
        first_name?: string
        last_name?: string
      }
      active: boolean
      provider: string
      user_count: number
      sync_user_attributes: boolean
      allow_subdomains?: boolean
      allow_idp_initiated?: boolean
      /**
       * Format: int64
       * @description Unix timestamp of creation.
       */
      created_at: number
      /**
       * Format: int64
       * @description Unix timestamp of last update.
       */
      updated_at: number
    }
    SAMLConnections: {
      data: components['schemas']['SAMLConnection'][]
      /**
       * Format: int64
       * @description Total number of SAML Connections
       */
      total_count: number
    }
    TestingToken: {
      /** @enum {string} */
      object: 'testing_token'
      /**
       * @description The actual token. This value is meant to be passed in the `__clerk_testing_token` query parameter with requests to the Frontend API.
       * @example 1713877200-c_2J2MvPu9PnXcuhbPZNao0LOXqK9A7YrnBn0HmIWxy
       */
      token: string
      /**
       * Format: int64
       * @description Unix timestamp of the token's expiration time.
       *
       * @example 1713880800
       */
      expires_at: number
    }
  }
  responses: {
    /** @description Success */
    'Client.List': {
      content: {
        'application/json': components['schemas']['Client'][]
      }
    }
    /** @description Request was not successful */
    ClerkErrors: {
      content: {
        'application/json': components['schemas']['ClerkErrors']
      }
    }
    /** @description Authentication invalid */
    AuthenticationInvalid: {
      content: {
        'application/json': components['schemas']['ClerkErrors']
      }
    }
    /** @description The endpoint is considered deprecated and is pending removal. */
    DeprecatedEndpoint: {
      content: {
        'application/json': components['schemas']['ClerkErrors']
      }
    }
    /** @description Invalid request parameters */
    UnprocessableEntity: {
      content: {
        'application/json': components['schemas']['ClerkErrors']
      }
    }
    /** @description Success */
    Client: {
      content: {
        'application/json': components['schemas']['Client']
      }
    }
    /** @description Resource not found */
    ResourceNotFound: {
      content: {
        'application/json': components['schemas']['ClerkErrors']
      }
    }
    /** @description Success */
    EmailAddress: {
      content: {
        'application/json': components['schemas']['EmailAddress']
      }
    }
    /** @description Authorization invalid */
    AuthorizationInvalid: {
      content: {
        'application/json': components['schemas']['ClerkErrors']
      }
    }
    /** @description Deleted Object */
    DeletedObject: {
      content: {
        'application/json': components['schemas']['DeletedObject']
      }
    }
    /** @description Success */
    PhoneNumber: {
      content: {
        'application/json': components['schemas']['PhoneNumber']
      }
    }
    /** @description Success */
    'Session.List': {
      content: {
        'application/json': components['schemas']['Session'][]
      }
    }
    /** @description Success */
    Session: {
      content: {
        'application/json': components['schemas']['Session']
      }
    }
    /** @description Success */
    'Template.List': {
      content: {
        'application/json': components['schemas']['Template'][]
      }
    }
    /** @description Success */
    Template: {
      content: {
        'application/json': components['schemas']['Template']
      }
    }
    /** @description Payment required */
    PaymentRequired: {
      content: {
        'application/json': components['schemas']['ClerkErrors']
      }
    }
    /** @description Success */
    'User.List': {
      content: {
        'application/json': components['schemas']['User'][]
      }
    }
    /** @description Success */
    User: {
      content: {
        'application/json': components['schemas']['User']
      }
    }
    /** @description Success */
    'User.Count': {
      content: {
        'application/json': components['schemas']['TotalCount']
      }
    }
    /** @description A list of organization memberships */
    OrganizationMemberships: {
      content: {
        'application/json': components['schemas']['OrganizationMemberships']
      }
    }
    /** @description List of invitations */
    'Invitation.List': {
      content: {
        'application/json': components['schemas']['Invitation'][]
      }
    }
    /** @description Success */
    Invitation: {
      content: {
        'application/json': components['schemas']['Invitation']
      }
    }
    /** @description Success */
    'Invitation.Revoked': {
      content: {
        'application/json': components['schemas']['Invitation'] & {
          /**
           * @example true
           * @enum {boolean}
           */
          revoked?: true
          /**
           * @example revoked
           * @enum {string}
           */
          status?: 'revoked'
        }
      }
    }
    /** @description Success */
    'AllowlistIdentifier.List': {
      content: {
        'application/json': components['schemas']['AllowlistIdentifier'][]
      }
    }
    /** @description Success */
    AllowlistIdentifier: {
      content: {
        'application/json': components['schemas']['AllowlistIdentifier']
      }
    }
    /** @description Success */
    'BlocklistIdentifier.List': {
      content: {
        'application/json': components['schemas']['BlocklistIdentifiers']
      }
    }
    /** @description Success */
    BlocklistIdentifier: {
      content: {
        'application/json': components['schemas']['BlocklistIdentifier']
      }
    }
    /** @description InstanceSettings Server API */
    InstanceSettings: {
      content: {
        'application/json': {
          /**
           * @description String representing the object's type. Objects of the same type share the same value.
           * @enum {string}
           */
          object?: 'instance_settings'
          id?: string
          restricted_to_allowlist?: boolean
          from_email_address?: string
          progressive_sign_up?: boolean
          enhanced_email_deliverability?: boolean
        }
      }
    }
    /** @description Success */
    ActorToken: {
      content: {
        'application/json': components['schemas']['ActorToken']
      }
    }
    /** @description A list of domains */
    Domains: {
      content: {
        'application/json': components['schemas']['Domains']
      }
    }
    /** @description A domain */
    Domain: {
      content: {
        'application/json': components['schemas']['Domain']
      }
    }
    /** @description Success */
    InstanceRestrictions: {
      content: {
        'application/json': components['schemas']['InstanceRestrictions']
      }
    }
    /** @description Success */
    OrganizationSettings: {
      content: {
        'application/json': components['schemas']['OrganizationSettings']
      }
    }
    /** @description Response that contains a temporary Svix URL to access management dashboard */
    SvixURL: {
      content: {
        'application/json': components['schemas']['SvixURL']
      }
    }
    /** @description List of JWT templates */
    'JWTTemplate.List': {
      content: {
        'application/json': components['schemas']['JWTTemplate'][]
      }
    }
    /** @description Success */
    JWTTemplate: {
      content: {
        'application/json': components['schemas']['JWTTemplate']
      }
    }
    /** @description A list of organizations */
    Organizations: {
      content: {
        'application/json': components['schemas']['Organizations']
      }
    }
    /** @description An organization */
    Organization: {
      content: {
        'application/json': components['schemas']['Organization']
      }
    }
    /** @description An organization with a logo URL. */
    OrganizationWithLogo: {
      content: {
        'application/json': components['schemas']['OrganizationWithLogo']
      }
    }
    /** @description A list of organization invitations */
    OrganizationInvitations: {
      content: {
        'application/json': components['schemas']['OrganizationInvitations']
      }
    }
    /** @description An organization invitation */
    OrganizationInvitation: {
      content: {
        'application/json': components['schemas']['OrganizationInvitation']
      }
    }
    /** @description Success */
    OrganizationMembership: {
      content: {
        'application/json': components['schemas']['OrganizationMembership']
      }
    }
    /** @description Health check information about a domain's proxy configuration validation attempt. */
    ProxyCheck: {
      content: {
        'application/json': components['schemas']['ProxyCheck']
      }
    }
    /** @description List of Redirect URLs */
    'RedirectURL.List': {
      content: {
        'application/json': components['schemas']['RedirectURL'][]
      }
    }
    /** @description Success */
    RedirectURL: {
      content: {
        'application/json': components['schemas']['RedirectURL']
      }
    }
    /** @description Success */
    SignInToken: {
      content: {
        'application/json': components['schemas']['SignInToken']
      }
    }
    /** @description Success */
    SignUp: {
      content: {
        'application/json': components['schemas']['SignUp']
      }
    }
    /** @description A list of OAuth applications */
    OAuthApplications: {
      content: {
        'application/json': components['schemas']['OAuthApplications']
      }
    }
    /** @description An OAuth application with client secret */
    OAuthApplicationWithSecret: {
      content: {
        'application/json': components['schemas']['OAuthApplicationWithSecret']
      }
    }
    /** @description An OAuth application */
    OAuthApplication: {
      content: {
        'application/json': components['schemas']['OAuthApplication']
      }
    }
    /** @description A list of SAML Connections */
    SAMLConnections: {
      content: {
        'application/json': components['schemas']['SAMLConnections']
      }
    }
    /** @description A SAML Connection */
    SAMLConnection: {
      content: {
        'application/json': components['schemas']['SAMLConnection']
      }
    }
    /** @description A Testing Token */
    TestingToken: {
      content: {
        'application/json': components['schemas']['TestingToken']
      }
    }
  }
  parameters: {
    /**
     * @description Applies a limit to the number of results returned.
     * Can be used for paginating the results together with `offset`.
     */
    LimitParameter?: number
    /**
     * @description Skip the first `offset` results when paginating.
     * Needs to be an integer greater or equal to zero.
     * To be used in conjunction with `limit`.
     */
    OffsetParameter?: number
  }
  requestBodies: never
  headers: never
  pathItems: never
}

export type $defs = Record<string, never>

export type external = Record<string, never>

export interface operations {
  /**
   * Returns the markup for the interstitial page
   * @description The Clerk interstitial endpoint serves an html page that loads clerk.js in order to check the user's authentication state.
   * It is used by Clerk SDKs when the user's authentication state cannot be immediately determined.
   */
  GetPublicInterstitial: {
    parameters: {
      query?: {
        /** @description The Frontend API key of your instance */
        frontendApi?: string
        /** @description The publishable key of your instance */
        publishable_key?: string
      }
    }
    responses: {
      /** @description The interstitial page markup */
      200: {
        content: never
      }
      /** @description A required query parameter is missing */
      400: {
        content: never
      }
      /** @description An infinite redirect loop was detected */
      500: {
        content: never
      }
    }
  }
  /**
   * Retrieve the JSON Web Key Set of the instance
   * @description Retrieve the JSON Web Key Set of the instance
   */
  GetJWKS: {
    responses: {
      /** @description The JSON Web Key Set */
      200: {
        content: never
      }
    }
  }
  /**
   * List all clients
   * @deprecated
   * @description Returns a list of all clients. The clients are returned sorted by creation date,
   * with the newest clients appearing first.
   * Warning: the endpoint is being deprecated and will be removed in future versions.
   */
  GetClientList: {
    parameters: {
      query?: {
        limit?: components['parameters']['LimitParameter']
        offset?: components['parameters']['OffsetParameter']
      }
    }
    responses: {
      200: components['responses']['Client.List']
      400: components['responses']['ClerkErrors']
      401: components['responses']['AuthenticationInvalid']
      410: components['responses']['DeprecatedEndpoint']
      422: components['responses']['UnprocessableEntity']
    }
  }
  /**
   * Verify a client
   * @description Verifies the client in the provided token
   */
  VerifyClient: {
    /** @description Parameters. */
    requestBody?: {
      content: {
        'application/json': {
          /** @description A JWT Token that represents the active client. */
          token?: string
        }
      }
    }
    responses: {
      200: components['responses']['Client']
      400: components['responses']['ClerkErrors']
      401: components['responses']['AuthenticationInvalid']
      404: components['responses']['ResourceNotFound']
    }
  }
  /**
   * Get a client
   * @description Returns the details of a client.
   */
  GetClient: {
    parameters: {
      path: {
        /** @description Client ID. */
        client_id: string
      }
    }
    responses: {
      200: components['responses']['Client']
      400: components['responses']['ClerkErrors']
      401: components['responses']['AuthenticationInvalid']
      404: components['responses']['ResourceNotFound']
    }
  }
  /**
   * Create an email address
   * @description Create a new email address
   */
  CreateEmailAddress: {
    requestBody?: {
      content: {
        'application/json': {
          /** @description The ID representing the user */
          user_id?: string
          /** @description The new email address. Must adhere to the RFC 5322 specification for email address format. */
          email_address?: string
          /** @description When created, the email address will be marked as verified. */
          verified?: boolean | null
          /**
           * @description Create this email address as the primary email address for the user.
           * Default: false, unless it is the first email address.
           */
          primary?: boolean | null
        }
      }
    }
    responses: {
      200: components['responses']['EmailAddress']
      400: components['responses']['ClerkErrors']
      401: components['responses']['AuthenticationInvalid']
      403: components['responses']['AuthorizationInvalid']
      404: components['responses']['ResourceNotFound']
      422: components['responses']['UnprocessableEntity']
    }
  }
  /**
   * Retrieve an email address
   * @description Returns the details of an email address.
   */
  GetEmailAddress: {
    parameters: {
      path: {
        /** @description The ID of the email address to retrieve */
        email_address_id: string
      }
    }
    responses: {
      200: components['responses']['EmailAddress']
      400: components['responses']['ClerkErrors']
      401: components['responses']['AuthenticationInvalid']
      403: components['responses']['AuthorizationInvalid']
      404: components['responses']['ResourceNotFound']
    }
  }
  /**
   * Delete an email address
   * @description Delete the email address with the given ID
   */
  DeleteEmailAddress: {
    parameters: {
      path: {
        /** @description The ID of the email address to delete */
        email_address_id: string
      }
    }
    responses: {
      200: components['responses']['DeletedObject']
      400: components['responses']['ClerkErrors']
      401: components['responses']['AuthenticationInvalid']
      403: components['responses']['AuthorizationInvalid']
      404: components['responses']['ResourceNotFound']
    }
  }
  /**
   * Update an email address
   * @description Updates an email address.
   */
  UpdateEmailAddress: {
    parameters: {
      path: {
        /** @description The ID of the email address to update */
        email_address_id: string
      }
    }
    requestBody?: {
      content: {
        'application/json': {
          /** @description The email address will be marked as verified. */
          verified?: boolean | null
          /** @description Set this email address as the primary email address for the user. */
          primary?: boolean | null
        }
      }
    }
    responses: {
      200: components['responses']['EmailAddress']
      400: components['responses']['ClerkErrors']
      401: components['responses']['AuthenticationInvalid']
      403: components['responses']['AuthorizationInvalid']
      404: components['responses']['ResourceNotFound']
    }
  }
  /**
   * Create a phone number
   * @description Create a new phone number
   */
  CreatePhoneNumber: {
    requestBody?: {
      content: {
        'application/json': {
          /** @description The ID representing the user */
          user_id?: string
          /** @description The new phone number. Must adhere to the E.164 standard for phone number format. */
          phone_number?: string
          /** @description When created, the phone number will be marked as verified. */
          verified?: boolean | null
          /**
           * @description Create this phone number as the primary phone number for the user.
           * Default: false, unless it is the first phone number.
           */
          primary?: boolean | null
          /**
           * @description Create this phone number as reserved for multi-factor authentication.
           * The phone number must also be verified.
           * If there are no other reserved second factors, the phone number will be set as the default second factor.
           */
          reserved_for_second_factor?: boolean | null
        }
      }
    }
    responses: {
      200: components['responses']['PhoneNumber']
      400: components['responses']['ClerkErrors']
      401: components['responses']['AuthenticationInvalid']
      403: components['responses']['AuthorizationInvalid']
      404: components['responses']['ResourceNotFound']
      422: components['responses']['UnprocessableEntity']
    }
  }
  /**
   * Retrieve a phone number
   * @description Returns the details of a phone number
   */
  GetPhoneNumber: {
    parameters: {
      path: {
        /** @description The ID of the phone number to retrieve */
        phone_number_id: string
      }
    }
    responses: {
      200: components['responses']['PhoneNumber']
      400: components['responses']['ClerkErrors']
      401: components['responses']['AuthenticationInvalid']
      403: components['responses']['AuthorizationInvalid']
      404: components['responses']['ResourceNotFound']
    }
  }
  /**
   * Delete a phone number
   * @description Delete the phone number with the given ID
   */
  DeletePhoneNumber: {
    parameters: {
      path: {
        /** @description The ID of the phone number to delete */
        phone_number_id: string
      }
    }
    responses: {
      200: components['responses']['DeletedObject']
      400: components['responses']['ClerkErrors']
      401: components['responses']['AuthenticationInvalid']
      403: components['responses']['AuthorizationInvalid']
      404: components['responses']['ResourceNotFound']
    }
  }
  /**
   * Update a phone number
   * @description Updates a phone number
   */
  UpdatePhoneNumber: {
    parameters: {
      path: {
        /** @description The ID of the phone number to update */
        phone_number_id: string
      }
    }
    requestBody?: {
      content: {
        'application/json': {
          /** @description The phone number will be marked as verified. */
          verified?: boolean | null
          /** @description Set this phone number as the primary phone number for the user. */
          primary?: boolean | null
          /**
           * @description Set this phone number as reserved for multi-factor authentication.
           * The phone number must also be verified.
           * If there are no other reserved second factors, the phone number will be set as the default second factor.
           */
          reserved_for_second_factor?: boolean | null
        }
      }
    }
    responses: {
      200: components['responses']['PhoneNumber']
      400: components['responses']['ClerkErrors']
      401: components['responses']['AuthenticationInvalid']
      403: components['responses']['AuthorizationInvalid']
      404: components['responses']['ResourceNotFound']
    }
  }
  /**
   * List all sessions
   * @description Returns a list of all sessions.
   * The sessions are returned sorted by creation date, with the newest sessions appearing first.
   * **Deprecation Notice (2024-01-01):** All parameters were initially considered optional, however
   * moving forward at least one of `client_id` or `user_id` parameters should be provided.
   */
  GetSessionList: {
    parameters: {
      query?: {
        /** @description List sessions for the given client */
        client_id?: string
        /** @description List sessions for the given user */
        user_id?: string
        /** @description Filter sessions by the provided status */
        status?:
          | 'abandoned'
          | 'active'
          | 'ended'
          | 'expired'
          | 'removed'
          | 'replaced'
          | 'revoked'
        limit?: components['parameters']['LimitParameter']
        offset?: components['parameters']['OffsetParameter']
      }
    }
    responses: {
      200: components['responses']['Session.List']
      400: components['responses']['ClerkErrors']
      401: components['responses']['AuthenticationInvalid']
      422: components['responses']['UnprocessableEntity']
    }
  }
  /**
   * Retrieve a session
   * @description Retrieve the details of a session
   */
  GetSession: {
    parameters: {
      path: {
        /** @description The ID of the session */
        session_id: string
      }
    }
    responses: {
      200: components['responses']['Session']
      400: components['responses']['ClerkErrors']
      401: components['responses']['AuthenticationInvalid']
      404: components['responses']['ResourceNotFound']
    }
  }
  /**
   * Revoke a session
   * @description Sets the status of a session as "revoked", which is an unauthenticated state.
   * In multi-session mode, a revoked session will still be returned along with its client object, however the user will need to sign in again.
   */
  RevokeSession: {
    parameters: {
      path: {
        /** @description The ID of the session */
        session_id: string
      }
    }
    responses: {
      200: components['responses']['Session']
      400: components['responses']['ClerkErrors']
      401: components['responses']['AuthenticationInvalid']
      404: components['responses']['ResourceNotFound']
    }
  }
  /**
   * Verify a session
   * @deprecated
   * @description Returns the session if it is authenticated, otherwise returns an error.
   * WARNING: This endpoint is deprecated and will be removed in future versions. We strongly recommend switching to networkless verification using short-lived session tokens,
   *          which is implemented transparently in all recent SDK versions (e.g. [NodeJS SDK](https://clerk.com/docs/backend-requests/handling/nodejs#clerk-express-require-auth)).
   *          For more details on how networkless verification works, refer to our [Session Tokens documentation](https://clerk.com/docs/backend-requests/resources/session-tokens).
   */
  VerifySession: {
    parameters: {
      path: {
        /** @description The ID of the session */
        session_id: string
      }
    }
    /** @description Parameters. */
    requestBody?: {
      content: {
        'application/json': {
          /**
           * @description The JWT that is sent via the `__session` cookie from your frontend.
           * Note: this JWT must be associated with the supplied session ID.
           */
          token?: string
        }
      }
    }
    responses: {
      200: components['responses']['Session']
      400: components['responses']['ClerkErrors']
      401: components['responses']['AuthenticationInvalid']
      404: components['responses']['ResourceNotFound']
      410: components['responses']['DeprecatedEndpoint']
    }
  }
  /**
   * Create a session token from a jwt template
   * @description Creates a JSON Web Token(JWT) based on a session and a JWT Template name defined for your instance
   */
  CreateSessionTokenFromTemplate: {
    parameters: {
      path: {
        /** @description The ID of the session */
        session_id: string
        /** @description The name of the JWT Template defined in your instance (e.g. `custom_hasura`). */
        template_name: string
      }
    }
    responses: {
      /** @description OK */
      200: {
        content: {
          'application/json': {
            /** @enum {string} */
            object?: 'token'
            jwt?: string
          }
        }
      }
      401: components['responses']['AuthenticationInvalid']
      404: components['responses']['ResourceNotFound']
    }
  }
  /**
   * List all templates
   * @deprecated
   * @description Returns a list of all templates.
   * The templates are returned sorted by position.
   */
  GetTemplateList: {
    parameters: {
      path: {
        /** @description The type of templates to list (email or SMS) */
        template_type: 'email' | 'sms'
      }
    }
    responses: {
      200: components['responses']['Template.List']
      400: components['responses']['ClerkErrors']
      401: components['responses']['AuthenticationInvalid']
      422: components['responses']['UnprocessableEntity']
    }
  }
  /**
   * Retrieve a template
   * @deprecated
   * @description Returns the details of a template
   */
  GetTemplate: {
    parameters: {
      path: {
        /** @description The type of templates to retrieve (email or SMS) */
        template_type: 'email' | 'sms'
        /** @description The slug (i.e. machine-friendly name) of the template to retrieve */
        slug: string
      }
    }
    responses: {
      200: components['responses']['Template']
      400: components['responses']['ClerkErrors']
      401: components['responses']['AuthenticationInvalid']
      404: components['responses']['ResourceNotFound']
    }
  }
  /**
   * Update a template for a given type and slug
   * @deprecated
   * @description Updates the existing template of the given type and slug
   */
  UpsertTemplate: {
    parameters: {
      path: {
        /** @description The type of template to update */
        template_type: 'email' | 'sms'
        /** @description The slug of the template to update */
        slug: string
      }
    }
    requestBody?: {
      content: {
        'application/json': {
          /** @description The user-friendly name of the template */
          name?: string
          /**
           * @description The email subject.
           * Applicable only to email templates.
           */
          subject?: string | null
          /** @description The editor markup used to generate the body of the template */
          markup?: string | null
          /** @description The template body before variable interpolation */
          body?: string
          /** @description Whether Clerk should deliver emails or SMS messages based on the current template */
          delivered_by_clerk?: boolean | null
          /**
           * @description The local part of the From email address that will be used for emails.
           * For example, in the address 'hello@example.com', the local part is 'hello'.
           * Applicable only to email templates.
           */
          from_email_name?: string
          /**
           * @description The local part of the Reply To email address that will be used for emails.
           * For example, in the address 'hello@example.com', the local part is 'hello'.
           * Applicable only to email templates.
           */
          reply_to_email_name?: string
        }
      }
    }
    responses: {
      200: components['responses']['Template']
      400: components['responses']['ClerkErrors']
      401: components['responses']['AuthenticationInvalid']
      402: components['responses']['PaymentRequired']
      403: components['responses']['ClerkErrors']
      404: components['responses']['ResourceNotFound']
      422: components['responses']['UnprocessableEntity']
    }
  }
  /**
   * Revert a template
   * @deprecated
   * @description Reverts an updated template to its default state
   */
  RevertTemplate: {
    parameters: {
      path: {
        /** @description The type of template to revert */
        template_type: 'email' | 'sms'
        /** @description The slug of the template to revert */
        slug: string
      }
    }
    responses: {
      200: components['responses']['Template']
      400: components['responses']['ClerkErrors']
      401: components['responses']['AuthenticationInvalid']
      402: components['responses']['PaymentRequired']
      404: components['responses']['ResourceNotFound']
    }
  }
  /**
   * Preview changes to a template
   * @deprecated
   * @description Returns a preview of a template for a given template_type, slug and body
   */
  PreviewTemplate: {
    parameters: {
      path: {
        /** @description The type of template to preview */
        template_type: string
        /** @description The slug of the template to preview */
        slug: string
      }
    }
    /** @description Required parameters */
    requestBody?: {
      content: {
        'application/json': {
          /**
           * @description The email subject.
           * Applicable only to email templates.
           */
          subject?: string | null
          /** @description The template body before variable interpolation */
          body?: string
          /**
           * @description The local part of the From email address that will be used for emails.
           * For example, in the address 'hello@example.com', the local part is 'hello'.
           * Applicable only to email templates.
           */
          from_email_name?: string
          /**
           * @description The local part of the Reply To email address that will be used for emails.
           * For example, in the address 'hello@example.com', the local part is 'hello'.
           * Applicable only to email templates.
           */
          reply_to_email_name?: string
        }
      }
    }
    responses: {
      /** @description OK */
      200: {
        content: {
          'application/json': Record<string, never>
        }
      }
      400: components['responses']['ClerkErrors']
      401: components['responses']['AuthenticationInvalid']
      404: components['responses']['ResourceNotFound']
      422: components['responses']['UnprocessableEntity']
    }
  }
  /**
   * Toggle the delivery by Clerk for a template of a given type and slug
   * @deprecated
   * @description Toggles the delivery by Clerk for a template of a given type and slug.
   * If disabled, Clerk will not deliver the resulting email or SMS.
   * The app developer will need to listen to the `email.created` or `sms.created` webhooks in order to handle delivery themselves.
   */
  ToggleTemplateDelivery: {
    parameters: {
      path: {
        /** @description The type of template to toggle delivery for */
        template_type: 'email' | 'sms'
        /** @description The slug of the template for which to toggle delivery */
        slug: string
      }
    }
    requestBody?: {
      content: {
        'application/json': {
          /** @description Whether Clerk should deliver emails or SMS messages based on the current template */
          delivered_by_clerk?: boolean | null
        }
      }
    }
    responses: {
      200: components['responses']['Template']
      400: components['responses']['ClerkErrors']
      401: components['responses']['AuthenticationInvalid']
      404: components['responses']['ResourceNotFound']
    }
  }
  /**
   * List all users
   * @description Returns a list of all users.
   * The users are returned sorted by creation date, with the newest users appearing first.
   */
  GetUserList: {
    parameters: {
      query?: {
        /**
         * @description Returns users with the specified email addresses.
         * Accepts up to 100 email addresses.
         * Any email addresses not found are ignored.
         */
        email_address?: string[]
        /**
         * @description Returns users with the specified phone numbers.
         * Accepts up to 100 phone numbers.
         * Any phone numbers not found are ignored.
         */
        phone_number?: string[]
        /**
         * @description Returns users with the specified external ids.
         * For each external id, the `+` and `-` can be
         * prepended to the id, which denote whether the
         * respective external id should be included or
         * excluded from the result set.
         * Accepts up to 100 external ids.
         * Any external ids not found are ignored.
         */
        external_id?: string[]
        /**
         * @description Returns users with the specified usernames.
         * Accepts up to 100 usernames.
         * Any usernames not found are ignored.
         */
        username?: string[]
        /**
         * @description Returns users with the specified web3 wallet addresses.
         * Accepts up to 100 web3 wallet addresses.
         * Any web3 wallet addressed not found are ignored.
         */
        web3_wallet?: string[]
        /**
         * @description Returns users with the user ids specified.
         * For each user id, the `+` and `-` can be
         * prepended to the id, which denote whether the
         * respective user id should be included or
         * excluded from the result set.
         * Accepts up to 100 user ids.
         * Any user ids not found are ignored.
         */
        user_id?: string[]
        /**
         * @description Returns users that have memberships to the
         * given organizations.
         * For each organization id, the `+` and `-` can be
         * prepended to the id, which denote whether the
         * respective organization should be included or
         * excluded from the result set.
         * Accepts up to 100 organization ids.
         */
        organization_id?: string[]
        /**
         * @description Returns users that match the given query.
         * For possible matches, we check the email addresses, phone numbers, usernames, web3 wallets, user ids, first and last names.
         * The query value doesn't need to match the exact value you are looking for, it is capable of partial matches as well.
         */
        query?: string
        /**
         * @description Returns users that had session activity since the given date, with day precision.
         * Providing a value with higher precision than day will result in an error.
         * Example: use 1700690400000 to retrieve users that had session activity from 2023-11-23 until the current day.
         * @example 1700690400000
         */
        last_active_at_since?: number
        limit?: components['parameters']['LimitParameter']
        offset?: components['parameters']['OffsetParameter']
        /**
         * @description Allows to return users in a particular order.
         * At the moment, you can order the returned users by their `created_at`,`updated_at`,`email_address`,`web3wallet`,`first_name`,`last_name`,`phone_number`,`username`,`last_active_at`,`last_sign_in_at`.
         * In order to specify the direction, you can use the `+/-` symbols prepended in the property to order by.
         * For example, if you want users to be returned in descending order according to their `created_at` property, you can use `-created_at`.
         * If you don't use `+` or `-`, then `+` is implied. We only support one `order_by` parameter, and if multiple `order_by` parameters are provided, we will only keep the first one. For example,
         * if you pass `order_by=username&order_by=created_at`, we will consider only the first `order_by` parameter, which is `username`. The `created_at` parameter will be ignored in this case.
         */
        order_by?: string
      }
    }
    responses: {
      200: components['responses']['User.List']
      400: components['responses']['ClerkErrors']
      401: components['responses']['AuthenticationInvalid']
      422: components['responses']['UnprocessableEntity']
    }
  }
  /**
   * Create a new user
   * @description Creates a new user. Your user management settings determine how you should setup your user model.
   *
   * Any email address and phone number created using this method will be marked as verified.
   *
   * Note: If you are performing a migration, check out our guide on [zero downtime migrations](https://clerk.com/docs/deployments/migrate-overview).
   *
   * A rate limit rule of 20 requests per 10 seconds is applied to this endpoint.
   */
  CreateUser: {
    requestBody: {
      content: {
        'application/json': {
          /**
           * @description The ID of the user as used in your external systems or your previous authentication solution.
           * Must be unique across your instance.
           */
          external_id?: string | null
          /** @description The first name to assign to the user */
          first_name?: string | null
          /** @description The last name to assign to the user */
          last_name?: string | null
          /**
           * @description Email addresses to add to the user.
           * Must be unique across your instance.
           * The first email address will be set as the user's primary email address.
           */
          email_address?: string[]
          /**
           * @description Phone numbers to add to the user.
           * Must be unique across your instance.
           * The first phone number will be set as the user's primary phone number.
           */
          phone_number?: string[]
          /**
           * @description Web3 wallets to add to the user.
           * Must be unique across your instance.
           * The first wallet will be set as the user's primary wallet.
           */
          web3_wallet?: string[]
          /**
           * @description The username to give to the user.
           * It must be unique across your instance.
           */
          username?: string | null
          /**
           * @description The plaintext password to give the user.
           * Must be at least 8 characters long, and can not be in any list of hacked passwords.
           */
          password?: string | null
          /**
           * @description In case you already have the password digests and not the passwords, you can use them for the newly created user via this property.
           * The digests should be generated with one of the supported algorithms.
           * The hashing algorithm can be specified using the `password_hasher` property.
           */
          password_digest?: string
          /**
           * @description The hashing algorithm that was used to generate the password digest.
           * The algorithms we support at the moment are [bcrypt](https://en.wikipedia.org/wiki/Bcrypt), [bcrypt_sha256_django](https://docs.djangoproject.com/en/4.0/topics/auth/passwords/),
           * [md5](https://en.wikipedia.org/wiki/MD5), pbkdf2_sha256, pbkdf2_sha512, [pbkdf2_sha256_django](https://docs.djangoproject.com/en/4.0/topics/auth/passwords/),
           * [phpass](https://www.openwall.com/phpass/), [scrypt_firebase](https://firebaseopensource.com/projects/firebase/scrypt/),
           * [scrypt_werkzeug](https://werkzeug.palletsprojects.com/en/3.0.x/utils/#werkzeug.security.generate_password_hash), [sha256](https://en.wikipedia.org/wiki/SHA-2)
           * and the [argon2](https://argon2.online/) variants argon2i and argon2id.
           *
           * If you need support for any particular hashing algorithm, [please let us know](https://clerk.com/support).
           *
           * Note: for password hashers considered insecure (at this moment MD5 and SHA256), the corresponding user password hashes will be transparently migrated to Bcrypt (a secure hasher) upon the user's first successful password sign in.
           * Insecure schemes are marked with `(insecure)` in the list below.
           *
           * Each of the supported hashers expects the incoming digest to be in a particular format. Specifically:
           *
           * **bcrypt:** The digest should be of the following form:
           *
           * `$<algorithm version>$<cost>$<salt & hash>`
           *
           * **bcrypt_sha256_django:** This is the Django-specific variant of Bcrypt, using SHA256 hashing function. The format should be as follows (as exported from Django):
           *
           * `bcrypt_sha256$$<algorithm version>$<cost>$<salt & hash>`
           *
           * **md5** (insecure): The digest should follow the regular form e.g.:
           *
           * `5f4dcc3b5aa765d61d8327deb882cf99`
           *
           * **pbkdf2_sha256:** This is the PBKDF2 algorithm using the SHA256 hashing function. The format should be as follows:
           *
           * `pbkdf2_sha256$<iterations>$<salt>$<hash>`
           *
           * Note: Both the salt and the hash are expected to be base64-encoded.
           *
           * **pbkdf2_sha512:** This is the PBKDF2 algorithm using the SHA512 hashing function. The format should be as follows:
           *
           * `pbkdf2_sha512$<iterations>$<salt>$<hash>`
           *
           *   _iterations:_ The number of iterations used. Must be an integer less than 420000.
           *   _salt:_ The salt used when generating the hash. Must be less than 1024 bytes.
           *   _hash:_ The hex-encoded hash. Must have been generated with a key length less than 1024 bytes.
           *
           * **pbkdf2_sha256_django:** This is the Django-specific variant of PBKDF2 and the digest should have the following format (as exported from Django):
           *
           * `pbkdf2_sha256$<iterations>$<salt>$<hash>`
           *
           * Note: The salt is expected to be un-encoded, the hash is expected base64-encoded.
           *
           * **pbkdf2_sha1:** This is similar to pkbdf2_sha256_django, but with two differences:
           * 1. uses sha1 instead of sha256
           * 2. accepts the hash as a hex-encoded string
           *
           * The format is the following:
           *
           * `pbkdf2_sha1$<iterations>$<salt>$<hash-as-hex-string>`
           *
           * **phpass:** Portable public domain password hashing framework for use in PHP applications. Digests hashed with phpass have the following sections:
           *
           * The format is the following:
           *
           * `$P$<rounds><salt><encoded-checksum>`
           *
           * - $P$ is the prefix used to identify phpass hashes.
           * - rounds is a single character encoding a 6-bit integer representing the number of rounds used.
           * - salt is eight characters drawn from [./0-9A-Za-z], providing a 48-bit salt.
           * - checksum is 22 characters drawn from the same set, encoding the 128-bit checksum with MD5.
           *
           * **scrypt_firebase:** The Firebase-specific variant of scrypt.
           * The value is expected to have 6 segments separated by the $ character and include the following information:
           *
           * _hash:_ The actual Base64 hash. This can be retrieved when exporting the user from Firebase.
           * _salt:_ The salt used to generate the above hash. Again, this is given when exporting the user.
           * _signer key:_ The base64 encoded signer key.
           * _salt separator:_ The base64 encoded salt separator.
           * _rounds:_ The number of rounds the algorithm needs to run.
           * _memory cost:_ The cost of the algorithm run
           *
           * The first 2 (hash and salt) are per user and can be retrieved when exporting the user from Firebase.
           * The other 4 values (signer key, salt separator, rounds and memory cost) are project-wide settings and can be retrieved from the project's password hash parameters.
           *
           * Once you have all these, you can combine it in the following format and send this as the digest in order for Clerk to accept it:
           *
           * `<hash>$<salt>$<signer key>$<salt separator>$<rounds>$<memory cost>`
           *
           * **scrypt_werkzeug:** The Werkzeug-specific variant of scrypt.
           *
           *   The value is expected to have 3 segments separated by the $ character and include the following information:
           *
           *   _algorithm args:_ The algorithm used to generate the hash.
           *   _salt:_ The salt used to generate the above hash.
           *   _hash:_ The actual Base64 hash.
           *
           *   The algorithm args are the parameters used to generate the hash and are included in the digest.
           *
           * **argon2i:** Algorithms in the argon2 family generate digests that encode the following information:
           *
           * _version (v):_ The argon version, version 19 is assumed
           * _memory (m):_ The memory used by the algorithm (in kibibytes)
           * _iterations (t):_ The number of iterations to perform
           * _parallelism (p):_ The number of threads to use
           *
           * Parts are demarcated by the `$` character, with the first part identifying the algorithm variant.
           * The middle part is a comma-separated list of the encoding options (memory, iterations, parallelism).
           * The final part is the actual digest.
           *
           * `$argon2i$v=19$m=4096,t=3,p=1$4t6CL3P7YiHBtwESXawI8Hm20zJj4cs7/4/G3c187e0$m7RQFczcKr5bIR0IIxbpO2P0tyrLjf3eUW3M3QSwnLc`
           *
           * **argon2id:** See the previous algorithm for an explanation of the formatting.
           *
           * For the argon2id case, the value of the algorithm in the first part of the digest is `argon2id`:
           *
           * `$argon2id$v=19$m=64,t=4,p=8$Z2liZXJyaXNo$iGXEpMBTDYQ8G/71tF0qGjxRHEmR3gpGULcE93zUJVU`
           *
           * **sha256** (insecure): The digest should be a 64-length hex string, e.g.:
           *
           * `9f86d081884c7d659a2feaa0c55ad015a3bf4f1b2b0b822cd15d6c15b0f00a08`
           *
           * **sha256_salted** (insecure): The digest should be a 64-length hex string with a salt.
           *
           * The format is the following:
           *   `<hash>$<salt>`
           *
           * The value is expected to have 2 segments separated by the $ character and include the following information:
           *   _hash:_ The sha256 hash, a 64-length hex string.
           *   _salt:_ The salt used to generate the above hash. Must be between 1 and 1024 bits.
           * @enum {string}
           */
          password_hasher?:
            | 'argon2i'
            | 'argon2id'
            | 'bcrypt'
            | 'bcrypt_sha256_django'
            | 'md5'
            | 'pbkdf2_sha256'
            | 'pbkdf2_sha512'
            | 'pbkdf2_sha256_django'
            | 'pbkdf2_sha1'
            | 'phpass'
            | 'scrypt_firebase'
            | 'scrypt_werkzeug'
            | 'sha256'
            | 'sha256_salted'
          /**
           * @description When set to `true` all password checks are skipped.
           * It is recommended to use this method only when migrating plaintext passwords to Clerk.
           * Upon migration the user base should be prompted to pick stronger password.
           */
          skip_password_checks?: boolean
          /**
           * @description When set to `true`, `password` is not required anymore when creating the user and can be omitted.
           * This is useful when you are trying to create a user that doesn't have a password, in an instance that is using passwords.
           * Please note that you cannot use this flag if password is the only way for a user to sign into your instance.
           */
          skip_password_requirement?: boolean
          /**
           * @description In case TOTP is configured on the instance, you can provide the secret to enable it on the newly created user without the need to reset it.
           * Please note that currently the supported options are:
           * * Period: 30 seconds
           * * Code length: 6 digits
           * * Algorithm: SHA1
           */
          totp_secret?: string
          /**
           * @description If Backup Codes are configured on the instance, you can provide them to enable it on the newly created user without the need to reset them.
           * You must provide the backup codes in plain format or the corresponding bcrypt digest.
           */
          backup_codes?: string[]
          /** @description Metadata saved on the user, that is visible to both your Frontend and Backend APIs */
          public_metadata?: Record<string, never>
          /** @description Metadata saved on the user, that is only visible to your Backend API */
          private_metadata?: Record<string, never>
          /**
           * @description Metadata saved on the user, that can be updated from both the Frontend and Backend APIs.
           * Note: Since this data can be modified from the frontend, it is not guaranteed to be safe.
           */
          unsafe_metadata?: Record<string, never>
          /** @description A custom date/time denoting _when_ the user signed up to the application, specified in RFC3339 format (e.g. `2012-10-20T07:15:20.902Z`). */
          created_at?: string
        }
      }
    }
    responses: {
      200: components['responses']['User']
      400: components['responses']['ClerkErrors']
      401: components['responses']['AuthenticationInvalid']
      403: components['responses']['AuthenticationInvalid']
      422: components['responses']['UnprocessableEntity']
    }
  }
  /**
   * Count users
   * @description Returns a total count of all users that match the given filtering criteria.
   */
  GetUsersCount: {
    parameters: {
      query?: {
        /**
         * @description Counts users with the specified email addresses.
         * Accepts up to 100 email addresses.
         * Any email addresses not found are ignored.
         */
        email_address?: string[]
        /**
         * @description Counts users with the specified phone numbers.
         * Accepts up to 100 phone numbers.
         * Any phone numbers not found are ignored.
         */
        phone_number?: string[]
        /**
         * @description Counts users with the specified external ids.
         * Accepts up to 100 external ids.
         * Any external ids not found are ignored.
         */
        external_id?: string[]
        /**
         * @description Counts users with the specified usernames.
         * Accepts up to 100 usernames.
         * Any usernames not found are ignored.
         */
        username?: string[]
        /**
         * @description Counts users with the specified web3 wallet addresses.
         * Accepts up to 100 web3 wallet addresses.
         * Any web3 wallet addressed not found are ignored.
         */
        web3_wallet?: string[]
        /**
         * @description Counts users with the user ids specified.
         * Accepts up to 100 user ids.
         * Any user ids not found are ignored.
         */
        user_id?: string[]
        /**
         * @description Counts users that match the given query.
         * For possible matches, we check the email addresses, phone numbers, usernames, web3 wallets, user ids, first and last names.
         * The query value doesn't need to match the exact value you are looking for, it is capable of partial matches as well.
         */
        query?: string
      }
    }
    responses: {
      200: components['responses']['User.Count']
      422: components['responses']['UnprocessableEntity']
    }
  }
  /**
   * Retrieve a user
   * @description Retrieve the details of a user
   */
  GetUser: {
    parameters: {
      path: {
        /** @description The ID of the user to retrieve */
        user_id: string
      }
    }
    responses: {
      200: components['responses']['User']
      400: components['responses']['ClerkErrors']
      401: components['responses']['AuthenticationInvalid']
      404: components['responses']['ResourceNotFound']
    }
  }
  /**
   * Delete a user
   * @description Delete the specified user
   */
  DeleteUser: {
    parameters: {
      path: {
        /** @description The ID of the user to delete */
        user_id: string
      }
    }
    responses: {
      200: components['responses']['DeletedObject']
      400: components['responses']['ClerkErrors']
      401: components['responses']['AuthenticationInvalid']
      404: components['responses']['ResourceNotFound']
    }
  }
  /**
   * Update a user
   * @description Update a user's attributes.
   *
   * You can set the user's primary contact identifiers (email address and phone numbers) by updating the `primary_email_address_id` and `primary_phone_number_id` attributes respectively.
   * Both IDs should correspond to verified identifications that belong to the user.
   *
   * You can remove a user's username by setting the username attribute to null or the blank string "".
   * This is a destructive action; the identification will be deleted forever.
   * Usernames can be removed only if they are optional in your instance settings and there's at least one other identifier which can be used for authentication.
   *
   * This endpoint allows changing a user's password. When passing the `password` parameter directly you have two further options.
   * You can ignore the password policy checks for your instance by setting the `skip_password_checks` parameter to `true`.
   * You can also choose to sign the user out of all their active sessions on any device once the password is updated. Just set `sign_out_of_other_sessions` to `true`.
   */
  UpdateUser: {
    parameters: {
      path: {
        /** @description The ID of the user to update */
        user_id: string
      }
    }
    requestBody: {
      content: {
        'application/json': {
          /**
           * @description The ID of the user as used in your external systems or your previous authentication solution.
           * Must be unique across your instance.
           */
          external_id?: string | null
          /** @description The first name to assign to the user */
          first_name?: string | null
          /** @description The last name to assign to the user */
          last_name?: string | null
          /**
           * @description The ID of the email address to set as primary.
           * It must be verified, and present on the current user.
           */
          primary_email_address_id?: string
          /**
           * @description If set to `true`, the user will be notified that their primary email address has changed.
           * By default, no notification is sent.
           * @default false
           */
          notify_primary_email_address_changed?: boolean
          /**
           * @description The ID of the phone number to set as primary.
           * It must be verified, and present on the current user.
           */
          primary_phone_number_id?: string
          /**
           * @description The ID of the web3 wallets to set as primary.
           * It must be verified, and present on the current user.
           */
          primary_web3_wallet_id?: string
          /**
           * @description The username to give to the user.
           * It must be unique across your instance.
           */
          username?: string | null
          /** @description The ID of the image to set as the user's profile image */
          profile_image_id?: string | null
          /**
           * @description The plaintext password to give the user.
           * Must be at least 8 characters long, and can not be in any list of hacked passwords.
           */
          password?: string | null
          /**
           * @description In case you already have the password digests and not the passwords, you can use them for the newly created user via this property.
           * The digests should be generated with one of the supported algorithms.
           * The hashing algorithm can be specified using the `password_hasher` property.
           */
          password_digest?: string
          /**
           * @description The hashing algorithm that was used to generate the password digest.
           * The algorithms we support at the moment are [bcrypt](https://en.wikipedia.org/wiki/Bcrypt), [bcrypt_sha256_django](https://docs.djangoproject.com/en/4.0/topics/auth/passwords/),
           * [md5](https://en.wikipedia.org/wiki/MD5), pbkdf2_sha256, pbkdf2_sha512, [pbkdf2_sha256_django](https://docs.djangoproject.com/en/4.0/topics/auth/passwords/),
           * [phpass](https://www.openwall.com/phpass/), [scrypt_firebase](https://firebaseopensource.com/projects/firebase/scrypt/),
           * [sha256](https://en.wikipedia.org/wiki/SHA-2), [scrypt_werkzeug](https://werkzeug.palletsprojects.com/en/3.0.x/utils/#werkzeug.security.generate_password_hash)
           * and the [argon2](https://argon2.online/) variants argon2i and argon2id.
           *
           * If you need support for any particular hashing algorithm, [please let us know](https://clerk.com/support).
           *
           * Note: for password hashers considered insecure (at this moment MD5 and SHA256), the corresponding user password hashes will be transparently migrated to Bcrypt (a secure hasher) upon the user's first successful password sign in.
           * Insecure schemes are marked with `(insecure)` in the list below.
           *
           * Each of the supported hashers expects the incoming digest to be in a particular format. Specifically:
           *
           * **bcrypt:** The digest should be of the following form:
           *
           * `$<algorithm version>$<cost>$<salt & hash>`
           *
           * **bcrypt_sha256_django:** This is the Django-specific variant of Bcrypt, using SHA256 hashing function. The format should be as follows (as exported from Django):
           *
           * `bcrypt_sha256$$<algorithm version>$<cost>$<salt & hash>`
           *
           * **md5** (insecure): The digest should follow the regular form e.g.:
           *
           * `5f4dcc3b5aa765d61d8327deb882cf99`
           *
           * **pbkdf2_sha256:** This is the PBKDF2 algorithm using the SHA256 hashing function. The format should be as follows:
           *
           * `pbkdf2_sha256$<iterations>$<salt>$<hash>`
           *
           * Note: Both the salt and the hash are expected to be base64-encoded.
           *
           * **pbkdf2_sha512:** This is the PBKDF2 algorithm using the SHA512 hashing function. The format should be as follows:
           *
           * `pbkdf2_sha512$<iterations>$<salt>$<hash>`
           *
           *   _iterations:_ The number of iterations used. Must be an integer less than 420000.
           *   _salt:_ The salt used when generating the hash. Must be less than bytes.
           *   _hash:_ The hex-encoded hash. Must have been generated with a key length less than 1024 bytes.
           *
           * **pbkdf2_sha256_django:** This is the Django-specific variant of PBKDF2 and the digest should have the following format (as exported from Django):
           *
           * `pbkdf2_sha256$<iterations>$<salt>$<hash>`
           *
           * Note: The salt is expected to be un-encoded, the hash is expected base64-encoded.
           *
           * **pbkdf2_sha1:** This is similar to pkbdf2_sha256_django, but with two differences:
           * 1. uses sha1 instead of sha256
           * 2. accepts the hash as a hex-encoded string
           *
           * The format is the following:
           *
           * `pbkdf2_sha1$<iterations>$<salt>$<hash-as-hex-string>`
           *
           * **phpass:** Portable public domain password hashing framework for use in PHP applications. Digests hashed with phpass have the following sections:
           *
           * The format is the following:
           *
           * `$P$<rounds><salt><encoded-checksum>`
           *
           * - $P$ is the prefix used to identify phpass hashes.
           * - rounds is a single character encoding a 6-bit integer representing the number of rounds used.
           * - salt is eight characters drawn from [./0-9A-Za-z], providing a 48-bit salt.
           * - checksum is 22 characters drawn from the same set, encoding the 128-bit checksum with MD5.
           *
           * **scrypt_firebase:** The Firebase-specific variant of scrypt.
           * The value is expected to have 6 segments separated by the $ character and include the following information:
           *
           * _hash:_ The actual Base64 hash. This can be retrieved when exporting the user from Firebase.
           * _salt:_ The salt used to generate the above hash. Again, this is given when exporting the user.
           * _signer key:_ The base64 encoded signer key.
           * _salt separator:_ The base64 encoded salt separator.
           * _rounds:_ The number of rounds the algorithm needs to run.
           * _memory cost:_ The cost of the algorithm run
           *
           * The first 2 (hash and salt) are per user and can be retrieved when exporting the user from Firebase.
           * The other 4 values (signer key, salt separator, rounds and memory cost) are project-wide settings and can be retrieved from the project's password hash parameters.
           *
           * Once you have all these, you can combine it in the following format and send this as the digest in order for Clerk to accept it:
           *
           * `<hash>$<salt>$<signer key>$<salt separator>$<rounds>$<memory cost>`
           *
           * **scrypt_werkzeug:** The Werkzeug-specific variant of scrypt.
           *
           * The value is expected to have 3 segments separated by the $ character and include the following information:
           *
           * _algorithm args:_ The algorithm used to generate the hash.
           * _salt:_ The salt used to generate the above hash.
           * _hash:_ The actual Base64 hash.
           *
           * The algorithm args are the parameters used to generate the hash and are included in the digest.
           *
           * **argon2i:** Algorithms in the argon2 family generate digests that encode the following information:
           *
           * _version (v):_ The argon version, version 19 is assumed
           * _memory (m):_ The memory used by the algorithm (in kibibytes)
           * _iterations (t):_ The number of iterations to perform
           * _parallelism (p):_ The number of threads to use
           *
           * Parts are demarcated by the `$` character, with the first part identifying the algorithm variant.
           * The middle part is a comma-separated list of the encoding options (memory, iterations, parallelism).
           * The final part is the actual digest.
           *
           * `$argon2i$v=19$m=4096,t=3,p=1$4t6CL3P7YiHBtwESXawI8Hm20zJj4cs7/4/G3c187e0$m7RQFczcKr5bIR0IIxbpO2P0tyrLjf3eUW3M3QSwnLc`
           *
           * **argon2id:** See the previous algorithm for an explanation of the formatting.
           *
           * For the argon2id case, the value of the algorithm in the first part of the digest is `argon2id`:
           *
           * `$argon2id$v=19$m=64,t=4,p=8$Z2liZXJyaXNo$iGXEpMBTDYQ8G/71tF0qGjxRHEmR3gpGULcE93zUJVU`
           *
           * **sha256** (insecure): The digest should be a 64-length hex string, e.g.:
           *
           * `9f86d081884c7d659a2feaa0c55ad015a3bf4f1b2b0b822cd15d6c15b0f00a08`
           * @enum {string}
           */
          password_hasher?:
            | 'argon2i'
            | 'argon2id'
            | 'bcrypt'
            | 'bcrypt_sha256_django'
            | 'md5'
            | 'pbkdf2_sha256'
            | 'pbkdf2_sha512'
            | 'pbkdf2_sha256_django'
            | 'pbkdf2_sha1'
            | 'phpass'
            | 'scrypt_firebase'
            | 'scrypt_werkzeug'
            | 'sha256'
          /** @description Set it to `true` if you're updating the user's password and want to skip any password policy settings check. This parameter can only be used when providing a `password`. */
          skip_password_checks?: boolean | null
          /** @description Set to `true` to sign out the user from all their active sessions once their password is updated. This parameter can only be used when providing a `password`. */
          sign_out_of_other_sessions?: boolean | null
          /**
           * @description In case TOTP is configured on the instance, you can provide the secret to enable it on the specific user without the need to reset it.
           * Please note that currently the supported options are:
           * * Period: 30 seconds
           * * Code length: 6 digits
           * * Algorithm: SHA1
           */
          totp_secret?: string
          /**
           * @description If Backup Codes are configured on the instance, you can provide them to enable it on the specific user without the need to reset them.
           * You must provide the backup codes in plain format or the corresponding bcrypt digest.
           */
          backup_codes?: string[]
          /** @description Metadata saved on the user, that is visible to both your Frontend and Backend APIs */
          public_metadata?: Record<string, never>
          /** @description Metadata saved on the user, that is only visible to your Backend API */
          private_metadata?: Record<string, never>
          /**
           * @description Metadata saved on the user, that can be updated from both the Frontend and Backend APIs.
           * Note: Since this data can be modified from the frontend, it is not guaranteed to be safe.
           */
          unsafe_metadata?: Record<string, never>
          /** @description If true, the user can delete themselves with the Frontend API. */
          delete_self_enabled?: boolean | null
          /** @description If true, the user can create organizations with the Frontend API. */
          create_organization_enabled?: boolean | null
          /** @description A custom date/time denoting _when_ the user signed up to the application, specified in RFC3339 format (e.g. `2012-10-20T07:15:20.902Z`). */
          created_at?: string
        }
      }
    }
    responses: {
      200: components['responses']['User']
      400: components['responses']['ClerkErrors']
      401: components['responses']['AuthenticationInvalid']
      404: components['responses']['ResourceNotFound']
      422: components['responses']['UnprocessableEntity']
    }
  }
  /**
   * Ban a user
   * @description Marks the given user as banned, which means that all their sessions are revoked and they are not allowed to sign in again.
   */
  BanUser: {
    parameters: {
      path: {
        /** @description The ID of the user to ban */
        user_id: string
      }
    }
    responses: {
      200: components['responses']['User']
      402: components['responses']['PaymentRequired']
    }
  }
  /**
   * Unban a user
   * @description Removes the ban mark from the given user.
   */
  UnbanUser: {
    parameters: {
      path: {
        /** @description The ID of the user to unban */
        user_id: string
      }
    }
    responses: {
      200: components['responses']['User']
      402: components['responses']['PaymentRequired']
    }
  }
  /**
   * Lock a user
   * @description Marks the given user as locked, which means they are not allowed to sign in again until the lock expires.
   * Lock duration can be configured in the instance's restrictions settings.
   */
  LockUser: {
    parameters: {
      path: {
        /** @description The ID of the user to lock */
        user_id: string
      }
    }
    responses: {
      200: components['responses']['User']
      403: components['responses']['AuthorizationInvalid']
    }
  }
  /**
   * Unlock a user
   * @description Removes the lock from the given user.
   */
  UnlockUser: {
    parameters: {
      path: {
        /** @description The ID of the user to unlock */
        user_id: string
      }
    }
    responses: {
      200: components['responses']['User']
      403: components['responses']['AuthorizationInvalid']
    }
  }
  /**
   * Set user profile image
   * @description Update a user's profile image
   */
  SetUserProfileImage: {
    parameters: {
      path: {
        /** @description The ID of the user to update the profile image for */
        user_id: string
      }
    }
    requestBody: {
      content: {
        'multipart/form-data': {
          /** Format: binary */
          file?: string
        }
      }
    }
    responses: {
      200: components['responses']['User']
      400: components['responses']['ClerkErrors']
      401: components['responses']['ClerkErrors']
      404: components['responses']['ClerkErrors']
    }
  }
  /**
   * Delete user profile image
   * @description Delete a user's profile image
   */
  DeleteUserProfileImage: {
    parameters: {
      path: {
        /** @description The ID of the user to delete the profile image for */
        user_id: string
      }
    }
    responses: {
      200: components['responses']['User']
      404: components['responses']['ClerkErrors']
    }
  }
  /**
   * Merge and update a user's metadata
   * @description Update a user's metadata attributes by merging existing values with the provided parameters.
   *
   * This endpoint behaves differently than the *Update a user* endpoint.
   * Metadata values will not be replaced entirely.
   * Instead, a deep merge will be performed.
   * Deep means that any nested JSON objects will be merged as well.
   *
   * You can remove metadata keys at any level by setting their value to `null`.
   */
  UpdateUserMetadata: {
    parameters: {
      path: {
        /** @description The ID of the user whose metadata will be updated and merged */
        user_id: string
      }
    }
    requestBody?: {
      content: {
        'application/json': {
          /**
           * @description Metadata saved on the user, that is visible to both your frontend and backend.
           * The new object will be merged with the existing value.
           */
          public_metadata?: {
            [key: string]: unknown
          }
          /**
           * @description Metadata saved on the user that is only visible to your backend.
           * The new object will be merged with the existing value.
           */
          private_metadata?: {
            [key: string]: unknown
          }
          /**
           * @description Metadata saved on the user, that can be updated from both the Frontend and Backend APIs.
           * The new object will be merged with the existing value.
           *
           * Note: Since this data can be modified from the frontend, it is not guaranteed to be safe.
           */
          unsafe_metadata?: {
            [key: string]: unknown
          }
        }
      }
    }
    responses: {
      200: components['responses']['User']
      400: components['responses']['ClerkErrors']
      401: components['responses']['AuthenticationInvalid']
      404: components['responses']['ResourceNotFound']
      422: components['responses']['UnprocessableEntity']
    }
  }
  /**
   * Retrieve the OAuth access token of a user
   * @description Fetch the corresponding OAuth access token for a user that has previously authenticated with a particular OAuth provider.
   * For OAuth 2.0, if the access token has expired and we have a corresponding refresh token, the access token will be refreshed transparently the new one will be returned.
   */
  GetOAuthAccessToken: {
    parameters: {
      path: {
        /** @description The ID of the user for which to retrieve the OAuth access token */
        user_id: string
        /** @description The ID of the OAuth provider (e.g. `oauth_google`) */
        provider: string
      }
    }
    responses: {
      /** @description The OAuth access token of the user, if any. */
      200: {
        content: {
          'application/json': {
            object?: string
            /** @description External account ID */
            external_account_id?: string
            /** @description The unique ID of the user in the external provider's system */
            provider_user_id?: string
            /** @description The access token */
            token?: string
            /** @description The ID of the provider */
            provider?: string
            public_metadata?: Record<string, never>
            label?: string | null
            /**
             * @description The list of scopes that the token is valid for.
             * Only present for OAuth 2.0 tokens.
             */
            scopes?: string[]
            /** @description The token secret. Only present for OAuth 1.0 tokens. */
            token_secret?: string
          }[]
        }
      }
      400: components['responses']['ClerkErrors']
      422: components['responses']['UnprocessableEntity']
    }
  }
  /**
   * Retrieve all memberships for a user
   * @description Retrieve a paginated list of the user's organization memberships
   */
  UsersGetOrganizationMemberships: {
    parameters: {
      query?: {
        limit?: components['parameters']['LimitParameter']
        offset?: components['parameters']['OffsetParameter']
      }
      path: {
        /** @description The ID of the user whose organization memberships we want to retrieve */
        user_id: string
      }
    }
    responses: {
      200: components['responses']['OrganizationMemberships']
      403: components['responses']['ClerkErrors']
    }
  }
  /**
   * Verify the password of a user
   * @description Check that the user's password matches the supplied input.
   * Useful for custom auth flows and re-verification.
   */
  VerifyPassword: {
    parameters: {
      path: {
        /** @description The ID of the user for whom to verify the password */
        user_id: string
      }
    }
    requestBody?: {
      content: {
        'application/json': {
          /** @description The user password to verify */
          password: string
        }
      }
    }
    responses: {
      /** @description The provided password was correct. */
      200: {
        content: {
          'application/json': {
            verified?: boolean
          }
        }
      }
      /** @description The user does not have a password set. */
      400: {
        content: never
      }
      /** @description The user does not exist. */
      404: {
        content: never
      }
      /** @description The provided password was incorrect. */
      422: {
        content: never
      }
      500: components['responses']['ClerkErrors']
    }
  }
  /**
   * Verify a TOTP or backup code for a user
   * @description Verify that the provided TOTP or backup code is valid for the user.
   * Verifying a backup code will result it in being consumed (i.e. it will
   * become invalid).
   * Useful for custom auth flows and re-verification.
   */
  VerifyTOTP: {
    parameters: {
      path: {
        /** @description The ID of the user for whom to verify the TOTP */
        user_id: string
      }
    }
    requestBody?: {
      content: {
        'application/json': {
          /** @description The TOTP or backup code to verify */
          code: string
        }
      }
    }
    responses: {
      /** @description The provided TOTP or backup code was correct. */
      200: {
        content: {
          'application/json': {
            verified?: boolean
            /** @enum {string} */
            code_type?: 'totp' | 'backup_code'
          }
        }
      }
      /** @description The user does not have TOTP configured for their account. */
      400: {
        content: never
      }
      /** @description The user does not exist. */
      404: {
        content: never
      }
      /** @description The provided TOTP or backup code was incorrect. */
      422: {
        content: never
      }
      500: components['responses']['ClerkErrors']
    }
  }
  /**
   * Disable a user's MFA methods
   * @description Disable all of a user's MFA methods (e.g. OTP sent via SMS, TOTP on their authenticator app) at once.
   */
  DisableMFA: {
    parameters: {
      path: {
        /** @description The ID of the user whose MFA methods are to be disabled */
        user_id: string
      }
    }
    responses: {
      /** @description Successful operation. */
      200: {
        content: {
          'application/json': {
            user_id?: string
          }
        }
      }
      404: components['responses']['ResourceNotFound']
      500: components['responses']['ClerkErrors']
    }
  }
  /**
   * List all invitations
   * @description Returns all non-revoked invitations for your application, sorted by creation date
   */
  ListInvitations: {
    parameters: {
      query?: {
        limit?: components['parameters']['LimitParameter']
        offset?: components['parameters']['OffsetParameter']
        /** @description Filter invitations based on their status */
        status?: 'pending' | 'accepted' | 'revoked'
      }
    }
    responses: {
      200: components['responses']['Invitation.List']
    }
  }
  /**
   * Create an invitation
   * @description Creates a new invitation for the given email address and sends the invitation email.
   * Keep in mind that you cannot create an invitation if there is already one for the given email address.
   * Also, trying to create an invitation for an email address that already exists in your application will result to an error.
   */
  CreateInvitation: {
    /** @description Required parameters */
    requestBody?: {
      content: {
        'application/json': {
          /** @description The email address the invitation will be sent to */
          email_address: string
          /**
           * @description Metadata that will be attached to the newly created invitation.
           * The value of this property should be a well-formed JSON object.
           * Once the user accepts the invitation and signs up, these metadata will end up in the user's public metadata.
           */
          public_metadata?: Record<string, never>
          /**
           * @description Optional URL which specifies where to redirect the user once they click the invitation link.
           * This is only required if you have implemented a [custom flow](https://clerk.com/docs/authentication/invitations#custom-flow) and you're not using Clerk Hosted Pages or Clerk Components.
           */
          redirect_url?: string
          /**
           * @description Optional flag which denotes whether an email invitation should be sent to the given email address.
           * Defaults to true.
           * @default true
           */
          notify?: boolean | null
          /**
           * @description Whether an invitation should be created if there is already an existing invitation for this email address, or it's claimed by another user.
           * @default false
           */
          ignore_existing?: boolean | null
        }
      }
    }
    responses: {
      200: components['responses']['Invitation']
      400: components['responses']['ClerkErrors']
      422: components['responses']['UnprocessableEntity']
    }
  }
  /**
   * Revokes an invitation
   * @description Revokes the given invitation.
   * Revoking an invitation will prevent the user from using the invitation link that was sent to them.
   * However, it doesn't prevent the user from signing up if they follow the sign up flow.
   * Only active (i.e. non-revoked) invitations can be revoked.
   */
  RevokeInvitation: {
    parameters: {
      path: {
        /** @description The ID of the invitation to be revoked */
        invitation_id: string
      }
    }
    responses: {
      200: components['responses']['Invitation.Revoked']
      400: components['responses']['ClerkErrors']
      404: components['responses']['ResourceNotFound']
    }
  }
  /**
   * List all identifiers on the allow-list
   * @description Get a list of all identifiers allowed to sign up to an instance
   */
  ListAllowlistIdentifiers: {
    responses: {
      200: components['responses']['AllowlistIdentifier.List']
      401: components['responses']['AuthenticationInvalid']
      402: components['responses']['PaymentRequired']
    }
  }
  /**
   * Add identifier to the allow-list
   * @description Create an identifier allowed to sign up to an instance
   */
  CreateAllowlistIdentifier: {
    requestBody?: {
      content: {
        'application/json': {
          /**
           * @description The identifier to be added in the allow-list.
           * This can be an email address, a phone number or a web3 wallet.
           */
          identifier: string
          /**
           * @description This flag denotes whether the given identifier will receive an invitation to join the application.
           * Note that this only works for email address and phone number identifiers.
           * @default false
           */
          notify?: boolean
        }
      }
    }
    responses: {
      200: components['responses']['AllowlistIdentifier']
      400: components['responses']['ClerkErrors']
      402: components['responses']['PaymentRequired']
      422: components['responses']['UnprocessableEntity']
    }
  }
  /**
   * Delete identifier from allow-list
   * @description Delete an identifier from the instance allow-list
   */
  DeleteAllowlistIdentifier: {
    parameters: {
      path: {
        /** @description The ID of the identifier to delete from the allow-list */
        identifier_id: string
      }
    }
    responses: {
      200: components['responses']['DeletedObject']
      402: components['responses']['PaymentRequired']
      404: components['responses']['ResourceNotFound']
    }
  }
  /**
   * List all identifiers on the block-list
   * @description Get a list of all identifiers which are not allowed to access an instance
   */
  ListBlocklistIdentifiers: {
    responses: {
      200: components['responses']['BlocklistIdentifier.List']
      401: components['responses']['AuthenticationInvalid']
      402: components['responses']['PaymentRequired']
    }
  }
  /**
   * Add identifier to the block-list
   * @description Create an identifier that is blocked from accessing an instance
   */
  CreateBlocklistIdentifier: {
    requestBody?: {
      content: {
        'application/json': {
          /**
           * @description The identifier to be added in the block-list.
           * This can be an email address, a phone number or a web3 wallet.
           */
          identifier: string
        }
      }
    }
    responses: {
      200: components['responses']['BlocklistIdentifier']
      400: components['responses']['ClerkErrors']
      402: components['responses']['PaymentRequired']
      422: components['responses']['UnprocessableEntity']
    }
  }
  /**
   * Delete identifier from block-list
   * @description Delete an identifier from the instance block-list
   */
  DeleteBlocklistIdentifier: {
    parameters: {
      path: {
        /** @description The ID of the identifier to delete from the block-list */
        identifier_id: string
      }
    }
    responses: {
      200: components['responses']['DeletedObject']
      402: components['responses']['PaymentRequired']
      404: components['responses']['ResourceNotFound']
    }
  }
  /**
   * Update instance settings
   * @description Updates the settings of an instance
   */
  UpdateInstanceAuthConfig: {
    requestBody?: {
      content: {
        'application/json': {
          /**
           * @description Whether sign up is restricted to email addresses, phone numbers and usernames that are on the allowlist.
           * @default false
           */
          restricted_to_allowlist?: boolean | null
          /**
           * @description The local part of the email address from which authentication-related emails (e.g. OTP code, magic links) will be sent.
           * Only alphanumeric values are allowed.
           * Note that this value should contain only the local part of the address (e.g. `foo` for `foo@example.com`).
           */
          from_email_address?: string | null
          /** @description Enable the Progressive Sign Up algorithm. Refer to the [docs](https://clerk.com/docs/upgrade-guides/progressive-sign-up) for more info. */
          progressive_sign_up?: boolean | null
          /** @description The name of the JWT Template used to augment your session tokens. To disable this, pass an empty string. */
          session_token_template?: string | null
          /**
           * @description The "enhanced_email_deliverability" feature will send emails from "verifications@clerk.dev" instead of your domain.
           * This can be helpful if you do not have a high domain reputation.
           */
          enhanced_email_deliverability?: boolean | null
          /**
           * @description Toggles test mode for this instance, allowing the use of test email addresses and phone numbers.
           * Defaults to true for development instances.
           */
          test_mode?: boolean | null
        }
      }
    }
    responses: {
      200: components['responses']['InstanceSettings']
      402: components['responses']['PaymentRequired']
      422: components['responses']['UnprocessableEntity']
    }
  }
  /**
   * Update production instance domain
   * @deprecated
   * @description Change the domain of a production instance.
   *
   * Changing the domain requires updating the [DNS records](https://clerk.com/docs/deployments/overview#dns-records) accordingly, deploying new [SSL certificates](https://clerk.com/docs/deployments/overview#deploy), updating your Social Connection's redirect URLs and setting the new keys in your code.
   *
   * WARNING: Changing your domain will invalidate all current user sessions (i.e. users will be logged out). Also, while your application is being deployed, a small downtime is expected to occur.
   */
  UpdateProductionInstanceDomain: {
    requestBody?: {
      content: {
        'application/json': {
          /** @description The new home URL of the production instance e.g. https://www.example.com */
          home_url?: string
        }
      }
    }
    responses: {
      /** @description Accepted */
      202: {
        content: never
      }
      400: components['responses']['ClerkErrors']
      422: components['responses']['ClerkErrors']
    }
  }
  /**
   * Create actor token
   * @description Create an actor token that can be used to impersonate the given user.
   * The `actor` parameter needs to include at least a "sub" key whose value is the ID of the actor (impersonating) user.
   */
  CreateActorToken: {
    requestBody?: {
      content: {
        'application/json': {
          /** @description The ID of the user that can use the newly created sign in token. */
          user_id: string
          /**
           * @description The actor payload. It needs to include a sub property which should contain the ID of the actor.
           * This whole payload will be also included in the JWT session token.
           * @example {
           *   "sub": "user_2OEpKhcCN1Lat9NQ0G6puh7q5Rb"
           * }
           */
          actor: Record<string, never>
          /**
           * @description Optional parameter to specify the life duration of the actor token in seconds.
           * By default, the duration is 1 hour.
           * @default 3600
           */
          expires_in_seconds?: number
          /**
           * @description The maximum duration that the session which will be created by the generated actor token should last.
           * By default, the duration of a session created via an actor token, lasts 30 minutes.
           * @default 1800
           */
          session_max_duration_in_seconds?: number
        }
      }
    }
    responses: {
      200: components['responses']['ActorToken']
      400: components['responses']['ClerkErrors']
      402: components['responses']['PaymentRequired']
      422: components['responses']['UnprocessableEntity']
    }
  }
  /**
   * Revoke actor token
   * @description Revokes a pending actor token.
   */
  RevokeActorToken: {
    parameters: {
      path: {
        /** @description The ID of the actor token to be revoked. */
        actor_token_id: string
      }
    }
    responses: {
      200: components['responses']['ActorToken']
      400: components['responses']['ClerkErrors']
      404: components['responses']['ResourceNotFound']
    }
  }
  /**
   * List all instance domains
   * @description Use this endpoint to get a list of all domains for an instance.
   * The response will contain the primary domain for the instance and any satellite domains. Each domain in the response contains information about the URLs where Clerk operates and the required CNAME targets.
   */
  ListDomains: {
    responses: {
      200: components['responses']['Domains']
    }
  }
  /**
   * Add a domain
   * @description Add a new domain for your instance.
   * Useful in the case of multi-domain instances, allows adding satellite domains to an instance.
   * The new domain must have a `name`. The domain name can contain the port for development instances, like `localhost:3000`.
   * At the moment, instances can have only one primary domain, so the `is_satellite` parameter must be set to `true`.
   * If you're planning to configure the new satellite domain to run behind a proxy, pass the `proxy_url` parameter accordingly.
   */
  AddDomain: {
    requestBody?: {
      content: {
        'application/json': {
          /** @description The new domain name. Can contain the port for development instances. */
          name: string
          /**
           * @description Marks the new domain as satellite. Only `true` is accepted at the moment.
           * @enum {boolean}
           */
          is_satellite: true
          /** @description The full URL of the proxy which will forward requests to the Clerk Frontend API for this domain. Applicable only to production instances. */
          proxy_url?: string
        }
      }
    }
    responses: {
      200: components['responses']['Domain']
      400: components['responses']['ClerkErrors']
      402: components['responses']['ClerkErrors']
      422: components['responses']['UnprocessableEntity']
    }
  }
  /**
   * Delete a satellite domain
   * @description Deletes a satellite domain for the instance.
   * It is currently not possible to delete the instance's primary domain.
   */
  DeleteDomain: {
    parameters: {
      path: {
        /** @description The ID of the domain that will be deleted. Must be a satellite domain. */
        domain_id: string
      }
    }
    responses: {
      200: components['responses']['DeletedObject']
      403: components['responses']['ClerkErrors']
      404: components['responses']['ResourceNotFound']
    }
  }
  /**
   * Update a domain
   * @description The `proxy_url` can be updated only for production instances.
   * Update one of the instance's domains. Both primary and satellite domains can be updated.
   * If you choose to use Clerk via proxy, use this endpoint to specify the `proxy_url`.
   * Whenever you decide you'd rather switch to DNS setup for Clerk, simply set `proxy_url`
   * to `null` for the domain. When you update a production instance's primary domain name,
   * you have to make sure that you've completed all the necessary setup steps for DNS and
   * emails to work. Expect downtime otherwise. Updating a primary domain's name will also
   * update the instance's home origin, affecting the default application paths.
   */
  UpdateDomain: {
    parameters: {
      path: {
        /** @description The ID of the domain that will be updated. */
        domain_id: string
      }
    }
    requestBody: {
      content: {
        'application/json': {
          /**
           * @description The new domain name. For development instances, can contain the port,
           * i.e `myhostname:3000`. For production instances, must be a valid FQDN,
           * i.e `mysite.com`. Cannot contain protocol scheme.
           */
          name?: string | null
          /**
           * @description The full URL of the proxy that will forward requests to Clerk's Frontend API.
           * Can only be updated for production instances.
           */
          proxy_url?: string | null
        }
      }
    }
    responses: {
      200: components['responses']['Domain']
      400: components['responses']['ClerkErrors']
      404: components['responses']['ResourceNotFound']
      422: components['responses']['UnprocessableEntity']
    }
  }
  /**
   * Update instance settings
   * @description Updates the settings of an instance
   */
  UpdateInstance: {
    requestBody?: {
      content: {
        'application/json': {
          /**
           * @description Toggles test mode for this instance, allowing the use of test email addresses and phone numbers.
           * Defaults to true for development instances.
           */
          test_mode?: boolean | null
          /** @description Whether the instance should be using the HIBP service to check passwords for breaches */
          hibp?: boolean | null
          /**
           * @description The "enhanced_email_deliverability" feature will send emails from "verifications@clerk.dev" instead of your domain.
           * This can be helpful if you do not have a high domain reputation.
           */
          enhanced_email_deliverability?: boolean | null
          support_email?: string | null
          clerk_js_version?: string | null
          development_origin?: string | null
          /**
           * @description For browser-like stacks such as browser extensions, Electron, or Capacitor.js the instance allowed origins need to be updated with the request origin value.
           * For Chrome extensions popup, background, or service worker pages the origin is chrome-extension://extension_uiid. For Electron apps the default origin is http://localhost:3000. For Capacitor, the origin is capacitor://localhost.
           */
          allowed_origins?: string[]
          /**
           * @deprecated
           * @description Whether the instance should operate in cookieless development mode (i.e. without third-party cookies).
           * Deprecated: Please use `url_based_session_syncing` instead.
           */
          cookieless_dev?: boolean
          /** @description Whether the instance should use URL-based session syncing in development mode (i.e. without third-party cookies). */
          url_based_session_syncing?: boolean
        }
      }
    }
    responses: {
      /** @description Accepted */
      204: {
        content: never
      }
      422: components['responses']['UnprocessableEntity']
    }
  }
  /**
   * Update instance restrictions
   * @description Updates the restriction settings of an instance
   */
  UpdateInstanceRestrictions: {
    requestBody?: {
      content: {
        'application/json': {
          allowlist?: boolean | null
          blocklist?: boolean | null
          block_email_subaddresses?: boolean | null
          block_disposable_email_domains?: boolean | null
          ignore_dots_for_gmail_addresses?: boolean | null
        }
      }
    }
    responses: {
      200: components['responses']['InstanceRestrictions']
      402: components['responses']['PaymentRequired']
      422: components['responses']['UnprocessableEntity']
    }
  }
  /**
   * Update production instance domain
   * @description Change the domain of a production instance.
   *
   * Changing the domain requires updating the [DNS records](https://clerk.com/docs/deployments/overview#dns-records) accordingly, deploying new [SSL certificates](https://clerk.com/docs/deployments/overview#deploy), updating your Social Connection's redirect URLs and setting the new keys in your code.
   *
   * WARNING: Changing your domain will invalidate all current user sessions (i.e. users will be logged out). Also, while your application is being deployed, a small downtime is expected to occur.
   */
  ChangeProductionInstanceDomain: {
    requestBody?: {
      content: {
        'application/json': {
          /** @description The new home URL of the production instance e.g. https://www.example.com */
          home_url?: string
        }
      }
    }
    responses: {
      /** @description Accepted */
      202: {
        content: never
      }
      400: components['responses']['ClerkErrors']
      422: components['responses']['ClerkErrors']
    }
  }
  /**
   * Update instance organization settings
   * @description Updates the organization settings of the instance
   */
  UpdateInstanceOrganizationSettings: {
    requestBody?: {
      content: {
        'application/json': {
          enabled?: boolean | null
          max_allowed_memberships?: number | null
          admin_delete_enabled?: boolean | null
          domains_enabled?: boolean | null
          /**
           * @description Specify which enrollment modes to enable for your Organization Domains.
           * Supported modes are 'automatic_invitation' & 'automatic_suggestion'.
           */
          domains_enrollment_modes?: string[]
          /** @description Specify what the default organization role is for an organization creator. */
          creator_role_id?: string
          /** @description Specify what the default organization role is for the organization domains. */
          domains_default_role_id?: string
        }
      }
    }
    responses: {
      200: components['responses']['OrganizationSettings']
      402: components['responses']['PaymentRequired']
      404: components['responses']['ResourceNotFound']
      422: components['responses']['UnprocessableEntity']
    }
  }
  /**
   * Create a Svix app
   * @description Create a Svix app and associate it with the current instance
   */
  CreateSvixApp: {
    responses: {
      200: components['responses']['SvixURL']
      400: components['responses']['ClerkErrors']
    }
  }
  /**
   * Delete a Svix app
   * @description Delete a Svix app and disassociate it from the current instance
   */
  DeleteSvixApp: {
    responses: {
      /** @description Svix app was successfully deleted */
      204: {
        content: never
      }
      400: components['responses']['ClerkErrors']
    }
  }
  /**
   * Create a Svix Dashboard URL
   * @description Generate a new url for accessing the Svix's management dashboard for that particular instance
   */
  GenerateSvixAuthURL: {
    responses: {
      200: components['responses']['SvixURL']
      400: components['responses']['ClerkErrors']
    }
  }
  /** List all templates */
  ListJWTTemplates: {
    responses: {
      200: components['responses']['JWTTemplate.List']
    }
  }
  /**
   * Create a JWT template
   * @description Create a new JWT template
   */
  CreateJWTTemplate: {
    requestBody?: {
      content: {
        'application/json': {
          /** @description JWT template name */
          name?: string
          /** @description JWT template claims in JSON format */
          claims?: Record<string, never>
          /** @description JWT token lifetime */
          lifetime?: number | null
          /** @description JWT token allowed clock skew */
          allowed_clock_skew?: number | null
          /** @description Whether a custom signing key/algorithm is also provided for this template */
          custom_signing_key?: boolean
          /** @description The custom signing algorithm to use when minting JWTs */
          signing_algorithm?: string | null
          /** @description The custom signing private key to use when minting JWTs */
          signing_key?: string | null
        }
      }
    }
    responses: {
      200: components['responses']['JWTTemplate']
      400: components['responses']['ClerkErrors']
      402: components['responses']['PaymentRequired']
      422: components['responses']['UnprocessableEntity']
    }
  }
  /**
   * Retrieve a template
   * @description Retrieve the details of a given JWT template
   */
  GetJWTTemplate: {
    parameters: {
      path: {
        /** @description JWT Template ID */
        template_id: string
      }
    }
    responses: {
      200: components['responses']['JWTTemplate']
      404: components['responses']['ResourceNotFound']
    }
  }
  /** Delete a Template */
  DeleteJWTTemplate: {
    parameters: {
      path: {
        /** @description JWT Template ID */
        template_id: string
      }
    }
    responses: {
      200: components['responses']['DeletedObject']
      403: components['responses']['AuthorizationInvalid']
      404: components['responses']['ResourceNotFound']
    }
  }
  /**
   * Update a JWT template
   * @description Updates an existing JWT template
   */
  UpdateJWTTemplate: {
    parameters: {
      path: {
        /** @description The ID of the JWT template to update */
        template_id: string
      }
    }
    requestBody?: {
      content: {
        'application/json': {
          /** @description JWT template name */
          name?: string
          /** @description JWT template claims in JSON format */
          claims?: Record<string, never>
          /** @description JWT token lifetime */
          lifetime?: number | null
          /** @description JWT token allowed clock skew */
          allowed_clock_skew?: number | null
          /** @description Whether a custom signing key/algorithm is also provided for this template */
          custom_signing_key?: boolean
          /** @description The custom signing algorithm to use when minting JWTs */
          signing_algorithm?: string | null
          /** @description The custom signing private key to use when minting JWTs */
          signing_key?: string | null
        }
      }
    }
    responses: {
      200: components['responses']['JWTTemplate']
      400: components['responses']['ClerkErrors']
      402: components['responses']['PaymentRequired']
      422: components['responses']['UnprocessableEntity']
    }
  }
  /**
   * Get a list of organizations for an instance
   * @description This request returns the list of organizations for an instance.
   * Results can be paginated using the optional `limit` and `offset` query parameters.
   * The organizations are ordered by descending creation date.
   * Most recent organizations will be returned first.
   */
  ListOrganizations: {
    parameters: {
      query?: {
        limit?: components['parameters']['LimitParameter']
        offset?: components['parameters']['OffsetParameter']
        /** @description Flag to denote whether the member counts of each organization should be included in the response or not. */
        include_members_count?: boolean
        /**
         * @description Returns organizations with ID, name, or slug that match the given query.
         * Uses exact match for organization ID and partial match for name and slug.
         */
        query?: string
        /**
         * @description Allows to return organizations in a particular order.
         * At the moment, you can order the returned organizations either by their `name`, `created_at` or `members_count`.
         * In order to specify the direction, you can use the `+/-` symbols prepended in the property to order by.
         * For example, if you want organizations to be returned in descending order according to their `created_at` property, you can use `-created_at`.
         * If you don't use `+` or `-`, then `+` is implied.
         * Defaults to `-created_at`.
         */
        order_by?: string
      }
    }
    responses: {
      200: components['responses']['Organizations']
      400: components['responses']['ClerkErrors']
      403: components['responses']['AuthorizationInvalid']
      422: components['responses']['UnprocessableEntity']
    }
  }
  /**
   * Create an organization
   * @description Creates a new organization with the given name for an instance.
   * In order to successfully create an organization you need to provide the ID of the User who will become the organization administrator.
   * You can specify an optional slug for the new organization.
   * If provided, the organization slug can contain only lowercase alphanumeric characters (letters and digits) and the dash "-".
   * Organization slugs must be unique for the instance.
   * You can provide additional metadata for the organization and set any custom attribute you want.
   * Organizations support private and public metadata.
   * Private metadata can only be accessed from the Backend API.
   * Public metadata can be accessed from the Backend API, and are read-only from the Frontend API.
   */
  CreateOrganization: {
    requestBody?: {
      content: {
        'application/json': {
          /** @description The name of the new organization */
          name: string
          /** @description The ID of the User who will become the administrator for the new organization */
          created_by: string
          /** @description Metadata saved on the organization, accessible only from the Backend API */
          private_metadata?: Record<string, never>
          /** @description Metadata saved on the organization, read-only from the Frontend API and fully accessible (read/write) from the Backend API */
          public_metadata?: Record<string, never>
          /**
           * @description A slug for the new organization.
           * Can contain only lowercase alphanumeric characters and the dash "-".
           * Must be unique for the instance.
           */
          slug?: string
          /** @description The maximum number of memberships allowed for this organization */
          max_allowed_memberships?: number
        }
      }
    }
    responses: {
      200: components['responses']['Organization']
      400: components['responses']['ClerkErrors']
      403: components['responses']['AuthorizationInvalid']
      422: components['responses']['UnprocessableEntity']
    }
  }
  /**
   * Retrieve an organization by ID or slug
   * @description Fetches the organization whose ID or slug matches the provided `id_or_slug` URL query parameter.
   */
  GetOrganization: {
    parameters: {
      path: {
        /** @description The ID or slug of the organization */
        organization_id: string
      }
    }
    responses: {
      200: components['responses']['Organization']
      403: components['responses']['AuthorizationInvalid']
      404: components['responses']['ResourceNotFound']
    }
  }
  /**
   * Delete an organization
   * @description Deletes the given organization.
   * Please note that deleting an organization will also delete all memberships and invitations.
   * This is not reversible.
   */
  DeleteOrganization: {
    parameters: {
      path: {
        /** @description The ID of the organization to delete */
        organization_id: string
      }
    }
    responses: {
      200: components['responses']['DeletedObject']
      404: components['responses']['ResourceNotFound']
    }
  }
  /**
   * Update an organization
   * @description Updates an existing organization
   */
  UpdateOrganization: {
    parameters: {
      path: {
        /** @description The ID of the organization to update */
        organization_id: string
      }
    }
    requestBody: {
      content: {
        'application/json': {
          /** @description Metadata saved on the organization, that is visible to both your frontend and backend. */
          public_metadata?: Record<string, never>
          /** @description Metadata saved on the organization that is only visible to your backend. */
          private_metadata?: Record<string, never>
          /** @description The new name of the organization */
          name?: string | null
          /** @description The new slug of the organization, which needs to be unique in the instance */
          slug?: string | null
          /** @description The maximum number of memberships allowed for this organization */
          max_allowed_memberships?: number | null
          /** @description If true, an admin can delete this organization with the Frontend API. */
          admin_delete_enabled?: boolean | null
        }
      }
    }
    responses: {
      200: components['responses']['Organization']
      402: components['responses']['ResourceNotFound']
      404: components['responses']['ResourceNotFound']
      422: components['responses']['UnprocessableEntity']
    }
  }
  /**
   * Merge and update metadata for an organization
   * @description Update organization metadata attributes by merging existing values with the provided parameters.
   * Metadata values will be updated via a deep merge.
   * Deep meaning that any nested JSON objects will be merged as well.
   * You can remove metadata keys at any level by setting their value to `null`.
   */
  MergeOrganizationMetadata: {
    parameters: {
      path: {
        /** @description The ID of the organization for which metadata will be merged or updated */
        organization_id: string
      }
    }
    requestBody: {
      content: {
        'application/json': {
          /**
           * @description Metadata saved on the organization, that is visible to both your frontend and backend.
           * The new object will be merged with the existing value.
           */
          public_metadata?: Record<string, never>
          /**
           * @description Metadata saved on the organization that is only visible to your backend.
           * The new object will be merged with the existing value.
           */
          private_metadata?: Record<string, never>
        }
      }
    }
    responses: {
      200: components['responses']['Organization']
      400: components['responses']['ClerkErrors']
      401: components['responses']['AuthenticationInvalid']
      404: components['responses']['ResourceNotFound']
      422: components['responses']['UnprocessableEntity']
    }
  }
  /**
   * Upload a logo for the organization
   * @description Set or replace an organization's logo, by uploading an image file.
   * This endpoint uses the `multipart/form-data` request content type and accepts a file of image type.
   * The file size cannot exceed 10MB.
   * Only the following file content types are supported: `image/jpeg`, `image/png`, `image/gif`, `image/webp`, `image/x-icon`, `image/vnd.microsoft.icon`.
   */
  UploadOrganizationLogo: {
    parameters: {
      path: {
        /** @description The ID of the organization for which to upload a logo */
        organization_id: string
      }
    }
    requestBody?: {
      content: {
        'multipart/form-data': {
          /** @description The ID of the user that will be credited with the image upload. */
          uploader_user_id: string
          /** Format: binary */
          file: string
        }
      }
    }
    responses: {
      200: components['responses']['OrganizationWithLogo']
      400: components['responses']['ClerkErrors']
      403: components['responses']['AuthorizationInvalid']
      404: components['responses']['ResourceNotFound']
      413: components['responses']['ClerkErrors']
    }
  }
  /** @description Delete the organization's logo. */
  DeleteOrganizationLogo: {
    parameters: {
      path: {
        /** @description The ID of the organization for which the logo will be deleted. */
        organization_id: string
      }
    }
    responses: {
      200: components['responses']['Organization']
      404: components['responses']['ResourceNotFound']
    }
  }
  /**
   * Get a list of organization invitations
   * @description This request returns the list of organization invitations.
   * Results can be paginated using the optional `limit` and `offset` query parameters.
   * You can filter them by providing the 'status' query parameter, that accepts multiple values.
   * The organization invitations are ordered by descending creation date.
   * Most recent invitations will be returned first.
   * Any invitations created as a result of an Organization Domain are not included in the results.
   */
  ListOrganizationInvitations: {
    parameters: {
      query?: {
        limit?: components['parameters']['LimitParameter']
        offset?: components['parameters']['OffsetParameter']
        /** @description Filter organization invitations based on their status */
        status?: 'pending' | 'accepted' | 'revoked'
      }
      path: {
        /** @description The organization ID. */
        organization_id: string
      }
    }
    responses: {
      200: components['responses']['OrganizationInvitations']
      400: components['responses']['ClerkErrors']
      404: components['responses']['ResourceNotFound']
    }
  }
  /**
   * Create and send an organization invitation
   * @description Creates a new organization invitation and sends an email to the provided `email_address` with a link to accept the invitation and join the organization.
   * You can specify the `role` for the invited organization member.
   *
   * New organization invitations get a "pending" status until they are revoked by an organization administrator or accepted by the invitee.
   *
   * The request body supports passing an optional `redirect_url` parameter.
   * When the invited user clicks the link to accept the invitation, they will be redirected to the URL provided.
   * Use this parameter to implement a custom invitation acceptance flow.
   *
   * You must specify the ID of the user that will send the invitation with the `inviter_user_id` parameter.
   * That user must be a member with administrator privileges in the organization.
   * Only "admin" members can create organization invitations.
   *
   * You can optionally provide public and private metadata for the organization invitation.
   * The public metadata are visible by both the Frontend and the Backend whereas the private ones only by the Backend.
   * When the organization invitation is accepted, the metadata will be transferred to the newly created organization membership.
   */
  CreateOrganizationInvitation: {
    parameters: {
      path: {
        /** @description The ID of the organization for which to send the invitation */
        organization_id: string
      }
    }
    requestBody: {
      content: {
        'application/json': {
          /** @description The email address of the new member that is going to be invited to the organization */
          email_address: string
          /**
           * @description The ID of the user that invites the new member to the organization.
           * Must be an administrator in the organization.
           */
          inviter_user_id: string
          /** @description The role of the new member in the organization */
          role: string
          /** @description Metadata saved on the organization invitation, read-only from the Frontend API and fully accessible (read/write) from the Backend API. */
          public_metadata?: Record<string, never>
          /** @description Metadata saved on the organization invitation, fully accessible (read/write) from the Backend API but not visible from the Frontend API. */
          private_metadata?: Record<string, never>
          /** @description Optional URL that the invitee will be redirected to once they accept the invitation by clicking the join link in the invitation email. */
          redirect_url?: string
        }
      }
    }
    responses: {
      200: components['responses']['OrganizationInvitation']
      400: components['responses']['ClerkErrors']
      403: components['responses']['AuthorizationInvalid']
      404: components['responses']['ResourceNotFound']
      422: components['responses']['UnprocessableEntity']
    }
  }
  /**
   * Bulk create and send organization invitations
   * @description Creates new organization invitations in bulk and sends out emails to the provided email addresses with a link to accept the invitation and join the organization.
   * You can specify a different `role` for each invited organization member.
   * New organization invitations get a "pending" status until they are revoked by an organization administrator or accepted by the invitee.
   * The request body supports passing an optional `redirect_url` parameter for each invitation.
   * When the invited user clicks the link to accept the invitation, they will be redirected to the provided URL.
   * Use this parameter to implement a custom invitation acceptance flow.
   * You must specify the ID of the user that will send the invitation with the `inviter_user_id` parameter. Each invitation
   * can have a different inviter user.
   * Inviter users must be members with administrator privileges in the organization.
   * Only "admin" members can create organization invitations.
   * You can optionally provide public and private metadata for each organization invitation. The public metadata are visible
   * by both the Frontend and the Backend, whereas the private metadata are only visible by the Backend.
   * When the organization invitation is accepted, the metadata will be transferred to the newly created organization membership.
   */
  CreateOrganizationInvitationBulk: {
    parameters: {
      path: {
        /** @description The organization ID. */
        organization_id: string
      }
    }
    requestBody: {
      content: {
        'application/json': {
          /** @description The email address of the new member that is going to be invited to the organization */
          email_address: string
          /**
           * @description The ID of the user that invites the new member to the organization.
           * Must be an administrator in the organization.
           */
          inviter_user_id: string
          /** @description The role of the new member in the organization. */
          role: string
          /** @description Metadata saved on the organization invitation, read-only from the Frontend API and fully accessible (read/write) from the Backend API. */
          public_metadata?: Record<string, never>
          /** @description Metadata saved on the organization invitation, fully accessible (read/write) from the Backend API but not visible from the Frontend API. */
          private_metadata?: Record<string, never>
          /** @description Optional URL that the invitee will be redirected to once they accept the invitation by clicking the join link in the invitation email. */
          redirect_url?: string
        }[]
      }
    }
    responses: {
      200: components['responses']['OrganizationInvitations']
      400: components['responses']['ClerkErrors']
      403: components['responses']['AuthorizationInvalid']
      404: components['responses']['ResourceNotFound']
      422: components['responses']['UnprocessableEntity']
    }
  }
  /**
   * Get a list of pending organization invitations
   * @deprecated
   * @description This request returns the list of organization invitations with "pending" status.
   * These are the organization invitations that can still be used to join the organization, but have not been accepted by the invited user yet.
   * Results can be paginated using the optional `limit` and `offset` query parameters.
   * The organization invitations are ordered by descending creation date.
   * Most recent invitations will be returned first.
   * Any invitations created as a result of an Organization Domain are not included in the results.
   */
  ListPendingOrganizationInvitations: {
    parameters: {
      query?: {
        limit?: components['parameters']['LimitParameter']
        offset?: components['parameters']['OffsetParameter']
      }
      path: {
        /** @description The organization ID. */
        organization_id: string
      }
    }
    responses: {
      200: components['responses']['OrganizationInvitations']
      400: components['responses']['ClerkErrors']
      404: components['responses']['ResourceNotFound']
    }
  }
  /**
   * Retrieve an organization invitation by ID
   * @description Use this request to get an existing organization invitation by ID.
   */
  GetOrganizationInvitation: {
    parameters: {
      path: {
        /** @description The organization ID. */
        organization_id: string
        /** @description The organization invitation ID. */
        invitation_id: string
      }
    }
    responses: {
      200: components['responses']['OrganizationInvitation']
      400: components['responses']['ClerkErrors']
      403: components['responses']['AuthorizationInvalid']
      404: components['responses']['ResourceNotFound']
    }
  }
  /**
   * Revoke a pending organization invitation
   * @description Use this request to revoke a previously issued organization invitation.
   * Revoking an organization invitation makes it invalid; the invited user will no longer be able to join the organization with the revoked invitation.
   * Only organization invitations with "pending" status can be revoked.
   * The request needs the `requesting_user_id` parameter to specify the user which revokes the invitation.
   * Only users with "admin" role can revoke invitations.
   */
  RevokeOrganizationInvitation: {
    parameters: {
      path: {
        /** @description The organization ID. */
        organization_id: string
        /** @description The organization invitation ID. */
        invitation_id: string
      }
    }
    requestBody: {
      content: {
        'application/json': {
          /**
           * @description The ID of the user that revokes the invitation.
           * Must be an administrator in the organization.
           */
          requesting_user_id: string
        }
      }
    }
    responses: {
      200: components['responses']['OrganizationInvitation']
      400: components['responses']['ClerkErrors']
      403: components['responses']['AuthorizationInvalid']
      404: components['responses']['ResourceNotFound']
    }
  }
  /**
   * Get a list of all members of an organization
   * @description Retrieves all user memberships for the given organization
   */
  ListOrganizationMemberships: {
    parameters: {
      query?: {
        limit?: components['parameters']['LimitParameter']
        offset?: components['parameters']['OffsetParameter']
        /**
         * @description Sorts organizations memberships by phone_number, email_address, created_at, first_name, last_name or username.
         * By prepending one of those values with + or -,
         * we can choose to sort in ascending (ASC) or descending (DESC) order."
         */
        order_by?: string
      }
      path: {
        /** @description The organization ID. */
        organization_id: string
      }
    }
    responses: {
      200: components['responses']['OrganizationMemberships']
      401: components['responses']['AuthenticationInvalid']
      422: components['responses']['UnprocessableEntity']
    }
  }
  /**
   * Create a new organization membership
   * @description Adds a user as a member to the given organization.
   * Only users in the same instance as the organization can be added as members.
   */
  CreateOrganizationMembership: {
    parameters: {
      path: {
        /** @description The ID of the organization where the new membership will be created */
        organization_id: string
      }
    }
    requestBody: {
      content: {
        'application/json': {
          /**
           * @description The ID of the user that will be added as a member in the organization.
           * The user needs to exist in the same instance as the organization and must not be a member of the given organization already.
           */
          user_id: string
          /** @description The role that the new member will have in the organization. */
          role: string
        }
      }
    }
    responses: {
      200: components['responses']['OrganizationMembership']
      400: components['responses']['ClerkErrors']
      403: components['responses']['AuthorizationInvalid']
      404: components['responses']['ResourceNotFound']
      422: components['responses']['UnprocessableEntity']
    }
  }
  /**
   * Remove a member from an organization
   * @description Removes the given membership from the organization
   */
  DeleteOrganizationMembership: {
    parameters: {
      path: {
        /** @description The ID of the organization the membership belongs to */
        organization_id: string
        /** @description The ID of the user that this membership belongs to */
        user_id: string
      }
    }
    responses: {
      200: components['responses']['OrganizationMembership']
      400: components['responses']['ClerkErrors']
      401: components['responses']['AuthenticationInvalid']
      404: components['responses']['ResourceNotFound']
    }
  }
  /**
   * Update an organization membership
   * @description Updates the properties of an existing organization membership
   */
  UpdateOrganizationMembership: {
    parameters: {
      path: {
        /** @description The ID of the organization the membership belongs to */
        organization_id: string
        /** @description The ID of the user that this membership belongs to */
        user_id: string
      }
    }
    requestBody: {
      content: {
        'application/json': {
          /** @description The new role of the given membership. */
          role: string
        }
      }
    }
    responses: {
      200: components['responses']['OrganizationMembership']
      400: components['responses']['ClerkErrors']
      404: components['responses']['ResourceNotFound']
      422: components['responses']['UnprocessableEntity']
    }
  }
  /**
   * Merge and update organization membership metadata
   * @description Update an organization membership's metadata attributes by merging existing values with the provided parameters.
   * Metadata values will be updated via a deep merge. Deep means that any nested JSON objects will be merged as well.
   * You can remove metadata keys at any level by setting their value to `null`.
   */
  UpdateOrganizationMembershipMetadata: {
    parameters: {
      path: {
        /** @description The ID of the organization the membership belongs to */
        organization_id: string
        /** @description The ID of the user that this membership belongs to */
        user_id: string
      }
    }
    requestBody: {
      content: {
        'application/json': {
          /**
           * @description Metadata saved on the organization membership, that is visible to both your frontend and backend.
           * The new object will be merged with the existing value.
           */
          public_metadata?: Record<string, never>
          /**
           * @description Metadata saved on the organization membership that is only visible to your backend.
           * The new object will be merged with the existing value.
           */
          private_metadata?: Record<string, never>
        }
      }
    }
    responses: {
      200: components['responses']['OrganizationMembership']
      400: components['responses']['ClerkErrors']
      404: components['responses']['ResourceNotFound']
      422: components['responses']['UnprocessableEntity']
    }
  }
  /**
   * Verify the proxy configuration for your domain
   * @description This endpoint can be used to validate that a proxy-enabled domain is operational.
   * It tries to verify that the proxy URL provided in the parameters maps to a functional proxy that can reach the Clerk Frontend API.
   *
   * You can use this endpoint before you set a proxy URL for a domain. This way you can ensure that switching to proxy-based
   * configuration will not lead to downtime for your instance.
   *
   * The `proxy_url` parameter allows for testing proxy configurations for domains that don't have a proxy URL yet, or operate on
   * a different proxy URL than the one provided. It can also be used to re-validate a domain that is already configured to work with a proxy.
   */
  VerifyDomainProxy: {
    requestBody?: {
      content: {
        'application/json': {
          /** @description The ID of the domain that will be updated. */
          domain_id?: string
          /** @description The full URL of the proxy which will forward requests to the Clerk Frontend API for this domain. e.g. https://example.com/__clerk */
          proxy_url?: string
        }
      }
    }
    responses: {
      200: components['responses']['ProxyCheck']
      400: components['responses']['ClerkErrors']
      422: components['responses']['UnprocessableEntity']
    }
  }
  /**
   * List all redirect URLs
   * @description Lists all whitelisted redirect_urls for the instance
   */
  ListRedirectURLs: {
    responses: {
      200: components['responses']['RedirectURL.List']
    }
  }
  /**
   * Create a redirect URL
   * @description Create a redirect URL
   */
  CreateRedirectURL: {
    requestBody?: {
      content: {
        'application/json': {
          /** @description The full url value prefixed with `https://` or a custom scheme e.g. `"https://my-app.com/oauth-callback"` or `"my-app://oauth-callback"` */
          url?: string
        }
      }
    }
    responses: {
      200: components['responses']['RedirectURL']
      400: components['responses']['ClerkErrors']
      422: components['responses']['UnprocessableEntity']
    }
  }
  /**
   * Retrieve a redirect URL
   * @description Retrieve the details of the redirect URL with the given ID
   */
  GetRedirectURL: {
    parameters: {
      path: {
        /** @description The ID of the redirect URL */
        id: string
      }
    }
    responses: {
      200: components['responses']['RedirectURL']
      404: components['responses']['ResourceNotFound']
    }
  }
  /**
   * Delete a redirect URL
   * @description Remove the selected redirect URL from the whitelist of the instance
   */
  DeleteRedirectURL: {
    parameters: {
      path: {
        /** @description The ID of the redirect URL */
        id: string
      }
    }
    responses: {
      200: components['responses']['DeletedObject']
      404: components['responses']['ResourceNotFound']
    }
  }
  /**
   * Create sign-in token
   * @description Creates a new sign-in token and associates it with the given user.
   * By default, sign-in tokens expire in 30 days.
   * You can optionally supply a different duration in seconds using the `expires_in_seconds` property.
   */
  CreateSignInToken: {
    requestBody?: {
      content: {
        'application/json': {
          /** @description The ID of the user that can use the newly created sign in token */
          user_id?: string
          /**
           * @description Optional parameter to specify the life duration of the sign in token in seconds.
           * By default, the duration is 30 days.
           * @default 2592000
           */
          expires_in_seconds?: number
        }
      }
    }
    responses: {
      200: components['responses']['SignInToken']
      404: components['responses']['ResourceNotFound']
      422: components['responses']['UnprocessableEntity']
    }
  }
  /**
   * Revoke the given sign-in token
   * @description Revokes a pending sign-in token
   */
  RevokeSignInToken: {
    parameters: {
      path: {
        /** @description The ID of the sign-in token to be revoked */
        sign_in_token_id: string
      }
    }
    responses: {
      200: components['responses']['SignInToken']
      400: components['responses']['ClerkErrors']
      404: components['responses']['ResourceNotFound']
    }
  }
  /**
   * Update a sign-up
   * @description Update the sign-up with the given ID
   */
  UpdateSignUp: {
    parameters: {
      path: {
        /** @description The ID of the sign-up to update */
        id: string
      }
    }
    requestBody?: {
      content: {
        'application/json': {
          /**
           * @description Specifies whether a custom action has run for this sign-up attempt.
           * This is important when your instance has been configured to require a custom action to run before converting a sign-up into a user.
           * After executing any external business logic you deem necessary, you can mark the sign-up as ready-to-convert by setting `custom_action` to `true`.
           */
          custom_action?: boolean
          /**
           * @description The ID of the guest attempting to sign up as used in your external systems or your previous authentication solution.
           * This will be copied to the resulting user when the sign-up is completed.
           */
          external_id?: string | null
        }
      }
    }
    responses: {
      200: components['responses']['SignUp']
      403: components['responses']['AuthorizationInvalid']
    }
  }
  /**
   * Get a list of OAuth applications for an instance
   * @description This request returns the list of OAuth applications for an instance.
   * Results can be paginated using the optional `limit` and `offset` query parameters.
   * The OAuth applications are ordered by descending creation date.
   * Most recent OAuth applications will be returned first.
   */
  ListOAuthApplications: {
    parameters: {
      query?: {
        limit?: components['parameters']['LimitParameter']
        offset?: components['parameters']['OffsetParameter']
      }
    }
    responses: {
      200: components['responses']['OAuthApplications']
      400: components['responses']['ClerkErrors']
      403: components['responses']['AuthorizationInvalid']
      422: components['responses']['UnprocessableEntity']
    }
  }
  /**
   * Create an OAuth application
   * @description Creates a new OAuth application with the given name and callback URL for an instance.
   * The callback URL must be a valid url.
   * All URL schemes are allowed such as `http://`, `https://`, `myapp://`, etc...
   */
  CreateOAuthApplication: {
    requestBody?: {
      content: {
        'application/json': {
          /** @description The name of the new OAuth application */
          name: string
          /** @description The callback URL of the new OAuth application */
          callback_url: string
          /**
           * @description Define the allowed scopes for the new OAuth applications that dictate the user payload of the OAuth user info endpoint. Available scopes are `profile`, `email`, `public_metadata`, `private_metadata`. Provide the requested scopes as a string, separated by spaces.
           * @default profile email
           * @example profile email public_metadata
           */
          scopes?: string
          /**
           * @description If true, this client is public and cannot securely store a client secret.
           * Only the authorization code flow with proof key for code exchange (PKCE) may be used.
           * Public clients cannot be updated to be confidential clients, and vice versa.
           */
          public?: boolean
        }
      }
    }
    responses: {
      200: components['responses']['OAuthApplicationWithSecret']
      400: components['responses']['ClerkErrors']
      403: components['responses']['AuthorizationInvalid']
      422: components['responses']['UnprocessableEntity']
    }
  }
  /**
   * Retrieve an OAuth application by ID
   * @description Fetches the OAuth application whose ID matches the provided `id` in the path.
   */
  GetOAuthApplication: {
    parameters: {
      path: {
        /** @description The ID of the OAuth application */
        oauth_application_id: string
      }
    }
    responses: {
      200: components['responses']['OAuthApplication']
      403: components['responses']['AuthorizationInvalid']
      404: components['responses']['ResourceNotFound']
    }
  }
  /**
   * Delete an OAuth application
   * @description Deletes the given OAuth application.
   * This is not reversible.
   */
  DeleteOAuthApplication: {
    parameters: {
      path: {
        /** @description The ID of the OAuth application to delete */
        oauth_application_id: string
      }
    }
    responses: {
      200: components['responses']['DeletedObject']
      403: components['responses']['AuthorizationInvalid']
      404: components['responses']['ResourceNotFound']
    }
  }
  /**
   * Update an OAuth application
   * @description Updates an existing OAuth application
   */
  UpdateOAuthApplication: {
    parameters: {
      path: {
        /** @description The ID of the OAuth application to update */
        oauth_application_id: string
      }
    }
    requestBody: {
      content: {
        'application/json': {
          /** @description The new name of the OAuth application */
          name?: string
          /** @description The new callback URL of the OAuth application */
          callback_url?: string
          /**
           * @description Define the allowed scopes for the new OAuth applications that dictate the user payload of the OAuth user info endpoint. Available scopes are `profile`, `email`, `public_metadata`, `private_metadata`. Provide the requested scopes as a string, separated by spaces.
           * @default profile email
           * @example profile email public_metadata private_metadata
           */
          scopes?: string
        }
      }
    }
    responses: {
      200: components['responses']['OAuthApplication']
      403: components['responses']['AuthorizationInvalid']
      404: components['responses']['ResourceNotFound']
      422: components['responses']['UnprocessableEntity']
    }
  }
  /**
   * Rotate the client secret of the given OAuth application
   * @description Rotates the OAuth application's client secret.
   * When the client secret is rotated, make sure to update it in authorized OAuth clients.
   */
  RotateOAuthApplicationSecret: {
    parameters: {
      path: {
        /** @description The ID of the OAuth application for which to rotate the client secret */
        oauth_application_id: string
      }
    }
    responses: {
      200: components['responses']['OAuthApplicationWithSecret']
      403: components['responses']['AuthorizationInvalid']
      404: components['responses']['ResourceNotFound']
    }
  }
  /**
   * Get a list of SAML Connections for an instance
   * @description Returns the list of SAML Connections for an instance.
   * Results can be paginated using the optional `limit` and `offset` query parameters.
   * The SAML Connections are ordered by descending creation date and the most recent will be returned first.
   */
  ListSAMLConnections: {
    parameters: {
      query?: {
        limit?: components['parameters']['LimitParameter']
        offset?: components['parameters']['OffsetParameter']
      }
    }
    responses: {
      200: components['responses']['SAMLConnections']
      402: components['responses']['PaymentRequired']
      403: components['responses']['AuthorizationInvalid']
      422: components['responses']['UnprocessableEntity']
    }
  }
  /**
   * Create a SAML Connection
   * @description Create a new SAML Connection.
   */
  CreateSAMLConnection: {
    requestBody?: {
      content: {
        'application/json': {
          /** @description The name to use as a label for this SAML Connection */
          name: string
          /** @description The domain of your organization. Sign in flows using an email with this domain, will use this SAML Connection. */
          domain: string
          /**
           * @description The IdP provider of the connection.
           * @enum {string}
           */
          provider:
            | 'saml_custom'
            | 'saml_okta'
            | 'saml_google'
            | 'saml_microsoft'
          /** @description The Entity ID as provided by the IdP */
          idp_entity_id?: string | null
          /** @description The Single-Sign On URL as provided by the IdP */
          idp_sso_url?: string | null
          /** @description The X.509 certificate as provided by the IdP */
          idp_certificate?: string | null
          /** @description The URL which serves the IdP metadata. If present, it takes priority over the corresponding individual properties */
          idp_metadata_url?: string | null
          /** @description The XML content of the IdP metadata file. If present, it takes priority over the corresponding individual properties */
          idp_metadata?: string | null
          /** @description Define the attribute name mapping between Identity Provider and Clerk's user properties */
          attribute_mapping?: {
            user_id?: string
            email_address?: string
            first_name?: string
            last_name?: string
          } | null
        }
      }
    }
    responses: {
      200: components['responses']['SAMLConnection']
      402: components['responses']['PaymentRequired']
      403: components['responses']['AuthorizationInvalid']
      422: components['responses']['UnprocessableEntity']
    }
  }
  /**
   * Retrieve a SAML Connection by ID
   * @description Fetches the SAML Connection whose ID matches the provided `saml_connection_id` in the path.
   */
  GetSAMLConnection: {
    parameters: {
      path: {
        /** @description The ID of the SAML Connection */
        saml_connection_id: string
      }
    }
    responses: {
      200: components['responses']['SAMLConnection']
      402: components['responses']['PaymentRequired']
      403: components['responses']['AuthorizationInvalid']
      404: components['responses']['ResourceNotFound']
    }
  }
  /**
   * Delete a SAML Connection
   * @description Deletes the SAML Connection whose ID matches the provided `id` in the path.
   */
  DeleteSAMLConnection: {
    parameters: {
      path: {
        /** @description The ID of the SAML Connection to delete */
        saml_connection_id: string
      }
    }
    responses: {
      200: components['responses']['DeletedObject']
      402: components['responses']['PaymentRequired']
      403: components['responses']['AuthorizationInvalid']
      404: components['responses']['ResourceNotFound']
    }
  }
  /**
   * Update a SAML Connection
   * @description Updates the SAML Connection whose ID matches the provided `id` in the path.
   */
  UpdateSAMLConnection: {
    parameters: {
      path: {
        /** @description The ID of the SAML Connection to update */
        saml_connection_id: string
      }
    }
    requestBody: {
      content: {
        'application/json': {
          /** @description The name of the new SAML Connection */
          name?: string | null
          /** @description The domain to use for the new SAML Connection */
          domain?: string | null
          /** @description The entity id as provided by the IdP */
          idp_entity_id?: string | null
          /** @description The SSO url as provided by the IdP */
          idp_sso_url?: string | null
          /** @description The x509 certificated as provided by the IdP */
          idp_certificate?: string | null
          /** @description The URL which serves the IdP metadata. If present, it takes priority over the corresponding individual properties and replaces them */
          idp_metadata_url?: string | null
          /** @description The XML content of the IdP metadata file. If present, it takes priority over the corresponding individual properties */
          idp_metadata?: string | null
          /** @description Define the atrtibute name mapping between Identity Provider and Clerk's user properties */
          attribute_mapping?: {
            user_id?: string
            email_address?: string
            first_name?: string
            last_name?: string
          } | null
          /** @description Activate or de-activate the SAML Connection */
          active?: boolean | null
          /** @description Controls whether to update the user's attributes in each sign-in */
          sync_user_attributes?: boolean | null
          /** @description Allow users with an email address subdomain to use this connection in order to authenticate */
          allow_subdomains?: boolean | null
          /** @description Enable or deactivate IdP-initiated flows */
          allow_idp_initiated?: boolean | null
        }
      }
    }
    responses: {
      200: components['responses']['SAMLConnection']
      402: components['responses']['PaymentRequired']
      403: components['responses']['AuthorizationInvalid']
      404: components['responses']['ResourceNotFound']
      422: components['responses']['UnprocessableEntity']
    }
  }
  /**
   * Retrieve a new testing token
   * @description Retrieve a new testing token. Only available for development instances.
   */
  CreateTestingToken: {
    responses: {
      200: components['responses']['TestingToken']
      /** @description The instance is a production instance, but this endpoint is only available in development instances. */
      400: {
        content: never
      }
    }
  }
}

export interface oasTypes {
  components: components
  external: external
  operations: operations
  paths: paths
  webhooks: webhooks
}

export default oasTypes
