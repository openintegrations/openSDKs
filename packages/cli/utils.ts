// shebang not working for some reason... https://github.com/privatenumber/tsx/issues/440
// #!/usr/bin/env node --import tsx

import * as fs from 'node:fs'
import type {OpenAPI3} from 'openapi-typescript'
import openapiTS from 'openapi-typescript'
import prettier from 'prettier'
import R from 'remeda'
import yaml from 'yaml'
import type {HTTPMethod, oas30, OpenAPISpec} from '@opensdks/runtime'

export async function prettyFormat(
  content: string,
  opts?: {parser?: 'typescript' | 'json'},
) {
  // Temp workaround for the fact that prettier doesn't always work in client environments easily
  // TODO: Make me a global flag rather than env var
  if (process.env['NO_PRETTY']) {
    return content
  }
  return prettier.format(content, {
    ...(await import('./prettier.config.js')).default,
    parser: opts?.parser ?? 'typescript',
  })
}

export function generateMeta(
  oas: OpenAPISpec,
  opts: {exportDefault?: boolean} = {},
) {
  // TODO: Do some validation here.

  // const content = `
  //   export const info = ${JSON.stringify(oas.info ?? {})} as const

  //   export const servers = ${JSON.stringify(oas.servers ?? [])} as const
  // `
  const data = R.pick(oas, ['info', 'servers'])
  const content = `
  // This file is generated by @opensdks/cli, do not edit manually.
  export const oasMeta = ${JSON.stringify(data)} as const
  ${opts.exportDefault ? 'export default oasMeta' : ''}
  `

  return content
}

export async function generateTypes(
  oas: OpenAPISpec,
  opts: {exportDefault?: boolean} = {},
) {
  const types = await openapiTS(oas as OpenAPI3)

  return `${types}

export interface oasTypes {
  components: components
  external: external
  operations: operations
  paths: paths
  webhooks: webhooks
}

${opts.exportDefault ? 'export default oasTypes' : ''}
`
}

export function generateSDKDef(
  name: string,
  {
    oasNames: _oasNames,
    ...opts
  }: {
    importOasTypes?: boolean
    importOasMeta?: boolean
    headersTemplate?: string
    oasNames?: string[]
  } = {},
) {
  const upperName = name.slice(0, 1).toUpperCase() + name.slice(1)
  const imports = {
    oasTypes: `import type {oasTypes} from '../${name}.oas.types.js'`,
    oasMeta: `import {oasMeta} from './${name}.oas.meta.js'`,
  }
  const kSDKTypes = `${upperName}SDKTypes`
  const oasNames = _oasNames?.map((oasName) =>
    oasName.replace(`${name}_`, '').replace('.oas.json', ''),
  )

  const multiImports = oasNames
    ? `
  ${oasNames
    .map((n) => `import type Oas_${n} from '../${name}_${n}.oas.types.js'`)
    .join('\n')}

${oasNames
  .map((n) => `import {default as oas_${n}} from './${name}_${n}.oas.meta.js'`)
  .join('\n')}

export type {
  ${oasNames.map((oasName) => `Oas_${oasName}`).join(',\n  ')},
}

export {
  ${oasNames.map((oasName) => `oas_${oasName}`).join(',\n  ')},
}`
    : ''
  const createClient = oasNames
    ? `createClient(ctx, options) {
    ${oasNames
      .map(
        (n) => `const ${n} = ctx.createClient<Oas_${n}['paths']>({
        ...options,
        baseUrl: options.baseUrl ?? oas_${n}.servers[0]?.url,
      })`,
      )
      .join('\n')}
    
      return {
        ${oasNames.join(',\n')}
      }
    }`
    : ''
  // TODO: Figure out how to run organize imports also on the final result..
  // Seems more scalable than trying to remove unused imports manually.
  return `
import type {ClientOptions, SdkDefinition, SDKTypes${
    opts.importOasTypes ? '' : ', OpenAPITypes'
  }} from '@opensdks/runtime'
import {initSDK} from '@opensdks/runtime'
${opts.importOasTypes ? imports.oasTypes : ''}
${opts.importOasMeta ? imports.oasMeta : ''}

${multiImports}

export type ${kSDKTypes} = SDKTypes<${
    opts.importOasTypes ? 'oasTypes' : 'OpenAPITypes'
  }, 
${
  opts.headersTemplate
    ? `Omit<ClientOptions, 'headers'> & ${opts.headersTemplate}`
    : 'ClientOptions'
}
>

export const ${name}SdkDef = {
  types: {} as ${kSDKTypes},
  ${opts.importOasMeta ? 'oasMeta,' : 'defaultOptions: {},'}
  ${createClient}
} satisfies SdkDefinition<${kSDKTypes}>

export function init${upperName}SDK(opts: ${kSDKTypes}['options']) {
  return initSDK(${name}SdkDef, opts)
}

export type ${upperName}SDK = ReturnType<typeof init${upperName}SDK>

export default init${upperName}SDK
`
}

export async function generateMultiFileFromOas(oasPath: string) {
  const oas = await getJson<OpenAPISpec>(oasPath)
  const meta = await prettyFormat(generateMeta(oas, {exportDefault: true}))

  const types = await prettyFormat(
    await generateTypes(oas, {exportDefault: true}),
  )

  return {meta, types}
}

export async function generateSingleFileFromOas(
  oasPath: string,
  opts: {name: string},
) {
  const oas = await getJson<OpenAPISpec>(oasPath)

  const meta = generateMeta(oas, {})
  const types = await generateTypes(oas, {})
  const sdkDefs = generateSDKDef(opts.name, {})
  return await prettyFormat(`
  /** 
   * This file was generated by @opensdks/cli, do not edit manually.
   * For bugs & feature requests, please open an issue on the [GitHub](https://github.com/tonyxiao/openSDKs)
   */
  ${meta}
  ${sdkDefs}
  ${types}
  `)
}

export async function getText(input: string) {
  try {
    const url = new URL(input)
    const res = await fetch(url)
    if (res.status >= 400) {
      throw new Error(`Failed to fetch ${input}, got status ${res.status}`)
    }
    return await res.text()
  } catch (err) {
    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-explicit-any
    if ((err as any)?.code !== 'ERR_INVALID_URL') {
      throw err
    }
    return fs.readFileSync(input, 'utf8')
  }
}

export function parseJsonOrYaml(text: string): unknown {
  try {
    return JSON.parse(text)
  } catch (err) {
    if (!(err instanceof SyntaxError)) {
      throw err
    }
    return yaml.parse(text)
  }
}

export async function getJson<T>(input: string): Promise<T> {
  const text = await getText(input)
  return parseJsonOrYaml(text) as T
}

// MARK: -

export async function listEndpointNames(filename: string) {
  const oas = await getJson<OpenAPISpec>(filename)
  const baseUrl = oas.servers?.[0]?.url.replace(/\/$/, '') ?? ''

  return getEndpoints(oas).map((ep) => {
    const url = new URL(`${baseUrl}`)

    return `${ep.method.toUpperCase().padEnd(6)}\t${
      ep.operation.operationId ?? ''
    }\t${url.pathname}${ep.path}`
  })
}

export function getEndpoints(oas: OpenAPISpec) {
  return Object.entries(oas.paths ?? {})
    .flatMap(([path, pathItem]) =>
      Object.entries(pathItem as {}).map(([method, op]) => {
        if (!isOperation(op)) {
          return null
        }
        return {method: method as HTTPMethod, path, operation: op}
      }),
    )
    .filter((i): i is NonNullable<typeof i> => !!i)
}

function isOperation(op: unknown): op is oas30.OperationObject {
  return op != null && typeof op === 'object' && 'responses' in op
}

export {snakeCase} from 'change-case'
