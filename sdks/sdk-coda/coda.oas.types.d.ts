/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

/** OneOf type helpers */
type Without<T, U> = {[P in Exclude<keyof T, keyof U>]?: never}
type XOR<T, U> = T | U extends object
  ? (Without<T, U> & U) | (Without<U, T> & T)
  : T | U
type OneOf<T extends any[]> = T extends [infer Only]
  ? Only
  : T extends [infer A, infer B, ...infer Rest]
    ? OneOf<[XOR<A, B>, ...Rest]>
    : never

export interface paths {
  '/categories': {
    /**
     * Get doc categories
     * @description Gets all available doc categories.
     */
    get: operations['listCategories']
  }
  '/docs': {
    /**
     * List available docs
     * @description Returns a list of Coda docs accessible by the user. These are returned in the same order as on the docs page: reverse chronological by the latest event relevant to the user (last viewed, edited, or shared).
     */
    get: operations['listDocs']
    /**
     * Create doc
     * @description Creates a new Coda doc, optionally copying an existing doc. Note that creating a doc requires you to be a Doc Maker in the applicable workspace (or be auto-promoted to one).
     */
    post: operations['createDoc']
  }
  '/docs/{docId}': {
    /**
     * Get info about a doc
     * @description Returns metadata for the specified doc.
     */
    get: operations['getDoc']
    /**
     * Delete doc
     * @description Deletes a doc.
     */
    delete: operations['deleteDoc']
    /**
     * Update doc
     * @description Updates metadata for a doc. Note that updating a doc title requires you to be a Doc Maker in the applicable workspace.
     */
    patch: operations['updateDoc']
  }
  '/docs/{docId}/acl/metadata': {
    /**
     * Get sharing metadata
     * @description Returns metadata associated with sharing for this Coda doc.
     */
    get: operations['getSharingMetadata']
  }
  '/docs/{docId}/acl/permissions': {
    /**
     * List permissions
     * @description Returns a list of permissions for this Coda doc.
     */
    get: operations['getPermissions']
    /**
     * Add permission
     * @description Adds a new permission to the doc.
     */
    post: operations['addPermission']
  }
  '/docs/{docId}/acl/permissions/{permissionId}': {
    /**
     * Delete permission
     * @description Deletes an existing permission.
     */
    delete: operations['deletePermission']
  }
  '/docs/{docId}/acl/principals/search': {
    /**
     * Search principals
     * @description Searches for user and group principals matching the query that this doc can be shared with.
     * At most 20 results will be returned for both users and groups. If no query is given then no results are returned.
     */
    get: operations['searchPrincipals']
  }
  '/docs/{docId}/acl/settings': {
    /**
     * Get ACL settings
     * @description Returns settings associated with ACLs for this Coda doc.
     */
    get: operations['getAclSettings']
    /**
     * Update ACL settings
     * @description Update settings associated with ACLs for this Coda doc.
     */
    patch: operations['updateAclSettings']
  }
  '/docs/{docId}/publish': {
    /**
     * Publish doc
     * @description Update publish settings for a doc.
     */
    put: operations['publishDoc']
    /**
     * Unpublish doc
     * @description Unpublishes a doc.
     */
    delete: operations['unpublishDoc']
  }
  '/docs/{docId}/pages': {
    /**
     * List pages
     * @description Returns a list of pages in a Coda doc.
     */
    get: operations['listPages']
    /**
     * Create a page
     * @description Create a new page in a doc. Note that creating a page requires you to be a Doc Maker in the applicable workspace.
     */
    post: operations['createPage']
  }
  '/docs/{docId}/pages/{pageIdOrName}': {
    /**
     * Get a page
     * @description Returns details about a page.
     */
    get: operations['getPage']
    /**
     * Update a page
     * @description Update properties for a page. Note that updating a page title or icon requires you to be a Doc Maker in the applicable workspace.
     */
    put: operations['updatePage']
    /**
     * Delete a page
     * @description Deletes the specified page.
     */
    delete: operations['deletePage']
  }
  '/docs/{docId}/pages/{pageIdOrName}/export': {
    /**
     * Begin content export
     * @description Initiate an export of content for the given page.
     */
    post: operations['beginPageContentExport']
  }
  '/docs/{docId}/pages/{pageIdOrName}/export/{requestId}': {
    /**
     * Content export status
     * @description Check the status of a page content export
     */
    get: operations['getPageContentExportStatus']
  }
  '/docs/{docId}/tables': {
    /**
     * List tables
     * @description Returns a list of tables in a Coda doc.
     */
    get: operations['listTables']
  }
  '/docs/{docId}/tables/{tableIdOrName}': {
    /**
     * Get a table
     * @description Returns details about a specific table or view.
     */
    get: operations['getTable']
  }
  '/docs/{docId}/tables/{tableIdOrName}/columns': {
    /**
     * List columns
     * @description Returns a list of columns in a table.
     */
    get: operations['listColumns']
  }
  '/docs/{docId}/tables/{tableIdOrName}/rows': {
    /**
     * List table rows
     * @description Returns a list of rows in a table.
     * ### Value results
     * The `valueFormat` parameter dictates in what format the API should return values for individual cells.
     * * `simple` (default): Returns cell values as the following JSON values: `string`, `number`, or `boolean`. Array values (like multiselects) are returned as comma-delimited strings.
     * * `simpleWithArrays`: Singleton values are returned as `simple`. Array values are returned as JSON arrays and the values within are `simple` values (including nested arrays).
     * * `rich`: If applicable, returns many values with further encoding, allowing API users to have lossless access to data in Coda.
     *   * For `text` values, returns data in Markdown syntax. If the text field is simple text (e.g. has no formatting),
     *   the field will be fully escaped with triple-ticks. E.g
     *   `
     *   ```This is plain text```
     *   `
     *   * For `currency`, `lookup`, `image`, `person` and `hyperlink` values, the value will be encoded in [JSON-LD](https://json-ld.org/) format.
     *
     * ```
     *   // Currency
     *   {
     *     "@context": "http://schema.org",
     *     "@type": "MonetaryAmount",
     *     "currency": "USD",
     *     "amount": 42.42
     *   }
     *
     *   // Lookup
     *   {
     *     "@context": "http://schema.org",
     *     "@type": "StructuredValue",
     *     "additionalType": "row",
     *     "name": "Row Name",
     *     "rowId": "i-123456789",
     *     "tableId": "grid-123456789",
     *     "tableUrl": "https://coda.io/d/_d123456789/grid-123456789",
     *     "url": "https://coda.io/d/_d123456789/grid-123456789#_r42",
     *   }
     *
     *   // Hyperlink
     *   {
     *     "@context": "http://schema.org",
     *     "@type": "WebPage",
     *     "name": "Coda",
     *     "url": "https://coda.io"
     *   }
     *
     *   // Image
     *   {
     *     "@context": "http://schema.org",
     *     "@type": "ImageObject",
     *     "name": "Coda logo",
     *     "url": "https://coda.io/logo.jpg"
     *   }
     *
     *   // People
     *   {
     *     "@context": "http://schema.org",
     *     "@type": "Person",
     *     "name": "Art Vandalay",
     *     "email": "art@vandalayindustries.com"
     *   }
     * ```
     */
    get: operations['listRows']
    /**
     * Insert/upsert rows
     * @description Inserts rows into a table, optionally updating existing rows if any upsert key columns are provided. This endpoint will always return a 202, so long as the doc and table exist and are accessible (and the update is structurally valid). Row inserts/upserts are generally processed within several seconds. Note: this endpoint only works for base tables, not views.
     * When upserting, if multiple rows match the specified key column(s), they will all be updated with the specified value.
     */
    post: operations['upsertRows']
    /**
     * Delete multiple rows
     * @description Deletes the specified rows from the table or view. This endpoint will always return a 202. Row deletions are generally processed within several seconds.
     */
    delete: operations['deleteRows']
  }
  '/docs/{docId}/tables/{tableIdOrName}/rows/{rowIdOrName}': {
    /**
     * Get a row
     * @description Returns details about a row in a table.
     */
    get: operations['getRow']
    /**
     * Update row
     * @description Updates the specified row in the table. This endpoint will always return a 202, so long as the row exists and is accessible (and the update is structurally valid). Row updates are generally processed within several seconds. When updating using a name as opposed to an ID, an arbitrary row will be affected.
     */
    put: operations['updateRow']
    /**
     * Delete row
     * @description Deletes the specified row from the table or view. This endpoint will always return a 202, so long as the row exists and is accessible (and the update is structurally valid). Row deletions are generally processed within several seconds. When deleting using a name as opposed to an ID, an arbitrary row will be removed.
     */
    delete: operations['deleteRow']
  }
  '/docs/{docId}/tables/{tableIdOrName}/rows/{rowIdOrName}/buttons/{columnIdOrName}': {
    /**
     * Push a button
     * @description Pushes a button on a row in a table.
     * Authorization note: This action is available to API tokens that are authorized to write to the table. However, the underlying button can perform any action on the document, including writing to other tables and performing Pack actions.
     */
    post: operations['pushButton']
  }
  '/docs/{docId}/tables/{tableIdOrName}/columns/{columnIdOrName}': {
    /**
     * Get a column
     * @description Returns details about a column in a table.
     */
    get: operations['getColumn']
  }
  '/docs/{docId}/formulas': {
    /**
     * List formulas
     * @description Returns a list of named formulas in a Coda doc.
     */
    get: operations['listFormulas']
  }
  '/docs/{docId}/formulas/{formulaIdOrName}': {
    /**
     * Get a formula
     * @description Returns info on a formula.
     */
    get: operations['getFormula']
  }
  '/docs/{docId}/controls': {
    /**
     * List controls
     * @description Returns a list of controls in a Coda doc.
     */
    get: operations['listControls']
  }
  '/docs/{docId}/controls/{controlIdOrName}': {
    /**
     * Get a control
     * @description Returns info on a control.
     */
    get: operations['getControl']
  }
  '/docs/${docId}/domains': {
    /**
     * List custom doc domains
     * @description List all custom domains for a published doc.
     */
    get: operations['listCustomDocDomains']
    /**
     * Add custom domain
     * @description Add a custom domain to a published doc.
     */
    post: operations['addCustomDocDomain']
  }
  '/docs/{docId}/domains/{customDocDomain}': {
    /**
     * Deletes a custom domain
     * @description Deletes a custom domain from a published doc.
     */
    delete: operations['deleteCustomDocDomain']
    /**
     * Updates a custom domain
     * @description Updates properties of a document's custom domain.
     */
    patch: operations['updateCustomDocDomain']
  }
  '/domains/provider/{customDocDomain}': {
    /**
     * Gets custom doc domains providers
     * @description Gets the provider (ie. GoDaddy) of a custom domain.
     */
    get: operations['getCustomDocDomainProvider']
  }
  '/whoami': {
    /**
     * Get user info
     * @description Returns basic info about the current user.
     */
    get: operations['whoami']
  }
  '/resolveBrowserLink': {
    /**
     * Resolve browser link
     * @description Given a browser link to a Coda object, attempts to find it and return metadata that can be used to get more info on it. Returns a 400 if the URL does not appear to be a Coda URL or a 404 if the resource cannot be located with the current credentials.
     */
    get: operations['resolveBrowserLink']
  }
  '/mutationStatus/{requestId}': {
    /**
     * Get mutation status
     * @description Get the status for an asynchronous mutation to know whether or not it has been completed. Each API endpoint that mutates a document will return a request id that you can pass to this endpoint to check the completion status. Status information is not guaranteed to be available for more than one day after the mutation was completed. It is intended to be used shortly after the request was made.
     */
    get: operations['getMutationStatus']
  }
  '/docs/{docId}/hooks/automation/{ruleId}': {
    /**
     * Trigger automation
     * @description Triggers webhook-invoked automation
     */
    post: operations['triggerWebhookAutomation']
  }
  '/analytics/docs': {
    /**
     * List doc analytics
     * @description Returns analytics data for available docs per day.
     */
    get: operations['listDocAnalytics']
  }
  '/analytics/docs/{docId}/pages': {
    /**
     * List page analytics
     * @description Returns analytics data for a given doc within the day.
     * This method will return a 401 if the given doc is not in an Enterprise workspace.
     */
    get: operations['listPageAnalytics']
  }
  '/analytics/docs/summary': {
    /**
     * Get doc analytics summary
     * @description Returns summarized analytics data for available docs.
     */
    get: operations['listDocAnalyticsSummary']
  }
  '/analytics/packs': {
    /**
     * List Pack analytics
     * @description Returns analytics data for Packs the user can edit.
     */
    get: operations['listPackAnalytics']
  }
  '/analytics/packs/summary': {
    /**
     * Get Pack analytics summary
     * @description Returns summarized analytics data for Packs the user can edit.
     */
    get: operations['listPackAnalyticsSummary']
  }
  '/analytics/packs/{packId}/formulas': {
    /**
     * List Pack formula analytics
     * @description Returns analytics data for Pack formulas.
     */
    get: operations['listPackFormulaAnalytics']
  }
  '/analytics/updated': {
    /**
     * Get analytics last updated day
     * @description Returns days based on Pacific Standard Time when analytics were last updated.
     */
    get: operations['getAnalyticsLastUpdated']
  }
  '/workspaces/{workspaceId}/users': {
    /**
     * List workspace users
     * @description Returns a list of members in the given workspace. This list will be ordered with the requesting user first and then ordered by role.
     */
    get: operations['listWorkspaceMembers']
  }
  '/workspaces/{workspaceId}/users/role': {
    /**
     * Updates user role
     * @description Updates the workspace user role of a user that matches the parameters. Only succeeds if the requesting user has admin permissions in the workspace.
     */
    post: operations['changeUserRole']
  }
  '/workspaces/{workspaceId}/roles': {
    /**
     * List workspace roles
     * @description Returns a list of the counts of users over time by role for the workspace.
     */
    get: operations['listWorkspaceRoleActivity']
  }
  '/packs': {
    /**
     * List Packs
     * @description Get the list of accessible Packs.
     */
    get: operations['listPacks']
    /**
     * Create Pack
     * @description Creates a new Pack, essentially registering a new Pack ID. The contents of the Pack will be uploaded separately.
     */
    post: operations['createPack']
  }
  '/packs/{packId}': {
    /**
     * Get a single Pack
     * @description Returns a single Pack.
     */
    get: operations['getPack']
    /**
     * Delete Pack
     * @description Delete a given Pack.
     */
    delete: operations['deletePack']
    /**
     * Update Pack
     * @description Update an existing Pack for non-versioned fields.
     */
    patch: operations['updatePack']
  }
  '/packs/{packId}/configurations/schema': {
    /**
     * Gets the JSON Schema for Pack configuration.
     * @description Returns a JSON Schema applicable for customizing the pack using Pack configurations.
     */
    get: operations['getPackConfigurationSchema']
  }
  '/packs/{packId}/versions': {
    /**
     * List the versions for a Pack.
     * @description Get the list of versions of a Pack.
     */
    get: operations['listPackVersions']
  }
  '/packs/{packId}/nextVersion': {
    /**
     * Get the next valid version for a Pack.
     * @description Get the next valid version based on the proposed metadata.
     */
    post: operations['getNextPackVersion']
  }
  '/packs/{packId}/versions/{basePackVersion}/diff/{targetPackVersion}': {
    /**
     * Get the difference between two pack versions.
     * @description Gets information about the difference between the specified previous version and next version of a Pack.
     */
    get: operations['getPackVersionDiffs']
  }
  '/packs/{packId}/versions/{packVersion}/register': {
    /**
     * Register Pack version
     * @description Registers a new Pack version. This simply returns a signed URL to use for uploading the Pack version definition. Following the completion of the upload, POST to /apis/v1/packs/{packId}/versions/{packVersion} trigger the rest of the creation process.
     */
    post: operations['registerPackVersion']
  }
  '/packs/{packId}/versions/{packVersion}/uploadComplete': {
    /**
     * Pack version upload complete
     * @description Note the completion of the upload of a Pack version bundle in order to create that Pack version.
     */
    post: operations['packVersionUploadComplete']
  }
  '/packs/{packId}/releases': {
    /**
     * List the releases for a Pack.
     * @description Get the list of releases of a Pack.
     */
    get: operations['listPackReleases']
    /**
     * Create a new Pack release.
     * @description Creates a new Pack release based on an existing Pack version.
     */
    post: operations['createPackRelease']
  }
  '/packs/{packId}/releases/{packReleaseId}': {
    /**
     * Update an existing Pack release.
     * @description Update details of a Pack release.
     */
    put: operations['updatePackRelease']
  }
  '/packs/{packId}/oauthConfig': {
    /**
     * Retrieve the OAuth configuration of the Pack.
     * @description Retrieve the OAuth configuration of the Pack for display purpose. Secrets will be returned with masks.
     */
    get: operations['getPackOauthConfig']
    /**
     * Set the OAuth configurations of the Pack.
     * @description Set the OAuth configurations of the Pack, including client id and secret.
     */
    put: operations['setPackOauthConfig']
  }
  '/packs/{packId}/systemConnection': {
    /**
     * Retrieve the system connection metadata of the Pack.
     * @description Retrieve the system connection metadata of the Pack.
     */
    get: operations['getPackSystemConnection']
    /**
     * Set the system connection credentials of the Pack.
     * @description Set the system connection credentials of the Pack.
     */
    put: operations['setPackSystemConnection']
    /**
     * Patch the system connection credentials of the Pack.
     * @description Patch the system connection credentials of the Pack.
     */
    patch: operations['patchPackSystemConnection']
  }
  '/packs/{packId}/permissions': {
    /**
     * List permissions for a Pack
     * @description Get user, workspace, and/or global permissions for a given Pack.
     */
    get: operations['getPackPermissions']
    /**
     * Add a permission for Pack
     * @description Create or modify user, workspace, or global permissions for a given Pack.
     */
    post: operations['addPackPermission']
  }
  '/packs/{packId}/permissions/{permissionId}': {
    /**
     * Delete a permission for Pack
     * @description Delete user, workspace, or global permissions for a given Pack.
     */
    delete: operations['deletePackPermission']
  }
  '/packs/{packId}/makers': {
    /**
     * List makers for Pack
     * @description List makers for a given pack.
     */
    get: operations['listPackMakers']
  }
  '/packs/{packId}/maker': {
    /**
     * Add a maker for Pack
     * @description Set a maker for a given Pack. Used to display makers for a pack in the corresponding packs page.
     */
    post: operations['addPackMaker']
  }
  '/packs/{packId}/maker/{loginId}': {
    /**
     * Delete a maker for Pack
     * @description Delete a maker for a given Pack, who will not be displayed in the corresponding packs page.
     */
    delete: operations['deletePackMaker']
  }
  '/packs/{packId}/categories': {
    /**
     * List categories for Pack
     * @description List publishing categories for a given pack.
     */
    get: operations['listPackCategories']
  }
  '/packs/{packId}/category': {
    /**
     * Add a category for Pack
     * @description Add a publishing category for a given pack.
     */
    post: operations['addPackCategory']
  }
  '/packs/{packId}/category/{categoryName}': {
    /**
     * Delete a category for Pack
     * @description Delete a publishing category for a given pack.
     */
    delete: operations['deletePackCategory']
  }
  '/packs/{packId}/uploadAsset': {
    /**
     * Upload a Pack asset.
     * @description Request a signed s3 URL to upload your Pack asset.
     */
    post: operations['uploadPackAsset']
  }
  '/packs/{packId}/uploadSourceCode': {
    /**
     * Upload Pack source code.
     * @description Request a signed s3 URL to upload your Pack source code.
     */
    post: operations['uploadPackSourceCode']
  }
  '/packs/{packId}/assets/{packAssetId}/assetType/{packAssetType}/uploadComplete': {
    /**
     * Pack asset upload complete
     * @description Note the completion of the upload of a Pack asset.
     */
    post: operations['packAssetUploadComplete']
  }
  '/packs/{packId}/versions/{packVersion}/sourceCode/uploadComplete': {
    /**
     * Pack source code upload complete
     * @description Note the completion of the upload of a Pack source code.
     */
    post: operations['packSourceCodeUploadComplete']
  }
  '/packs/{packId}/versions/{packVersion}/sourceCode': {
    /**
     * get the source code for a Pack version.
     * @description Get temporary links used to download the source code for the given packId and version
     */
    get: operations['getPackSourceCode']
  }
  '/packs/listings': {
    /**
     * List the Pack listings accessible to a user.
     * @description Get listings of public Packs and Packs created by you.
     */
    get: operations['listPackListings']
  }
  '/packs/{packId}/listing': {
    /**
     * Get detailed listing information for a Pack.
     * @description Get detailed listing information for a Pack.
     */
    get: operations['getPackListing']
  }
  '/packs/{packId}/docs/{docId}/logs': {
    /**
     * Retrieve the logs of a Pack.
     * @description Retrieve the logs of a Pack for debugging purpose.
     */
    get: operations['listPackLogs']
  }
  '/packs/{packId}/organizationId/{organizationId}/rootIngestionId/{rootIngestionId}/logs': {
    /**
     * Retrieve the logs of a Ingestion.
     * @description Retrieve the logs of a Ingestion for debugging purpose.
     */
    get: operations['listIngestionLogs']
  }
  '/packs/{packId}/docs/{docId}/groupedLogs': {
    /**
     * Retrieve the grouped logs of a Pack.
     * @description Retrieve the grouped logs of a Pack for debugging purpose.
     */
    get: operations['listGroupedPackLogs']
  }
  '/packs/{packId}/organizationId/{organizationId}/rootIngestionId/{rootIngestionId}/ingestionExecutionId/{ingestionExecutionId}/groupedLogs': {
    /**
     * Retrieve the grouped logs of a Pack for a specific ingestionExecutionId.
     * @description Retrieve the grouped logs of a Pack for debugging purpose.
     */
    get: operations['listGroupedIngestionLogs']
  }
  '/packs/{packId}/organizationId/{organizationId}/rootIngestionId/{rootIngestionId}/ingestionExecutions': {
    /**
     * Retrieve a list of ingestion execution ids for the given root ingestion id.
     * @description Retrieve the ingestion execution ids of a root ingestion for debugging purpose.
     */
    get: operations['listIngestionExecutions']
  }
  '/packs/{packId}/featuredDocs': {
    /**
     * List featured docs for a Pack
     * @description Returns a list of featured doc ids for a Pack.
     */
    get: operations['listPackFeaturedDocs']
    /**
     * Update featured docs for a Pack
     * @description Create or replace the featured docs for a Pack.
     */
    put: operations['updatePackFeaturedDocs']
  }
}

export type webhooks = Record<string, never>

export interface components {
  schemas: {
    /**
     * @description A constant identifying the type of the resource.
     * @enum {string}
     */
    Type:
      | 'aclMetadata'
      | 'aclPermissions'
      | 'aclSettings'
      | 'analyticsLastUpdated'
      | 'apiLink'
      | 'automation'
      | 'column'
      | 'control'
      | 'doc'
      | 'customDocDomain'
      | 'customDocDomainProvider'
      | 'docAnalytics'
      | 'docAnalyticsSummary'
      | 'docAnalyticsV2'
      | 'folder'
      | 'formula'
      | 'mutationStatus'
      | 'pack'
      | 'packAclPermissions'
      | 'packAnalytics'
      | 'packAnalyticsSummary'
      | 'packAsset'
      | 'packCategory'
      | 'packConfigurationSchema'
      | 'packFeaturedDocs'
      | 'packFormulaAnalytics'
      | 'packLog'
      | 'packMaker'
      | 'packOauthConfig'
      | 'packRelease'
      | 'packSourceCode'
      | 'packSystemConnection'
      | 'packVersion'
      | 'page'
      | 'pageContentExport'
      | 'pageContentExportStatus'
      | 'principal'
      | 'row'
      | 'table'
      | 'user'
      | 'workspace'
    /**
     * @description Type of principal.
     * @enum {string}
     */
    PrincipalType: 'email' | 'group' | 'domain' | 'workspace' | 'anyone'
    /** @description Metadata about a principal to add to a doc. */
    AddedPrincipal:
      | components['schemas']['AddedEmailPrincipal']
      | components['schemas']['AddedGroupPrincipal']
      | components['schemas']['AddedDomainPrincipal']
      | components['schemas']['AddedWorkspacePrincipal']
      | components['schemas']['AddedAnyonePrincipal']
    AddedEmailPrincipal: {
      /**
       * @description The type of this principal.
       * @enum {string}
       */
      type: 'email'
      /**
       * @description Email for the principal.
       * @example example@domain.com
       */
      email: string
    }
    AddedGroupPrincipal: {
      /**
       * @description The type of this principal.
       * @enum {string}
       */
      type: 'group'
      /**
       * @description Group ID for the principal.
       * @example grp-6SM9xrKcqW
       */
      groupId: string
    }
    AddedDomainPrincipal: {
      /**
       * @description The type of this principal.
       * @enum {string}
       */
      type: 'domain'
      /**
       * @description Domain for the principal.
       * @example domain.com
       */
      domain: string
    }
    AddedWorkspacePrincipal: {
      /**
       * @description The type of this principal.
       * @enum {string}
       */
      type: 'workspace'
      /**
       * @description WorkspaceId for the principal.
       * @example ws-sdfmsdf9
       */
      workspaceId: string
    }
    AddedAnyonePrincipal: {
      /**
       * @description The type of this principal.
       * @enum {string}
       */
      type: 'anyone'
    }
    /** @description Metadata about a principal. */
    Principal:
      | components['schemas']['EmailPrincipal']
      | components['schemas']['GroupPrincipal']
      | components['schemas']['DomainPrincipal']
      | components['schemas']['WorkspacePrincipal']
      | components['schemas']['AnyonePrincipal']
    EmailPrincipal: {
      /**
       * @description The type of this principal.
       * @enum {string}
       */
      type: 'email'
      /**
       * @description Email for the principal.
       * @example example@domain.com
       */
      email: string
    }
    GroupPrincipal: {
      /**
       * @description The type of this principal.
       * @enum {string}
       */
      type: 'group'
      /**
       * @description Group ID for the principal.
       * @example grp-6SM9xrKcqW
       */
      groupId: string
      /**
       * @description Name of the group.
       * @example Marketing team
       */
      groupName: string
    }
    DomainPrincipal: {
      /**
       * @description The type of this principal.
       * @enum {string}
       */
      type: 'domain'
      /**
       * @description Domain for the principal.
       * @example domain.com
       */
      domain: string
    }
    WorkspacePrincipal: {
      /**
       * @description The type of this principal.
       * @enum {string}
       */
      type: 'workspace'
      /**
       * @description WorkspaceId for the principal.
       * @example ws-sdfmsdf9
       */
      workspaceId: string
    }
    AnyonePrincipal: {
      /**
       * @description The type of this principal.
       * @enum {string}
       */
      type: 'anyone'
    }
    /**
     * @description Type of access.
     * @enum {string}
     */
    AccessType: 'readonly' | 'write' | 'comment' | 'none'
    /**
     * @description Type of access (excluding none).
     * @enum {string}
     */
    AccessTypeNotNone: 'readonly' | 'write' | 'comment'
    /** @description A specific permission granted to a principal. */
    Permission: {
      principal: components['schemas']['Principal']
      /** @description Id for the Permission */
      id: string
      access: components['schemas']['AccessType']
    }
    /** @description Payload for granting a new permission. */
    AddPermissionRequest: {
      access: components['schemas']['AccessTypeNotNone']
      principal: components['schemas']['AddedPrincipal']
      /** @description When true suppresses email notification */
      suppressEmail?: boolean
    }
    /** @description List of Permissions. */
    Acl: {
      items: components['schemas']['Permission'][]
      /**
       * Format: url
       * @description API link to these results
       * @example https://coda.io/apis/v1/docs/AbCDeFGH/acl?limit=20
       */
      href: string
      nextPageToken?: components['schemas']['nextPageToken']
      nextPageLink?: components['schemas']['nextPageLink'] & string
    }
    /** @description Doc level metadata associated with ACL. */
    AclMetadata: {
      /** @description When true, the user of the api can share */
      canShare: boolean
      /** @description When true, the user of the api can share with the workspace */
      canShareWithWorkspace: boolean
      /** @description When true, the user of the api can share with the org */
      canShareWithOrg: boolean
      /** @description When true, the user of the api can copy the doc */
      canCopy: boolean
    }
    /** @description Sharing settings for the doc. */
    AclSettings: {
      /** @description When true, allows editors to change doc permissions. When false, only doc owner can change doc permissions. */
      allowEditorsToChangePermissions: boolean
      /** @description When true, allows doc viewers to copy the doc. */
      allowCopying: boolean
      /** @description When true, allows doc viewers to request editing permissions. */
      allowViewersToRequestEditing: boolean
    }
    /** @description The result of sharing a doc. */
    AddPermissionResult: Record<string, never>
    /** @description The result of deleting a permission. */
    DeletePermissionResult: Record<string, never>
    /** @description Metadata about the principals that match the given query. */
    SearchPrincipalsResponse: {
      users: components['schemas']['UserSummary'][]
      groups: components['schemas']['GroupPrincipal'][]
    }
    /** @description Request to update ACL settings for a doc. */
    UpdateAclSettingsRequest: {
      /** @description When true, allows editors to change doc permissions. When false, only doc owner can change doc permissions. */
      allowEditorsToChangePermissions?: boolean
      /** @description When true, allows doc viewers to copy the doc. */
      allowCopying?: boolean
      /** @description When true, allows doc viewers to request editing permissions. */
      allowViewersToRequestEditing?: boolean
    }
    /** @description Reference to a Coda doc. */
    DocReference: {
      /**
       * @description ID of the Coda doc.
       * @example AbCDeFGH
       */
      id: string
      /**
       * @description The type of this resource.
       * @enum {string}
       */
      type: 'doc'
      /**
       * Format: url
       * @description API link to the Coda doc.
       * @example https://coda.io/apis/v1/docs/AbCDeFGH
       */
      href: string
      /**
       * Format: url
       * @description Browser-friendly link to the Coda doc.
       * @example https://coda.io/d/_dAbCDeFGH
       */
      browserLink: string
    }
    /** @description Metadata about a Coda doc. */
    Doc: {
      /**
       * @description ID of the Coda doc.
       * @example AbCDeFGH
       */
      id: string
      /**
       * @description The type of this resource.
       * @enum {string}
       */
      type: 'doc'
      /**
       * Format: url
       * @description API link to the Coda doc.
       * @example https://coda.io/apis/v1/docs/AbCDeFGH
       */
      href: string
      /**
       * Format: url
       * @description Browser-friendly link to the Coda doc.
       * @example https://coda.io/d/_dAbCDeFGH
       */
      browserLink: string
      icon?: components['schemas']['Icon']
      /**
       * @description Name of the doc.
       * @example Product Launch Hub
       */
      name: string
      /**
       * Format: email
       * @description Email address of the doc owner.
       * @example user@example.com
       */
      owner: string
      /**
       * @description Name of the doc owner.
       * @example Some User
       */
      ownerName: string
      docSize?: components['schemas']['DocSize']
      sourceDoc?: Record<string, never> & components['schemas']['DocReference']
      /**
       * Format: date-time
       * @description Timestamp for when the doc was created.
       * @example 2018-04-11T00:18:57.946Z
       */
      createdAt: string
      /**
       * Format: date-time
       * @description Timestamp for when the doc was last modified.
       * @example 2018-04-11T00:18:57.946Z
       */
      updatedAt: string
      published?: components['schemas']['DocPublished']
      folder: components['schemas']['FolderReference']
      workspace: components['schemas']['WorkspaceReference']
      /**
       * @deprecated
       * @description ID of the Coda workspace containing this doc.
       * @example ws-1Ab234
       */
      workspaceId: string
      /**
       * @deprecated
       * @description ID of the Coda folder containing this doc.
       * @example fl-1Ab234
       */
      folderId: string
    }
    /** @description The category applied to a doc. */
    DocCategory: {
      /**
       * @description Name of the category.
       * @example Project Management
       */
      name: string
    }
    /** @description A list of categories that can be applied to a doc. */
    DocCategoryList: {
      /** @description Categories for the doc. */
      items: components['schemas']['DocCategory'][]
    }
    /** @description List of Coda docs. */
    DocList: {
      items: components['schemas']['Doc'][]
      /**
       * Format: url
       * @description API link to these results
       * @example https://coda.io/apis/v1/docs?limit=20
       */
      href?: string
      nextPageToken?: components['schemas']['nextPageToken']
      nextPageLink?: components['schemas']['nextPageLink'] & string
    }
    /** @description Payload for creating a new doc. */
    DocCreate: {
      /**
       * @description Title of the new doc. Defaults to 'Untitled'.
       * @example Project Tracker
       */
      title?: string
      /**
       * @description An optional doc ID from which to create a copy.
       * @example iJKlm_noPq
       */
      sourceDoc?: string
      /**
       * @description The timezone to use for the newly created doc.
       * @example America/Los_Angeles
       */
      timezone?: string
      /**
       * @description The ID of the folder within which to create this doc. Defaults to your "My docs" folder in the oldest workspace you joined; this is subject to change. You can get this ID by opening the folder in the docs list on your computer and grabbing the `folderId` query parameter.
       *
       * @example fl-ABcdEFgHJi
       */
      folderId?: string
      initialPage?: Record<string, never> & components['schemas']['PageCreate']
    }
    /** @description The result of a doc deletion. */
    DocDelete: Record<string, never>
    /** @description Payload for updating a doc. */
    DocUpdate: {
      /**
       * @description Title of the doc.
       * @example Project Tracker
       */
      title?: string
      /**
       * @description Name of the icon.
       * @example rocket
       */
      iconName?: string
    }
    /** @description The number of components within a Coda doc. */
    DocSize: {
      /**
       * @description The number of rows contained within all tables of the doc.
       * @example 31337
       */
      totalRowCount: number
      /**
       * @description The total number of tables and views contained within the doc.
       * @example 42
       */
      tableAndViewCount: number
      /**
       * @description The total number of page contained within the doc.
       * @example 10
       */
      pageCount: number
      /**
       * @description If true, indicates that the doc is over the API size limit.
       * @example false
       */
      overApiSizeLimit: boolean
    }
    /** @description Payload for publishing a doc or or updating its publishing information. */
    DocPublish: {
      /**
       * @description Slug for the published doc.
       * @example my-doc
       */
      slug?: string
      /**
       * @description If true, indicates that the doc is discoverable.
       * @example true
       */
      discoverable?: boolean
      /**
       * @description If true, new users may be required to sign in to view content within this document. You will receive Coda credit for each user who signs up via your doc.
       *
       * @example true
       */
      earnCredit?: boolean
      /**
       * @description The names of categories to apply to the document.
       * @example [
       *   "Project management"
       * ]
       */
      categoryNames?: string[]
      mode?: components['schemas']['DocPublishMode']
    }
    /** @description Information about the publishing state of the document. */
    DocPublished: {
      /**
       * @description Description of the published doc.
       * @example Hello World!
       */
      description?: string
      /**
       * @description URL to the published doc.
       * @example https://coda.io/@coda/hello-world
       */
      browserLink: string
      /** @description URL to the cover image for the published doc. */
      imageLink?: string
      /**
       * @description If true, indicates that the doc is discoverable.
       * @example true
       */
      discoverable: boolean
      /**
       * @description If true, new users may be required to sign in to view content within this document. You will receive Coda credit for each user who signs up via your doc.
       *
       * @example true
       */
      earnCredit: boolean
      mode: components['schemas']['DocPublishMode']
      /**
       * @description Categories applied to the doc.
       * @example [
       *   "Project Management"
       * ]
       */
      categories: components['schemas']['DocCategory'][]
    }
    /**
     * @description Which interaction mode the published doc should use.
     * @enum {string}
     */
    DocPublishMode: 'view' | 'play' | 'edit'
    /** @description The result of publishing a doc. */
    PublishResult: components['schemas']['DocumentMutateResponse'] &
      Record<string, never>
    /** @description The result of unpublishing a doc. */
    UnpublishResult: Record<string, never>
    /** @description The result of a doc creation. */
    DocumentCreationResult: {
      /**
       * @description ID of the Coda doc.
       * @example AbCDeFGH
       */
      id: string
      /**
       * @description The type of this resource.
       * @enum {string}
       */
      type: 'doc'
      /**
       * Format: url
       * @description API link to the Coda doc.
       * @example https://coda.io/apis/v1/docs/AbCDeFGH
       */
      href: string
      /**
       * Format: url
       * @description Browser-friendly link to the Coda doc.
       * @example https://coda.io/d/_dAbCDeFGH
       */
      browserLink: string
      icon?: components['schemas']['Icon']
      /**
       * @description Name of the doc.
       * @example Product Launch Hub
       */
      name: string
      /**
       * Format: email
       * @description Email address of the doc owner.
       * @example user@example.com
       */
      owner: string
      /**
       * @description Name of the doc owner.
       * @example Some User
       */
      ownerName: string
      docSize?: components['schemas']['DocSize']
      sourceDoc?: Record<string, never> & components['schemas']['DocReference']
      /**
       * Format: date-time
       * @description Timestamp for when the doc was created.
       * @example 2018-04-11T00:18:57.946Z
       */
      createdAt: string
      /**
       * Format: date-time
       * @description Timestamp for when the doc was last modified.
       * @example 2018-04-11T00:18:57.946Z
       */
      updatedAt: string
      published?: components['schemas']['DocPublished']
      folder: components['schemas']['FolderReference']
      workspace: components['schemas']['WorkspaceReference']
      /**
       * @deprecated
       * @description ID of the Coda workspace containing this doc.
       * @example ws-1Ab234
       */
      workspaceId: string
      /**
       * @deprecated
       * @description ID of the Coda folder containing this doc.
       * @example fl-1Ab234
       */
      folderId: string
      /**
       * @description An arbitrary unique identifier for this request.
       * @example abc-123-def-456
       */
      requestId?: string
    }
    /** @description The result of a doc update */
    DocUpdateResult: Record<string, never>
    /** @description List of all custom domains added to a published doc. */
    CustomDocDomainList: {
      /** @description Custom domains for the published doc. */
      customDocDomains: components['schemas']['CustomDocDomain'][]
      nextPageToken?: components['schemas']['nextPageToken']
      nextPageLink?: components['schemas']['nextPageLink'] & string
    }
    /** @description The custom domain added to a published doc. */
    CustomDocDomain: {
      /**
       * @description The custom domain.
       * @example example.com
       */
      customDocDomain: string
      /**
       * @description Whether the domain has a certificate
       * @example true
       */
      hasCertificate: boolean
      /**
       * @description Whether the domain DNS points back to this doc.
       * @example true
       */
      hasDnsDocId: boolean
      setupStatus: components['schemas']['CustomDocDomainSetupStatus']
      domainStatus: components['schemas']['CustomDomainConnectedStatus']
      /**
       * Format: date-time
       * @description When the domain DNS settings were last checked.
       * @example 2018-04-11T00:18:57.946Z
       */
      lastVerifiedTimestamp?: string
    }
    /** @enum {string} */
    CustomDocDomainProvider:
      | 'GoDaddy'
      | 'Namecheap'
      | 'Hover (Tucows)'
      | 'Network Solutions'
      | 'Google Domains'
      | 'Other'
    /** @enum {string} */
    CustomDocDomainSetupStatus: 'pending' | 'succeeded' | 'failed'
    /** @enum {string} */
    CustomDomainConnectedStatus: 'connected' | 'notConnected'
    /** @description The result of adding a custom domain to a published doc. */
    AddCustomDocDomainResponse: Record<string, never>
    /** @description Payload for adding a custom published doc domain. */
    AddCustomDocDomainRequest: {
      /**
       * @description The custom domain.
       * @example example.com
       */
      customDocDomain: string
    }
    /** @description The result of updating a custom domain for a published doc. */
    UpdateCustomDocDomainResponse: Record<string, never>
    /** @description Payload for updating the properties of a custom published doc domain. */
    UpdateCustomDocDomainRequest: Record<string, never>
    /** @description The result of deleting a custom domain from a published doc. */
    DeleteCustomDocDomainResponse: Record<string, never>
    /** @description The result of determining the domain provider for a custom doc domain. */
    CustomDocDomainProviderResponse: {
      provider: components['schemas']['CustomDocDomainProvider']
    }
    /** @description Reference to a page. */
    PageReference: {
      /**
       * @description ID of the page.
       * @example canvas-IjkLmnO
       */
      id: string
      /**
       * @description The type of this resource.
       * @enum {string}
       */
      type: 'page'
      /**
       * Format: url
       * @description API link to the page.
       * @example https://coda.io/apis/v1/docs/AbCDeFGH/pages/canvas-IjkLmnO
       */
      href: string
      /**
       * Format: url
       * @description Browser-friendly link to the page.
       * @example https://coda.io/d/_dAbCDeFGH/Launch-Status_sumnO
       */
      browserLink: string
      /**
       * @description Name of the page.
       * @example Launch Status
       */
      name: string
    }
    /** @description Metadata about a page. */
    Page: {
      /**
       * @description ID of the page.
       * @example canvas-IjkLmnO
       */
      id: string
      /**
       * @description The type of this resource.
       * @enum {string}
       */
      type: 'page'
      /**
       * Format: url
       * @description API link to the page.
       * @example https://coda.io/apis/v1/docs/AbCDeFGH/pages/canvas-IjkLmnO
       */
      href: string
      /**
       * Format: url
       * @description Browser-friendly link to the page.
       * @example https://coda.io/d/_dAbCDeFGH/Launch-Status_sumnO
       */
      browserLink: string
      /**
       * @description Name of the page.
       * @example Launch Status
       */
      name: string
      /**
       * @description Subtitle of the page.
       * @example See the status of launch-related tasks.
       */
      subtitle?: string
      icon?: components['schemas']['Icon']
      image?: components['schemas']['Image']
      contentType: components['schemas']['PageType']
      /**
       * @description Whether the page is hidden in the UI.
       * @example true
       */
      isHidden: boolean
      /**
       * @description Whether the page or any of its parents is hidden in the UI.
       * @example true
       */
      isEffectivelyHidden: boolean
      parent?: components['schemas']['PageReference']
      children: components['schemas']['PageReference'][]
      /** @description Authors of the page */
      authors?: components['schemas']['PersonValue'][]
      /**
       * Format: date-time
       * @description Timestamp for when the page was created.
       * @example 2018-04-11T00:18:57.946Z
       */
      createdAt?: string
      createdBy?: components['schemas']['PersonValue']
      /**
       * Format: date-time
       * @description Timestamp for when page content was last modified.
       * @example 2018-04-11T00:18:57.946Z
       */
      updatedAt?: string
      updatedBy?: components['schemas']['PersonValue']
    }
    /** @description List of pages. */
    PageList: {
      items: components['schemas']['Page'][]
      /**
       * Format: url
       * @description API link to these results
       * @example https://coda.io/apis/v1/docs/AbCDeFGH/pages?limit=20
       */
      href?: string
      nextPageToken?: components['schemas']['nextPageToken']
      nextPageLink?: components['schemas']['nextPageLink'] & string
    }
    /** @description Payload for creating a new page in a doc. */
    PageCreate: {
      /**
       * @description Name of the page.
       * @example Launch Status
       */
      name?: string
      /**
       * @description Subtitle of the page.
       * @example See the status of launch-related tasks.
       */
      subtitle?: string
      /**
       * @description Name of the icon.
       * @example rocket
       */
      iconName?: string
      /**
       * @description Url of the cover image to use.
       * @example https://example.com/image.jpg
       */
      imageUrl?: string
      /**
       * @description The ID of this new page's parent, if creating a subpage.
       * @example canvas-tuVwxYz
       */
      parentPageId?: string
      pageContent?: components['schemas']['PageCreateContent']
    }
    /** @description Content that can be added to a page at creation time, either text (or rich text) or a URL to create a full-page embed. */
    PageCreateContent: OneOf<
      [
        {
          /**
           * @description Indicates a page containing canvas content.
           * @enum {string}
           */
          type: 'canvas'
          canvasContent: components['schemas']['PageContent']
        },
        {
          /**
           * @description Indicates a page that embeds other content.
           * @enum {string}
           */
          type: 'embed'
          /**
           * @description The URL of the content to embed.
           * @example https://example.com
           */
          url: string
          renderMethod?: components['schemas']['PageEmbedRenderMethod']
        },
        {
          /**
           * @description Indicates a page that embeds other Coda content.
           * @enum {string}
           */
          type: 'syncPage'
          /**
           * @description Indicates a single-page sync page.
           * @enum {string}
           */
          mode: 'page'
          /** @description Include subpages in the sync page. */
          includeSubpages: boolean
          /**
           * @description The page id to insert as a sync page.
           * @example canvas-IjkLmnO
           */
          sourcePageId: string
          /**
           * @description The id of the document to insert as a sync page.
           * @example sHbI4uIwiK
           */
          sourceDocId: string
        },
        {
          /**
           * @description Indicates a page that embeds other content.
           * @enum {string}
           */
          type: 'syncPage'
          /**
           * @description Indicates a full doc sync page.
           * @enum {string}
           */
          mode: 'document'
          /**
           * @description The id of the document to insert as a sync page.
           * @example sHbI4uIwiK
           */
          sourceDocId: string
        },
      ]
    >
    /** @description The result of a page creation. */
    PageCreateResult: components['schemas']['DocumentMutateResponse'] & {
      /**
       * @description ID of the created page.
       * @example canvas-tuVwxYz
       */
      id: string
    }
    /** @description Payload for updating a page. */
    PageUpdate: {
      /**
       * @description Name of the page.
       * @example Launch Status
       */
      name?: string
      /**
       * @description Subtitle of the page.
       * @example See the status of launch-related tasks.
       */
      subtitle?: string
      /**
       * @description Name of the icon.
       * @example rocket
       */
      iconName?: string
      /**
       * @description Url of the cover image to use.
       * @example https://example.com/image.jpg
       */
      imageUrl?: string
      /**
       * @description Whether the page is hidden or not. Note that for pages that cannot be hidden, like the sole top-level page in a doc, this will be ignored.
       * @example true
       */
      isHidden?: boolean
      contentUpdate?: Record<string, never> &
        components['schemas']['PageContentUpdate']
    }
    /** @description The result of a page update. */
    PageUpdateResult: components['schemas']['DocumentMutateResponse'] & {
      /**
       * @description ID of the updated page.
       * @example canvas-tuVwxYz
       */
      id: string
    }
    /** @description The result of a page deletion. */
    PageDeleteResult: components['schemas']['DocumentMutateResponse'] & {
      /**
       * @description ID of the page to be deleted.
       * @example canvas-tuVwxYz
       */
      id: string
    }
    /**
     * @description Mode for inserting content into an existing page.
     * @enum {string}
     */
    PageContentInsertionMode: 'append' | 'replace'
    /** @description Payload for updating the content of an existing page. */
    PageContentUpdate: {
      insertionMode: components['schemas']['PageContentInsertionMode']
      canvasContent: components['schemas']['PageContent']
    }
    /** @description Request for beginning an export of page content. */
    BeginPageContentExportRequest: {
      outputFormat: components['schemas']['PageContentOutputFormat']
    }
    /** @description Response when beginning an export of page content. */
    BeginPageContentExportResponse: {
      /**
       * @description The identifier of this export request.
       * @example AbCDeFGH
       */
      id: string
      /**
       * @description The status of this export.
       * @example complete
       */
      status: string
      /**
       * @description The URL that reports the status of this export. Poll this URL to get the content URL when the export has completed.
       * @example https://coda.io/apis/v1/docs/somedoc/pages/somepage/export/some-request-id
       */
      href: string
    }
    /**
     * @description Supported output content formats that can be requested for getting content for an existing page.
     * @enum {string}
     */
    PageContentOutputFormat: 'html' | 'markdown'
    /**
     * @description Status of a page content export.
     * @enum {string}
     */
    PageContentExportStatus: 'inProgress' | 'failed' | 'complete'
    /** @description Response when requesting the status of a page content export. */
    PageContentExportStatusResponse: {
      /**
       * @description The identifier of this export request.
       * @example AbCDeFGH
       */
      id: string
      /**
       * @description The status of this export.
       * @example complete
       */
      status: string
      /**
       * @description The URL that reports the status of this export.
       * @example https://coda.io/apis/v1/docs/somedoc/pages/somepage/export/some-request-id
       */
      href: string
      /**
       * @description Once the export completes, the location where the resulting export file can be downloaded; this link typically expires after a short time.  Call this method again to get a fresh link.
       * @example https://coda.io/blobs/DOC_EXPORT_RENDERING/some-request-id
       */
      downloadLink?: string
      /** @description Message describing an error, if this export failed. */
      error?: string
    }
    /**
     * @description Render mode for a page using the Embed page type.
     * @enum {string}
     */
    PageEmbedRenderMethod: 'compatibility' | 'standard'
    /**
     * @description Layout type of the table or view.
     * @enum {string}
     */
    Layout:
      | 'default'
      | 'areaChart'
      | 'barChart'
      | 'bubbleChart'
      | 'calendar'
      | 'card'
      | 'detail'
      | 'form'
      | 'ganttChart'
      | 'lineChart'
      | 'masterDetail'
      | 'pieChart'
      | 'scatterChart'
      | 'slide'
      | 'wordCloud'
    /** @description Content for a page (canvas). */
    PageContent: {
      format: components['schemas']['PageContentFormat']
      /**
       * @description The actual page content.
       * @example <p><b>This</b> is rich text</p>
       */
      content: string
    }
    /**
     * @description Supported content types for page (canvas) content.
     * @enum {string}
     */
    PageContentFormat: 'html' | 'markdown'
    /**
     * @description The type of a page in a doc.
     * @enum {string}
     */
    PageType: 'canvas' | 'embed' | 'syncPage'
    /** @description A sort applied to a table or view. */
    Sort: {
      column: components['schemas']['ColumnReference']
      direction: components['schemas']['SortDirection']
    }
    /**
     * @description Direction of a sort for a table or view.
     * @enum {string}
     */
    SortDirection: 'ascending' | 'descending'
    /**
     * @description The type of sync page in a doc
     * @enum {string}
     */
    SyncPageType: 'page' | 'document'
    /** @description Base response type for an operation that mutates a document. */
    DocumentMutateResponse: {
      /**
       * @description An arbitrary unique identifier for this request.
       * @example abc-123-def-456
       */
      requestId: string
    }
    /** @description Detail about why a particular field failed request validation. */
    ValidationError: {
      /**
       * @description A path indicating the affected field, in OGNL notation.
       * @example parent.child[0]
       */
      path: string
      /**
       * @description An error message.
       * @example Expected a string but got a number
       */
      message: string
    }
    /** @description Reference to a table or view. */
    TableReference: {
      /**
       * @description ID of the table.
       * @example grid-pqRst-U
       */
      id: string
      /**
       * @description The type of this resource.
       * @enum {string}
       */
      type: 'table'
      tableType: components['schemas']['TableType']
      /**
       * Format: url
       * @description API link to the table.
       * @example https://coda.io/apis/v1/docs/AbCDeFGH/tables/grid-pqRst-U
       */
      href: string
      /**
       * Format: url
       * @description Browser-friendly link to the table.
       * @example https://coda.io/d/_dAbCDeFGH/#Teams-and-Tasks_tpqRst-U
       */
      browserLink: string
      /**
       * @description Name of the table.
       * @example Tasks
       */
      name: string
      parent?: components['schemas']['PageReference']
    }
    /** @description Metadata about a table. */
    Table: {
      /**
       * @description ID of the table.
       * @example grid-pqRst-U
       */
      id: string
      /**
       * @description The type of this resource.
       * @enum {string}
       */
      type: 'table'
      tableType: components['schemas']['TableType']
      /**
       * Format: url
       * @description API link to the table.
       * @example https://coda.io/apis/v1/docs/AbCDeFGH/tables/grid-pqRst-U
       */
      href: string
      /**
       * Format: url
       * @description Browser-friendly link to the table.
       * @example https://coda.io/d/_dAbCDeFGH/#Teams-and-Tasks_tpqRst-U
       */
      browserLink: string
      /**
       * @description Name of the table.
       * @example Tasks
       */
      name: string
      parent: components['schemas']['PageReference']
      parentTable?: components['schemas']['TableReference']
      displayColumn: components['schemas']['ColumnReference']
      /**
       * @description Total number of rows in the table.
       * @example 130
       */
      rowCount: number
      /** @description Any sorts applied to the table. */
      sorts: components['schemas']['Sort'][]
      layout: components['schemas']['Layout']
      filter?: components['schemas']['FormulaDetail']
      /**
       * Format: date-time
       * @description Timestamp for when the table was created.
       * @example 2018-04-11T00:18:57.946Z
       */
      createdAt: string
      /**
       * Format: date-time
       * @description Timestamp for when the table was last modified.
       * @example 2018-04-11T00:18:57.946Z
       */
      updatedAt: string
    }
    /** @description List of tables. */
    TableList: {
      items: components['schemas']['TableReference'][]
      /**
       * Format: url
       * @description API link to these results
       * @example https://coda.io/apis/v1/docs/AbCDeFGH/tables?limit=20
       */
      href?: string
      nextPageToken?: components['schemas']['nextPageToken']
      nextPageLink?: components['schemas']['nextPageLink'] & string
    }
    /** @description Reference to a column. */
    ColumnReference: {
      /**
       * @description ID of the column.
       * @example c-tuVwxYz
       */
      id: string
      /**
       * @description The type of this resource.
       * @enum {string}
       */
      type: 'column'
      /**
       * Format: url
       * @description API link to the column.
       * @example https://coda.io/apis/v1/docs/AbCDeFGH/tables/grid-pqRst-U/columns/c-tuVwxYz
       */
      href: string
    }
    /** @description Info about a column. */
    Column: {
      /**
       * @description ID of the column.
       * @example c-tuVwxYz
       */
      id: string
      /**
       * @description The type of this resource.
       * @enum {string}
       */
      type: 'column'
      /**
       * Format: url
       * @description API link to the column.
       * @example https://coda.io/apis/v1/docs/AbCDeFGH/tables/grid-pqRst-U/columns/c-tuVwxYz
       */
      href: string
      /**
       * @description Name of the column.
       * @example Completed
       */
      name: string
      /**
       * @description Whether the column is the display column.
       * @example true
       */
      display?: boolean
      /**
       * @description Whether the column has a formula set on it.
       * @example true
       */
      calculated?: boolean
      /**
       * @description Formula on the column.
       * @example thisRow.Created()
       */
      formula?: string
      /**
       * @description Default value formula for the column.
       * @example Test
       */
      defaultValue?: string
      format: components['schemas']['ColumnFormat']
    }
    /** @description Info about a column. */
    ColumnDetail: {
      /**
       * @description ID of the column.
       * @example c-tuVwxYz
       */
      id: string
      /**
       * @description The type of this resource.
       * @enum {string}
       */
      type: 'column'
      /**
       * Format: url
       * @description API link to the column.
       * @example https://coda.io/apis/v1/docs/AbCDeFGH/tables/grid-pqRst-U/columns/c-tuVwxYz
       */
      href: string
      /**
       * @description Name of the column.
       * @example Completed
       */
      name: string
      /**
       * @description Whether the column is the display column.
       * @example true
       */
      display?: boolean
      /**
       * @description Whether the column has a formula set on it.
       * @example true
       */
      calculated?: boolean
      /**
       * @description Formula on the column.
       * @example thisRow.Created()
       */
      formula?: string
      /**
       * @description Default value formula for the column.
       * @example Test
       */
      defaultValue?: string
      format: components['schemas']['ColumnFormat']
      parent: components['schemas']['TableReference']
    }
    /** @description Format of a simple column. */
    SimpleColumnFormat: {
      type: components['schemas']['ColumnFormatType']
      /**
       * @description Whether or not this column is an array.
       * @example true
       */
      isArray: boolean
    }
    /** @description Format of a column that refers to another table. */
    ReferenceColumnFormat: components['schemas']['SimpleColumnFormat'] & {
      table: components['schemas']['TableReference']
    }
    /** @description Format of a numeric column. */
    NumericColumnFormat: components['schemas']['SimpleColumnFormat'] & {
      /**
       * @description The decimal precision.
       * @example 2
       */
      precision?: number
      /**
       * @description Whether to use a thousands separator (like ",") to format the numeric value.
       * @example true
       */
      useThousandsSeparator?: boolean
    }
    /** @description Format of a currency column. */
    CurrencyColumnFormat: components['schemas']['SimpleColumnFormat'] & {
      /**
       * @description The currency symbol
       * @example $
       */
      currencyCode?: string
      /**
       * @description The decimal precision.
       * @example 2
       */
      precision?: number
      format?: components['schemas']['CurrencyFormatType']
    }
    /**
     * @description How the numeric value should be formatted (with or without symbol, negative numbers in parens).
     * @enum {string}
     */
    CurrencyFormatType: 'currency' | 'accounting' | 'financial'
    /** @description Format of a date column. */
    DateColumnFormat: components['schemas']['SimpleColumnFormat'] & {
      /**
       * @description A format string using Moment syntax: https://momentjs.com/docs/#/displaying/
       * @example YYYY-MM-DD
       */
      format?: string
    }
    /** @description Format of an email column. */
    EmailColumnFormat: components['schemas']['SimpleColumnFormat'] & {
      display?: components['schemas']['EmailDisplayType']
      autocomplete?: boolean
    }
    /**
     * @description How an email address should be displayed in the user interface.
     * @enum {string}
     */
    EmailDisplayType: 'iconAndEmail' | 'iconOnly' | 'emailOnly'
    /** @description Format of an image reference column. */
    ImageReferenceColumnFormat: components['schemas']['SimpleColumnFormat'] & {
      width: components['schemas']['NumberOrNumberFormula']
      height: components['schemas']['NumberOrNumberFormula']
      style: components['schemas']['ImageShapeStyle']
    }
    /**
     * @description How an image should be displayed.
     * @enum {string}
     */
    ImageShapeStyle: 'auto' | 'circle'
    /** @description Format of a link column. */
    LinkColumnFormat: components['schemas']['SimpleColumnFormat'] & {
      display?: components['schemas']['LinkDisplayType']
      /**
       * @description Force embeds to render on the client instead of the server (for sites that require user login).
       * @example true
       */
      force?: boolean
    }
    /**
     * @description How a link should be displayed in the user interface.
     * @enum {string}
     */
    LinkDisplayType: 'iconOnly' | 'url' | 'title' | 'card' | 'embed'
    /** @description Format of a time column. */
    TimeColumnFormat: components['schemas']['SimpleColumnFormat'] & {
      /**
       * @description A format string using Moment syntax: https://momentjs.com/docs/#/displaying/
       * @example h:mm:ss A
       */
      format?: string
    }
    /** @description Format of a date column. */
    DateTimeColumnFormat: components['schemas']['SimpleColumnFormat'] & {
      /**
       * @description A format string using Moment syntax: https://momentjs.com/docs/#/displaying/
       * @example YYYY-MM-DD
       */
      dateFormat?: string
      /**
       * @description A format string using Moment syntax: https://momentjs.com/docs/#/displaying/
       * @example h:mm:ss A
       */
      timeFormat?: string
    }
    /** @description Format of a duration column. */
    DurationColumnFormat: components['schemas']['SimpleColumnFormat'] & {
      /** @example 2 */
      precision?: number
      maxUnit?: components['schemas']['DurationUnit']
    }
    /**
     * @description A time unit used as part of a duration value.
     * @enum {string}
     */
    DurationUnit: 'days' | 'hours' | 'minutes' | 'seconds'
    /** @description A number or a string representing a formula that evaluates to a number. */
    NumberOrNumberFormula: number | string
    /** @description Format of a numeric column that renders as a slider. */
    SliderColumnFormat: components['schemas']['SimpleColumnFormat'] & {
      minimum?: components['schemas']['NumberOrNumberFormula']
      maximum?: components['schemas']['NumberOrNumberFormula']
      step?: components['schemas']['NumberOrNumberFormula']
      displayType?: components['schemas']['SliderDisplayType']
      /**
       * @description Whether the underyling numeric value is also displayed.
       * @example true
       */
      showValue?: boolean
    }
    /** @description Format of a button column. */
    ButtonColumnFormat: components['schemas']['SimpleColumnFormat'] & {
      /**
       * @description Label formula for the button.
       * @example Click me
       */
      label?: string
      /**
       * @description DisableIf formula for the button.
       * @example False()
       */
      disableIf?: string
      /**
       * @description Action formula for the button.
       * @example OpenUrl("www.google.com")
       */
      action?: string
    }
    /**
     * @description List of available icon sets.
     * @enum {string}
     */
    IconSet:
      | 'star'
      | 'circle'
      | 'fire'
      | 'bug'
      | 'diamond'
      | 'bell'
      | 'thumbsup'
      | 'heart'
      | 'chili'
      | 'smiley'
      | 'lightning'
      | 'currency'
      | 'coffee'
      | 'person'
      | 'battery'
      | 'cocktail'
      | 'cloud'
      | 'sun'
      | 'checkmark'
      | 'lightbulb'
    /** @description Format of a numeric column that renders as a scale, like star ratings. */
    ScaleColumnFormat: components['schemas']['SimpleColumnFormat'] & {
      /**
       * @description The maximum number allowed for this scale.
       * @example 5
       */
      maximum: number
      icon: components['schemas']['IconSet']
    }
    /** @description Format of a select column. */
    SelectColumnFormat: components['schemas']['SimpleColumnFormat'] &
      Record<string, never>
    /** @description An option for a select column. */
    SelectOption: {
      /**
       * @description The name of the option.
       * @example Option 1
       */
      name: string
      /**
       * @description The background color of the option.
       * @example #ff0000
       */
      backgroundColor?: string
      /**
       * @description The foreground color of the option.
       * @example #ffffff
       */
      foregroundColor?: string
    }
    /**
     * @description How the slider should be rendered.
     * @enum {string}
     */
    SliderDisplayType: 'slider' | 'progress'
    /** @description Format of a checkbox column. */
    CheckboxColumnFormat: components['schemas']['SimpleColumnFormat'] & {
      displayType: components['schemas']['CheckboxDisplayType']
    }
    /**
     * @description How a checkbox should be displayed.
     * @enum {string}
     */
    CheckboxDisplayType: 'toggle' | 'check'
    /** @description Format of a column. */
    ColumnFormat:
      | components['schemas']['ButtonColumnFormat']
      | components['schemas']['CheckboxColumnFormat']
      | components['schemas']['DateColumnFormat']
      | components['schemas']['DateTimeColumnFormat']
      | components['schemas']['DurationColumnFormat']
      | components['schemas']['EmailColumnFormat']
      | components['schemas']['LinkColumnFormat']
      | components['schemas']['CurrencyColumnFormat']
      | components['schemas']['ImageReferenceColumnFormat']
      | components['schemas']['NumericColumnFormat']
      | components['schemas']['ReferenceColumnFormat']
      | components['schemas']['SelectColumnFormat']
      | components['schemas']['SimpleColumnFormat']
      | components['schemas']['ScaleColumnFormat']
      | components['schemas']['SliderColumnFormat']
      | components['schemas']['TimeColumnFormat']
    /**
     * @description Format type of the column
     * @enum {string}
     */
    ColumnFormatType:
      | 'text'
      | 'person'
      | 'lookup'
      | 'number'
      | 'percent'
      | 'currency'
      | 'date'
      | 'dateTime'
      | 'time'
      | 'duration'
      | 'email'
      | 'link'
      | 'slider'
      | 'scale'
      | 'image'
      | 'imageReference'
      | 'attachments'
      | 'button'
      | 'checkbox'
      | 'select'
      | 'packObject'
      | 'reaction'
      | 'canvas'
      | 'other'
    /** @description List of columns. */
    ColumnList: {
      items: components['schemas']['Column'][]
      /**
       * Format: url
       * @description API link to these results
       * @example https://coda.io/apis/v1/docs/AbCDeFGH/tables/grid-pqRst-U/columns?limit=20
       */
      href?: string
      nextPageToken?: components['schemas']['nextPageToken']
      nextPageLink?: components['schemas']['nextPageLink'] & string
    }
    /** @description Info about a row. */
    Row: {
      /**
       * @description ID of the row.
       * @example i-tuVwxYz
       */
      id: string
      /**
       * @description The type of this resource.
       * @enum {string}
       */
      type: 'row'
      /**
       * Format: url
       * @description API link to the row.
       * @example https://coda.io/apis/v1/docs/AbCDeFGH/tables/grid-pqRst-U/rows/i-RstUv-W
       */
      href: string
      /**
       * @description The display name of the row, based on its identifying column.
       * @example Apple
       */
      name: string
      /**
       * @description Index of the row within the table.
       * @example 7
       */
      index: number
      /**
       * Format: url
       * @description Browser-friendly link to the row.
       * @example https://coda.io/d/_dAbCDeFGH#Teams-and-Tasks_tpqRst-U/_rui-tuVwxYz
       */
      browserLink: string
      /**
       * Format: date-time
       * @description Timestamp for when the row was created.
       * @example 2018-04-11T00:18:57.946Z
       */
      createdAt: string
      /**
       * Format: date-time
       * @description Timestamp for when the row was last modified.
       * @example 2018-04-11T00:18:57.946Z
       */
      updatedAt: string
      /**
       * @description Values for a specific row, represented as a hash of column IDs (or names with `useColumnNames`) to values.
       *
       * @example {
       *   "c-tuVwxYz": "Apple",
       *   "c-bCdeFgh": [
       *     "$12.34",
       *     "$56.78"
       *   ]
       * }
       */
      values: {
        [key: string]: components['schemas']['CellValue']
      }
    }
    /** @description Details about a row. */
    RowDetail: {
      /**
       * @description ID of the row.
       * @example i-tuVwxYz
       */
      id: string
      /**
       * @description The type of this resource.
       * @enum {string}
       */
      type: 'row'
      /**
       * Format: url
       * @description API link to the row.
       * @example https://coda.io/apis/v1/docs/AbCDeFGH/tables/grid-pqRst-U/rows/i-RstUv-W
       */
      href: string
      /**
       * @description The display name of the row, based on its identifying column.
       * @example Apple
       */
      name: string
      /**
       * @description Index of the row within the table.
       * @example 7
       */
      index: number
      /**
       * Format: url
       * @description Browser-friendly link to the row.
       * @example https://coda.io/d/_dAbCDeFGH#Teams-and-Tasks_tpqRst-U/_rui-tuVwxYz
       */
      browserLink: string
      /**
       * Format: date-time
       * @description Timestamp for when the row was created.
       * @example 2018-04-11T00:18:57.946Z
       */
      createdAt: string
      /**
       * Format: date-time
       * @description Timestamp for when the row was last modified.
       * @example 2018-04-11T00:18:57.946Z
       */
      updatedAt: string
      /**
       * @description Values for a specific row, represented as a hash of column IDs (or names with `useColumnNames`) to values.
       *
       * @example {
       *   "c-tuVwxYz": "Apple",
       *   "c-bCdeFgh": [
       *     "$12.34",
       *     "$56.78"
       *   ]
       * }
       */
      values: {
        [key: string]: components['schemas']['CellValue']
      }
      parent: components['schemas']['TableReference']
    }
    /** @description List of rows. */
    RowList: {
      items: components['schemas']['Row'][]
      /**
       * Format: url
       * @description API link to these results
       * @example https://coda.io/apis/v1/docs/AbCDeFGH/tables/grid-pqRst-U/rows?limit=20
       */
      href?: string
      nextPageToken?: components['schemas']['nextPageToken']
      nextPageLink?: components['schemas']['nextPageLink'] & string
      nextSyncToken?: components['schemas']['nextSyncToken']
    }
    /** @description A Coda result or entity expressed as a primitive type. */
    ScalarValue: string | number | boolean
    /** @description A Coda result or entity expressed as a primitive type, or array of primitive types. */
    Value:
      | components['schemas']['ScalarValue']
      | (
          | components['schemas']['ScalarValue']
          | components['schemas']['ScalarValue'][]
        )[]
    /** @description A value that contains rich structured data. Cell values are composed of these values or arrays of these values. */
    RichSingleValue:
      | components['schemas']['ScalarValue']
      | components['schemas']['CurrencyValue']
      | components['schemas']['ImageUrlValue']
      | components['schemas']['PersonValue']
      | components['schemas']['UrlValue']
      | components['schemas']['RowValue']
    /** @description A cell value that contains rich structured data. */
    RichValue:
      | components['schemas']['RichSingleValue']
      | (
          | components['schemas']['RichSingleValue']
          | components['schemas']['RichSingleValue'][]
        )[]
    /** @description A value representing a Coda row. */
    RowValue: components['schemas']['LinkedDataObject'] & {
      /**
       * @description The display name of the row, based on its identifying column.
       * @example Apple
       */
      name: string
      /**
       * @description The url of the row.
       * @example https://coda.io/d/_dAbCDeFGH#Teams-and-Tasks_tpqRst-U/_rui-tuVwxYz
       */
      url: string
      /**
       * @description The ID of the table
       * @example grid-pqRst-U
       */
      tableId: string
      /**
       * @description The ID of the table
       * @example i-tuVwxYz
       */
      rowId: string
      /**
       * @description The url of the table.
       * @example https://coda.io/d/_dAbCDeFGH#Teams-and-Tasks_tpqRst-U
       */
      tableUrl: string
      /**
       * @description The type of this resource.
       * @enum {string}
       */
      additionalType: 'row'
    }
    /** @description Base type for a JSON-LD (Linked Data) object. */
    LinkedDataObject: {
      /**
       * @description A url describing the schema context for this object, typically "http://schema.org/".
       * @example http://schema.org/
       */
      '@context': string
      '@type': components['schemas']['LinkedDataType']
      /** @description An identifier of additional type info specific to Coda that may not be present in a schema.org taxonomy, */
      additionalType?: string
    }
    /**
     * @description A schema.org identifier for the object.
     * @enum {string}
     */
    LinkedDataType:
      | 'ImageObject'
      | 'MonetaryAmount'
      | 'Person'
      | 'WebPage'
      | 'StructuredValue'
    /** @description A named hyperlink to an arbitrary url. */
    UrlValue: components['schemas']['LinkedDataObject'] & {
      /**
       * @description The user-visible text of the hyperlink.
       * @example Click me
       */
      name?: string
      /**
       * @description The url of the hyperlink.
       * @example https://coda.io
       */
      url: string
    }
    /** @description A named url of an image along with metadata. */
    ImageUrlValue: components['schemas']['LinkedDataObject'] & {
      /**
       * @description The name of the image.
       * @example Dogs Playing Poker
       */
      name?: string
      /**
       * @description The url of the image.
       * @example https://example.com/dogs-playing-poker.jpg
       */
      url?: string
      /**
       * @description The height of the image in pixels.
       * @example 480
       */
      height?: number
      /**
       * @description The width of the image in pixels.
       * @example 640
       */
      width?: number
      status?: components['schemas']['ImageStatus']
    }
    /**
     * @description The status values that an image object can have.
     * @enum {string}
     */
    ImageStatus: 'live' | 'deleted' | 'failed'
    /** @description A named reference to a person, where the person is identified by email address. */
    PersonValue: components['schemas']['LinkedDataObject'] & {
      /**
       * @description The full name of the person.
       * @example Alice Atkins
       */
      name: string
      /**
       * @description The email address of the person.
       * @example alice@atkins.com
       */
      email: string
    }
    /** @description A numeric monetary amount as a string or number. */
    CurrencyAmount: string | number
    /** @description A monetary value with its associated currency code. */
    CurrencyValue: components['schemas']['LinkedDataObject'] & {
      /**
       * @description The 3-letter currency code.
       * @example USD
       */
      currency: string
      amount: components['schemas']['CurrencyAmount']
    }
    /** @description All values that a row cell can contain. */
    CellValue:
      | components['schemas']['Value']
      | components['schemas']['RichValue']
    /** @description An edit made to a particular cell in a row. */
    CellEdit: {
      /**
       * @description Column ID, URL, or name (fragile and discouraged) associated with this edit.
       * @example c-tuVwxYz
       */
      column: string
      value: components['schemas']['Value']
    }
    /** @description The result of a push button. */
    PushButtonResult: components['schemas']['DocumentMutateResponse'] & {
      /**
       * @description ID of the row where the button exists.
       * @example i-tuVwxYz
       */
      rowId: string
      /**
       * @description ID of the column where the button exists.
       * @example i-tuVwxYz
       */
      columnId: string
    }
    /** @description An edit made to a particular row. */
    RowEdit: {
      cells: components['schemas']['CellEdit'][]
    }
    /** @description Payload for updating a row in a table. */
    RowUpdate: {
      row: components['schemas']['RowEdit']
    }
    /** @description The result of a row update. */
    RowUpdateResult: components['schemas']['DocumentMutateResponse'] & {
      /**
       * @description ID of the updated row.
       * @example i-tuVwxYz
       */
      id: string
    }
    /** @description Payload for deleting rows from a table. */
    RowsDelete: {
      /**
       * @description Row IDs to delete.
       *
       * @example [
       *   "i-bCdeFgh",
       *   "i-CdEfgHi"
       * ]
       */
      rowIds: string[]
    }
    /** @description The result of a rows delete operation. */
    RowsDeleteResult: components['schemas']['DocumentMutateResponse'] & {
      /**
       * @description Row IDs to delete.
       * @example [
       *   "i-bCdeFgh",
       *   "i-CdEfgHi"
       * ]
       */
      rowIds: string[]
    }
    /** @description Payload for upserting rows in a table. */
    RowsUpsert: {
      rows: components['schemas']['RowEdit'][]
      /**
       * @description Optional column IDs, URLs, or names (fragile and discouraged), specifying columns to be used as upsert keys.
       * @example [
       *   "c-bCdeFgh"
       * ]
       */
      keyColumns?: string[]
    }
    /** @description The result of a rows insert/upsert operation. */
    RowsUpsertResult: components['schemas']['DocumentMutateResponse'] & {
      /**
       * @description Row IDs for rows that will be added. Only applicable when keyColumns is not set or empty.
       * @example [
       *   "i-bCdeFgh",
       *   "i-CdEfgHi"
       * ]
       */
      addedRowIds?: string[]
    }
    /** @description The result of a row deletion. */
    RowDeleteResult: components['schemas']['DocumentMutateResponse'] & {
      /**
       * @description ID of the row to be deleted.
       * @example i-tuVwxYz
       */
      id: string
    }
    /**
     * @description Determines how the rows returned are sorted
     * @enum {string}
     */
    RowsSortBy: 'createdAt' | 'natural' | 'updatedAt'
    /**
     * @description The format that cell values are returned as.
     * @enum {string}
     */
    ValueFormat: 'simple' | 'simpleWithArrays' | 'rich'
    /** @description Reference to a formula. */
    FormulaReference: {
      /**
       * @description ID of the formula.
       * @example f-fgHijkLm
       */
      id: string
      /**
       * @description The type of this resource.
       * @enum {string}
       */
      type: 'formula'
      /**
       * Format: url
       * @description API link to the formula.
       * @example https://coda.io/apis/v1/docs/AbCDeFGH/formulas/f-fgHijkLm
       */
      href: string
      /**
       * @description Name of the formula.
       * @example Sum of expenses
       */
      name: string
      parent?: components['schemas']['PageReference']
    }
    /** @description Details about a formula. */
    Formula: {
      /**
       * @description ID of the formula.
       * @example f-fgHijkLm
       */
      id: string
      /**
       * @description The type of this resource.
       * @enum {string}
       */
      type: 'formula'
      /**
       * Format: url
       * @description API link to the formula.
       * @example https://coda.io/apis/v1/docs/AbCDeFGH/formulas/f-fgHijkLm
       */
      href: string
      /**
       * @description Name of the formula.
       * @example Sum of expenses
       */
      name: string
      parent?: components['schemas']['PageReference']
      value: components['schemas']['Value']
    }
    /** @description List of formulas. */
    FormulaList: {
      items: components['schemas']['FormulaReference'][]
      /**
       * Format: url
       * @description API link to these results
       * @example https://coda.io/apis/v1/docs/AbCDeFGH/formulas?limit=20
       */
      href?: string
      nextPageToken?: components['schemas']['nextPageToken']
      nextPageLink?: components['schemas']['nextPageLink'] & string
    }
    /** @description Reference to a control. */
    ControlReference: {
      /**
       * @description ID of the control.
       * @example ctrl-cDefGhij
       */
      id: string
      /**
       * @description The type of this resource.
       * @enum {string}
       */
      type: 'control'
      /**
       * Format: url
       * @description API link to the control.
       * @example https://coda.io/apis/v1/docs/AbCDeFGH/controls/ctrl-cDefGhij
       */
      href: string
      /**
       * @description Name of the control.
       * @example Cost
       */
      name: string
      parent?: components['schemas']['PageReference']
    }
    /** @description Details about a control. */
    Control: {
      /**
       * @description ID of the control.
       * @example ctrl-cDefGhij
       */
      id: string
      /**
       * @description The type of this resource.
       * @enum {string}
       */
      type: 'control'
      /**
       * Format: url
       * @description API link to the control.
       * @example https://coda.io/apis/v1/docs/AbCDeFGH/controls/ctrl-cDefGhij
       */
      href: string
      /**
       * @description Name of the control.
       * @example Cost
       */
      name: string
      parent?: components['schemas']['PageReference']
      controlType: components['schemas']['ControlType']
      value: components['schemas']['Value']
    }
    /** @description List of controls. */
    ControlList: {
      items: components['schemas']['ControlReference'][]
      /**
       * Format: url
       * @description API link to these results
       * @example https://coda.io/apis/v1/docs/AbCDeFGH/controls?limit=20
       */
      href?: string
      nextPageToken?: components['schemas']['nextPageToken']
      nextPageLink?: components['schemas']['nextPageLink'] & string
    }
    /**
     * @description Type of the control.
     * @example slider
     * @enum {string}
     */
    ControlType:
      | 'button'
      | 'checkbox'
      | 'datePicker'
      | 'dateRangePicker'
      | 'dateTimePicker'
      | 'lookup'
      | 'multiselect'
      | 'select'
      | 'scale'
      | 'slider'
      | 'reaction'
      | 'textbox'
      | 'timePicker'
    /** @description Info about the user. */
    User: {
      /**
       * @description Name of the user.
       * @example John Doe
       */
      name: string
      /**
       * @description Email address of the user.
       * @example user@example.com
       */
      loginId: string
      /**
       * @description The type of this resource.
       * @enum {string}
       */
      type: 'user'
      /**
       * Format: url
       * @description Browser-friendly link to the user's avatar image.
       * @example https://cdn.coda.io/avatars/default_avatar.png
       */
      pictureLink?: string
      /**
       * @description True if the token used to make this request has restricted/scoped access to the API.
       * @example false
       */
      scoped: boolean
      /**
       * @description Returns the name of the token used for this request.
       * @example My API token
       */
      tokenName: string
      /**
       * Format: url
       * @description API link to the user.
       * @example https://coda.io/apis/v1beta/whoami
       */
      href: string
      workspace: components['schemas']['WorkspaceReference']
    }
    /** @description Summary about the user. */
    UserSummary: {
      /**
       * @description Name of the user.
       * @example John Doe
       */
      name: string
      /**
       * @description Email address of the user.
       * @example user@example.com
       */
      loginId: string
      /**
       * @description The type of this resource.
       * @enum {string}
       */
      type: 'user'
      /**
       * Format: url
       * @description Browser-friendly link to the user's avatar image.
       * @example https://cdn.coda.io/avatars/default_avatar.png
       */
      pictureLink?: string
    }
    /**
     * @description If specified, an opaque token used to fetch the next page of results.
     * @example eyJsaW1pd
     */
    nextPageToken: string
    /**
     * Format: url
     * @description If specified, a link that can be used to fetch the next page of results.
     */
    nextPageLink: string
    /**
     * @description If specified, an opaque token that can be passed back later to retrieve new results that match the parameters specified when the sync token was created.
     *
     * @example eyJsaW1pd
     */
    nextSyncToken: string
    /** @description Info about a publishing category */
    PublishingCategory: {
      /**
       * @description The ID for this category.
       * @example aBCdEFg
       */
      categoryId: string
      /**
       * @description The name of the category.
       * @example Project management
       */
      categoryName: string
      /**
       * @description The URL identifier of the category.
       * @example project-management
       */
      categorySlug?: string
    }
    /** @description Info about the maker */
    Maker: {
      /**
       * @description Name of the maker.
       * @example John Doe
       */
      name: string
      /**
       * Format: url
       * @description Browser-friendly link to the maker's avatar image.
       * @example https://cdn.coda.io/avatars/default_avatar.png
       */
      pictureLink?: string
      /** @description Maker profile identifier for the maker. */
      slug?: string
      /** @description Job title for maker. */
      jobTitle?: string
      /** @description Employer for maker. */
      employer?: string
      /** @description Description for the maker. */
      description?: string
      /**
       * @description Email address of the user.
       * @example user@example.com
       */
      loginId: string
    }
    /** @description Summary about a maker */
    MakerSummary: {
      /**
       * @description Name of the maker.
       * @example John Doe
       */
      name: string
      /**
       * Format: url
       * @description Browser-friendly link to the maker's avatar image.
       * @example https://cdn.coda.io/avatars/default_avatar.png
       */
      pictureLink?: string
      /** @description Maker profile identifier for the maker. */
      slug?: string
      /** @description Job title for maker. */
      jobTitle?: string
      /** @description Employer for maker. */
      employer?: string
      /** @description Description for the maker. */
      description?: string
    }
    /** @description Info about a resolved link to an API resource. */
    ApiLink: {
      /**
       * @description The type of this resource.
       * @enum {string}
       */
      type: 'apiLink'
      /**
       * Format: url
       * @description Self link to this query.
       * @example https://coda.io/apis/v1/resolveBrowserLink?url=https%3A%2F%2Fcoda.io%2Fd%2F_dAbCDeFGH%2FLaunch-Status_sumnO
       */
      href: string
      /**
       * Format: url
       * @description Canonical browser-friendly link to the resolved resource.
       * @example https://coda.io/d/_dAbCDeFGH/Launch-Status_sumnO
       */
      browserLink?: string
      resource: components['schemas']['ApiLinkResolvedResource']
    }
    /** @description Reference to the resolved resource. */
    ApiLinkResolvedResource: {
      type: components['schemas']['Type']
      /**
       * @description ID of the resolved resource.
       * @example canvas-IjkLmnO
       */
      id: string
      /**
       * @description Name of the resource.
       * @example My Page
       */
      name?: string
      /**
       * Format: url
       * @description API link to the resolved resource that can be queried to get further information.
       * @example https://coda.io/apis/v1/docs/AbCDeFGH/pages/canvas-IjkLmnO
       */
      href: string
    }
    /** @description Info about the icon. */
    Icon: {
      /** @description Name of the icon. */
      name: string
      /** @description MIME type of the icon */
      type: string
      /**
       * Format: url
       * @description Browser-friendly link to an icon.
       * @example https://cdn.coda.io/icons/png/color/icon-32.png
       */
      browserLink: string
    }
    /** @description Info about the image. */
    Image: {
      /**
       * Format: url
       * @description Browser-friendly link to an image.
       * @example https://codahosted.io/docs/nUYhlXysYO/blobs/bl-lYkYKNzkuT/3f879b9ecfa27448
       */
      browserLink: string
      /** @description MIME type of the image. */
      type?: string
      /**
       * @description The width in pixels of the image.
       * @example 800
       */
      width?: number
      /**
       * @description The height in pixels of the image.
       * @example 600
       */
      height?: number
    }
    /**
     * @description Determines how the objects returned are sorted
     * @enum {string}
     */
    SortBy: 'name'
    /** @enum {string} */
    TableType: 'table' | 'view'
    /** @description Detailed information about a formula. */
    FormulaDetail: {
      /**
       * @description Returns whether or not the given formula is valid.
       * @example true
       */
      valid: boolean
      /**
       * @description Returns whether or not the given formula can return different results in different contexts (for example, for different users).
       *
       * @example false
       */
      isVolatile?: boolean
      /**
       * @description Returns whether or not the given formula has a User() formula within it.
       * @example false
       */
      hasUserFormula?: boolean
      /**
       * @description Returns whether or not the given formula has a Today() formula within it.
       * @example false
       */
      hasTodayFormula?: boolean
      /**
       * @description Returns whether or not the given formula has a Now() formula within it.
       * @example false
       */
      hasNowFormula?: boolean
    }
    /** @description The status of an asynchronous mutation. */
    MutationStatus: {
      /**
       * @description Returns whether the mutation has completed.
       * @example true
       */
      completed: boolean
      /**
       * @description A warning if the mutation completed but with caveats.
       * @example Initial page HTML was invalid.
       */
      warning?: string
    }
    /**
     * @description Payload for webhook trigger
     * @example {
     *   "message": "The doc that brings words, data, & teams together."
     * }
     */
    WebhookTriggerPayload: {
      [key: string]: unknown
    }
    /** @description The result of triggering a webhook */
    WebhookTriggerResult: components['schemas']['DocumentMutateResponse'] &
      Record<string, never>
    /** @description Reference to a Coda folder. */
    FolderReference: {
      /**
       * @description ID of the Coda folder.
       * @example fl-1Ab234
       */
      id: string
      /**
       * @description The type of this resource.
       * @enum {string}
       */
      type: 'folder'
      /**
       * Format: url
       * @description Browser-friendly link to the folder.
       * @example https://coda.io/docs?folderId=fl-1Ab234
       */
      browserLink: string
      /**
       * @description Name of the folder; included if the user has access to the folder.
       * @example My docs
       */
      name?: string
    }
    /** @description Reference to a Coda workspace. */
    WorkspaceReference: {
      /**
       * @description ID of the Coda workspace.
       * @example ws-1Ab234
       */
      id: string
      /**
       * @description The type of this resource.
       * @enum {string}
       */
      type: 'workspace'
      /**
       * @description ID of the organization bound to this workspace, if any.
       * @example org-2Bc456
       */
      organizationId?: string
      /**
       * Format: url
       * @description Browser-friendly link to the Coda workspace.
       * @example https://coda.io/docs?workspaceId=ws-1Ab234
       */
      browserLink: string
      /**
       * @description Name of the workspace; included if the user has access to the workspace.
       * @example My workspace
       */
      name?: string
    }
    /** @description Metadata about a Coda workspace. */
    Workspace: {
      /**
       * @description ID of the Coda workspace.
       * @example ws-1Ab234
       */
      id: string
      /**
       * @description The type of this resource.
       * @enum {string}
       */
      type: 'workspace'
      /**
       * @description ID of the organization bound to this workspace, if any.
       * @example org-2Bc456
       */
      organizationId?: string
      /**
       * Format: url
       * @description Browser-friendly link to the Coda workspace.
       * @example https://coda.io/docs?workspaceId=ws-1Ab234
       */
      browserLink: string
      /**
       * @description Name of the workspace.
       * @example coda.io
       */
      name: string
      /**
       * @description Description of the workspace.
       * @example The central place for our team's knowledge.
       */
      description?: string
    }
    /** @description Metadata of a workspace user. */
    WorkspaceUser: {
      /**
       * @description Email of the user.
       * @example hello@coda.io
       */
      email: string
      /**
       * @description Name of the user.
       * @example Sally Jane
       */
      name: string
      role: components['schemas']['WorkspaceUserRole']
      /**
       * Format: url
       * @description Picture url of the user.
       * @example codahosted.io/123
       */
      pictureUrl?: string
      /**
       * Format: date-time
       * @description Timestamp for when the user registered in this workspace
       * @example 2018-04-11T00:18:57.946Z
       */
      registeredAt: string
      /**
       * Format: date-time
       * @description Timestamp for when the user's role last changed in this workspace.
       * @example 2018-04-11T00:18:57.946Z
       */
      roleChangedAt?: string
      /**
       * Format: date
       * @description Date when the user last took an action in any workspace.
       * @example 2018-04-11
       */
      lastActiveAt?: string
      /**
       * @description Number of docs the user owns in this workspace.
       * @example 2
       */
      ownedDocs?: number
      /**
       * Format: date
       * @description Date when anyone last accessed a doc that the user owns in this workspace.
       * @example 2018-04-11
       */
      docsLastActiveAt?: string
      /**
       * @description Number of collaborators that have interacted with docs owned by the user in the last 90 days.
       * @example 2
       */
      docCollaboratorCount?: number
      /**
       * @description Number of docs the user owns, manages, or to which they have added pages in the last 90 days.
       * @example 2
       */
      totalDocs?: number
      /**
       * Format: date
       * @description Date when anyone last accessed a doc the member owns or contributed to.
       * @example 2018-04-11
       */
      totalDocsLastActiveAt?: string
      /**
       * @description Number of unique users that have viewed any doc the user owns, manages, or has added pages to in the last 90 days.
       * @example 2
       */
      totalDocCollaboratorsLast90Days?: number
    }
    /** @enum {string} */
    WorkspaceUserRole: 'Admin' | 'DocMaker' | 'Editor'
    /** @description Metadata for workspace role activity. */
    WorkspaceRoleActivity: {
      /**
       * @description Month corresponding to the data.
       * @example 2020-09-15
       */
      month: string
      /**
       * @description Number of active Admins.
       * @example 2
       */
      activeAdminCount: number
      /**
       * @description Number of active Doc Makers.
       * @example 2
       */
      activeDocMakerCount: number
      /**
       * @description Number of active Editors.
       * @example 2
       */
      activeEditorCount: number
      /**
       * @description Number of inactive Admins.
       * @example 2
       */
      inactiveAdminCount: number
      /**
       * @description Number of inactive Doc Makers.
       * @example 2
       */
      inactiveDocMakerCount: number
      /**
       * @description Number of inactive Editor users.
       * @example 2
       */
      inactiveEditorCount: number
    }
    /** @description Response for listing workspace users. */
    WorkspaceMembersList: {
      items: components['schemas']['WorkspaceUser'][]
      nextPageToken?: components['schemas']['nextPageToken']
      nextPageLink?: components['schemas']['nextPageLink'] & string
    }
    /** @description Response for getting workspace role activity. */
    GetWorkspaceRoleActivity: {
      items: components['schemas']['WorkspaceRoleActivity'][]
    }
    /** @description Parameters for changing a workspace user role. */
    ChangeRole: {
      /**
       * @description Email of the user.
       * @example hello@coda.io
       */
      email: string
      newRole: components['schemas']['WorkspaceUserRole']
    }
    /** @description The result of changing a user's workspace user role. */
    ChangeRoleResult: {
      /**
       * Format: date-time
       * @description Timestamp for when the user's role last changed in this workspace.
       * @example 2018-04-11T00:18:57.946Z
       */
      roleChangedAt: string
    }
    /** @description Analytics data for a Coda doc. */
    DocAnalyticsItem: {
      doc: components['schemas']['DocAnalyticsDetails']
      metrics: components['schemas']['DocAnalyticsMetrics'][]
    }
    /** @description List of analytics for Coda docs over a date range. */
    DocAnalyticsCollection: {
      items: components['schemas']['DocAnalyticsItem'][]
      nextPageToken?: components['schemas']['nextPageToken']
      nextPageLink?: components['schemas']['nextPageLink'] & string
    }
    /** @description Analytics metrics for a Coda Doc. */
    DocAnalyticsMetrics: {
      /**
       * Format: date
       * @description Date of the analytics data.
       * @example 2020-09-02
       */
      date: string
      /**
       * @description Number of times the doc was viewed.
       * @example 980
       */
      views: number
      /**
       * @description Number of times the doc was copied.
       * @example 24
       */
      copies: number
      /**
       * @description Number of times the doc was liked.
       * @example 342
       */
      likes: number
      /**
       * @description Number of unique visitors to this doc from a mobile device.
       * @example 530
       */
      sessionsMobile: number
      /**
       * @description Number of unique visitors to this doc from a desktop device.
       * @example 212
       */
      sessionsDesktop: number
      /**
       * @description Number of unique visitors to this doc from an unknown device type.
       * @example 10
       */
      sessionsOther: number
      /**
       * @description Sum of the total sessions from any device.
       * @example 1000
       */
      totalSessions: number
      /**
       * @description Number of credits used for AI chat.
       * @example 10
       */
      aiCreditsChat?: number
      /**
       * @description Number of credits used for AI block.
       * @example 10
       */
      aiCreditsBlock?: number
      /**
       * @description Number of credits used for AI column.
       * @example 10
       */
      aiCreditsColumn?: number
      /**
       * @description Number of credits used for AI assistant.
       * @example 10
       */
      aiCreditsAssistant?: number
      /**
       * @description Number of credits used for AI reviewer.
       * @example 10
       */
      aiCreditsReviewer?: number
      /**
       * @description Total number of AI credits used.
       * @example 50
       */
      aiCredits?: number
    }
    /**
     * @description Determines how the Doc analytics returned are sorted.
     * @enum {string}
     */
    DocAnalyticsOrderBy:
      | 'date'
      | 'docId'
      | 'title'
      | 'createdAt'
      | 'publishedAt'
      | 'likes'
      | 'copies'
      | 'views'
      | 'sessionsDesktop'
      | 'sessionsMobile'
      | 'sessionsOther'
      | 'totalSessions'
      | 'aiCreditsChat'
      | 'aiCreditsBlock'
      | 'aiCreditsColumn'
      | 'aiCreditsAssistant'
      | 'aiCreditsReviewer'
      | 'aiCredits'
    DocAnalyticsDetails: components['schemas']['DocReference'] & {
      /**
       * @description The name of the doc.
       * @example Cool Geometry Formulas
       */
      title: string
      /** @example https://coda.io/d/_dAbCDeFGH */
      icon?: components['schemas']['Icon']
      /**
       * Format: date-time
       * @description Creation time of the doc.
       * @example 2022-04-11T00:18:57.946Z
       */
      createdAt: string
      /**
       * Format: date-time
       * @description Published time of the doc.
       * @example 2022-04-12T00:18:57.946Z
       */
      publishedAt?: string
    }
    /** @description Summarized metrics for Coda docs. */
    DocAnalyticsSummary: {
      /**
       * @description Total number of sessions across all docs.
       * @example 1337
       */
      totalSessions: number
    }
    /** @description Analytics metrics for a page within a Coda doc. */
    PageAnalyticsMetrics: {
      /**
       * Format: date
       * @description Date of the analytics data.
       * @example 2022-06-03
       */
      date: string
      /**
       * @description Number of times the page was viewed within the given day.
       * @example 980
       */
      views: number
      /**
       * @description Number of unique browsers that viewed the page on the given day.
       * @example 24
       */
      sessions: number
      /**
       * @description Number of unique Coda users that viewed the page on the given day.
       * @example 42
       */
      users: number
      /**
       * @description Average number of seconds that the page was viewed on the given day.
       * @example 42
       */
      averageSecondsViewed: number
      /**
       * @description Median number of seconds that the page was viewed on the given day.
       * @example 42
       */
      medianSecondsViewed: number
      /**
       * @description Number of unique tabs that opened the doc on the given day.
       * @example 10
       */
      tabs: number
    }
    /** @description Analytics data for a page within a Coda doc. */
    PageAnalyticsItem: {
      page: components['schemas']['PageAnalyticsDetails']
      metrics: components['schemas']['PageAnalyticsMetrics'][]
    }
    /** @description Metadata about a page relevant to analytics. */
    PageAnalyticsDetails: {
      /**
       * @description ID of the page.
       * @example section-IjkLmnO
       */
      id: string
      /**
       * @description Name of the page.
       * @example Launch Status
       */
      name: string
      /** @example https://coda.io/d/_dAbCDeFGH */
      icon?: components['schemas']['Icon']
    }
    /** @description List of analytics for pages within a Coda doc over a date range. */
    PageAnalyticsCollection: {
      items: components['schemas']['PageAnalyticsItem'][]
      nextPageToken?: components['schemas']['nextPageToken']
      nextPageLink?: components['schemas']['nextPageLink'] & string
    }
    /** @description Metadata about a Pack relevant to analytics. */
    PackAnalyticsDetails: {
      /**
       * @description ID of the Pack.
       * @example 1003
       */
      id: number
      /**
       * @description The name of the Pack.
       * @example Cool Geometry Formulas
       */
      name: string
      /**
       * Format: url
       * @description The link to the logo of the Pack.
       */
      logoUrl?: string
      /**
       * Format: date-time
       * @description Creation time of the Pack.
       * @example 2022-04-11T00:18:57.946Z
       */
      createdAt: string
    }
    /** @description List of analytics for Coda Packs over a date range. */
    PackAnalyticsCollection: {
      items: components['schemas']['PackAnalyticsItem'][]
      nextPageToken?: components['schemas']['nextPageToken']
      nextPageLink?: components['schemas']['nextPageLink'] & string
    }
    /** @description Analytics data for a Coda Pack. */
    PackAnalyticsItem: {
      pack: components['schemas']['PackAnalyticsDetails']
      metrics: components['schemas']['PackAnalyticsMetrics'][]
    }
    /** @description Analytics metrics for a Coda Pack. */
    PackAnalyticsMetrics: {
      /**
       * Format: date
       * @description Date of the analytics data.
       * @example 2020-09-02
       */
      date: string
      /**
       * @description Number of unique documents that have installed this Pack.
       * @example 100
       */
      docInstalls: number
      /**
       * @description Number of unique workspaces that have installed this Pack.
       * @example 10
       */
      workspaceInstalls: number
      /**
       * @description Number of times regular formulas have been called.
       * @example 100
       */
      numFormulaInvocations: number
      /**
       * @description Number of times action formulas have been called.
       * @example 100
       */
      numActionInvocations: number
      /**
       * @description Number of times sync table formulas have been called.
       * @example 100
       */
      numSyncInvocations: number
      /**
       * @description Number of times metadata formulas have been called.
       * @example 100
       */
      numMetadataInvocations: number
      /**
       * @description Number of unique docs that have invoked a formula from this Pack in the past day.
       * @example 50
       */
      docsActivelyUsing: number
      /**
       * @description Number of unique docs that have invoked a formula from this Pack in the past 7 days.
       * @example 100
       */
      docsActivelyUsing7Day: number
      /**
       * @description Number of unique docs that have invoked a formula from this Pack in the past 30 days.
       * @example 200
       */
      docsActivelyUsing30Day: number
      /**
       * @description Number of unique docs that have invoked a formula from this Pack in the past 90 days.
       * @example 300
       */
      docsActivelyUsing90Day: number
      /**
       * @description Number of unique docs that have invoked a formula from this Pack ever.
       * @example 500
       */
      docsActivelyUsingAllTime: number
      /**
       * @description Number of unique workspaces that have invoked a formula from this Pack in the past day.
       * @example 10
       */
      workspacesActivelyUsing: number
      /**
       * @description Number of unique workspaces that have invoked a formula from this Pack in the past 7 days.
       * @example 15
       */
      workspacesActivelyUsing7Day: number
      /**
       * @description Number of unique workspaces that have invoked a formula from this Pack in the past 30 days.
       * @example 20
       */
      workspacesActivelyUsing30Day: number
      /**
       * @description Number of unique workspaces that have invoked a formula from this Pack in the past 90 days.
       * @example 30
       */
      workspacesActivelyUsing90Day: number
      /**
       * @description Number of unique workspaces that have invoked a formula from this Pack ever.
       * @example 50
       */
      workspacesActivelyUsingAllTime: number
      /** @description Number of unique workspaces that are currently involved in a trial. */
      workspacesActivelyTrialing: number
      /** @description Number of unique workspaces that have been involved in a trial in the last 7 days. */
      workspacesActivelyTrialing7Day: number
      /** @description Number of unique workspaces that have been involved in a trial in the last 30 days. */
      workspacesActivelyTrialing30Day: number
      /** @description Number of unique workspaces that have been involved in a trial in the last 90 days. */
      workspacesActivelyTrialing90Day: number
      /** @description Number of unique workspaces that have been involved in a trial ever. */
      workspacesActivelyTrialingAllTime: number
      /** @description Number of unique workspaces that have recently subscribed to the Pack. */
      workspacesNewlySubscribed: number
      /** @description Number of unique workspaces that are currently subscribed to the Pack. */
      workspacesWithActiveSubscriptions: number
      /** @description Number of unique workspaces that subscribed after undertaking a Pack trial. */
      workspacesWithSuccessfulTrials: number
      /** @description Amount of revenue (in USD) that the Pack has produced. */
      revenueUsd: string
    }
    /**
     * @description Determines how the Pack analytics returned are sorted.
     * @enum {string}
     */
    PackAnalyticsOrderBy:
      | 'date'
      | 'packId'
      | 'name'
      | 'createdAt'
      | 'docInstalls'
      | 'workspaceInstalls'
      | 'numFormulaInvocations'
      | 'numActionInvocations'
      | 'numSyncInvocations'
      | 'numMetadataInvocations'
      | 'docsActivelyUsing'
      | 'docsActivelyUsing7Day'
      | 'docsActivelyUsing30Day'
      | 'docsActivelyUsing90Day'
      | 'docsActivelyUsingAllTime'
      | 'workspacesActivelyUsing'
      | 'workspacesActivelyUsing7Day'
      | 'workspacesActivelyUsing30Day'
      | 'workspacesActivelyUsing90Day'
      | 'workspacesActivelyUsingAllTime'
      | 'workspacesWithActiveSubscriptions'
      | 'workspacesWithSuccessfulTrials'
      | 'revenueUsd'
    /** @description Summary analytics for Packs. */
    PackAnalyticsSummary: {
      /** @description The number of times this Pack was installed in docs. */
      totalDocInstalls: number
      /** @description The number of times this Pack was installed in workspaces. */
      totalWorkspaceInstalls: number
      /** @description The number of times formulas in this Pack were invoked. */
      totalInvocations: number
    }
    /**
     * @description Quantization period over which to view analytics.
     * @enum {string}
     */
    AnalyticsScale: 'daily' | 'cumulative'
    /** @description Analytics metrics for a Coda Pack formula. */
    PackFormulaAnalyticsMetrics: {
      /**
       * Format: date
       * @description Date of the analytics data.
       * @example 2020-09-02
       */
      date: string
      /**
       * @description Number of times this formula has been invoked.
       * @example 123
       */
      formulaInvocations: number
      /**
       * @description Number of errors from invocations.
       * @example 5
       */
      errors: number
      /**
       * @description Median latency of an invocation in milliseconds. Only present for daily metrics.
       * @example 500
       */
      medianLatencyMs?: number
      /**
       * @description Median response size in bytes. Only present for daily metrics.
       * @example 300
       */
      medianResponseSizeBytes?: number
      /**
       * @description Number of unique docs that have invoked a formula from this Pack in the past day.
       * @example 50
       */
      docsActivelyUsing: number
      /**
       * @description Number of unique docs that have invoked a formula from this Pack in the past 7 days.
       * @example 100
       */
      docsActivelyUsing7Day: number
      /**
       * @description Number of unique docs that have invoked a formula from this Pack in the past 30 days.
       * @example 200
       */
      docsActivelyUsing30Day: number
      /**
       * @description Number of unique docs that have invoked a formula from this Pack in the past 90 days.
       * @example 300
       */
      docsActivelyUsing90Day: number
      /**
       * @description Number of unique docs that have invoked a formula from this Pack ever.
       * @example 500
       */
      docsActivelyUsingAllTime: number
      /**
       * @description Number of unique workspaces that have invoked a formula from this Pack in the past day.
       * @example 10
       */
      workspacesActivelyUsing: number
      /**
       * @description Number of unique workspaces that have invoked a formula from this Pack in the past 7 days.
       * @example 15
       */
      workspacesActivelyUsing7Day: number
      /**
       * @description Number of unique workspaces that have invoked a formula from this Pack in the past 30 days.
       * @example 20
       */
      workspacesActivelyUsing30Day: number
      /**
       * @description Number of unique workspaces that have invoked a formula from this Pack in the past 90 days.
       * @example 30
       */
      workspacesActivelyUsing90Day: number
      /**
       * @description Number of unique workspaces that have invoked a formula from this Pack ever.
       * @example 50
       */
      workspacesActivelyUsingAllTime: number
      /** @description Number of unique workspaces that are currently involved in a trial. */
      workspacesActivelyTrialing?: number
      /** @description Number of unique workspaces that have been involved in a trial in the last 7 days. */
      workspacesActivelyTrialing7Day?: number
      /** @description Number of unique workspaces that have been involved in a trial in the last 30 days. */
      workspacesActivelyTrialing30Day?: number
      /** @description Number of unique workspaces that have been involved in a trial in the last 90 days. */
      workspacesActivelyTrialing90Day?: number
      /** @description Number of unique workspaces that have been involved in a trial ever. */
      workspacesActivelyTrialingAllTime?: number
      /** @description Number of unique workspaces that have recently subscribed to the Pack. */
      workspacesNewlySubscribed?: number
      /** @description Number of unique workspaces that are currently subscribed to the Pack. */
      workspacesWithActiveSubscriptions?: number
      /** @description Number of unique workspaces that subscribed after undertaking a Pack trial. */
      workspacesWithSuccessfulTrials?: number
      /** @description Amount of revenue (in USD) that the Pack has produced. */
      revenueUsd?: string
    }
    /** @description Analytics data for a Coda Pack formula. */
    PackFormulaAnalyticsItem: {
      formula: components['schemas']['PackFormulaIdentifier']
      metrics: components['schemas']['PackFormulaAnalyticsMetrics'][]
    }
    /** @description A collection of analytics for Coda Packs formulas over a date range. */
    PackFormulaAnalyticsCollection: {
      items: components['schemas']['PackFormulaAnalyticsItem'][]
      nextPageToken?: components['schemas']['nextPageToken']
      nextPageLink?: components['schemas']['nextPageLink'] & string
    }
    /**
     * @description Determines how the Pack formula analytics returned are sorted.
     * @enum {string}
     */
    PackFormulaAnalyticsOrderBy:
      | 'date'
      | 'formulaName'
      | 'formulaType'
      | 'formulaInvocations'
      | 'medianLatencyMs'
      | 'medianResponseSizeBytes'
      | 'errors'
      | 'docsActivelyUsing'
      | 'docsActivelyUsing7Day'
      | 'docsActivelyUsing30Day'
      | 'docsActivelyUsing90Day'
      | 'docsActivelyUsingAllTime'
      | 'workspacesActivelyUsing'
      | 'workspacesActivelyUsing7Day'
      | 'workspacesActivelyUsing30Day'
      | 'workspacesActivelyUsing90Day'
      | 'workspacesActivelyUsingAllTime'
    /** @description Response representing the last day analytics were updated. */
    AnalyticsLastUpdatedResponse: {
      /**
       * Format: date
       * @description Date that doc analytics were last updated.
       * @example 2022-05-01
       */
      docAnalyticsLastUpdated: string
      /**
       * Format: date
       * @description Date that Pack analytics were last updated.
       * @example 2022-05-01
       */
      packAnalyticsLastUpdated: string
      /**
       * Format: date
       * @description Date that Pack formula analytics were last updated.
       * @example 2022-05-01
       */
      packFormulaAnalyticsLastUpdated: string
    }
    /** @description Details about a Pack. */
    Pack: {
      /**
       * @description ID of the Pack.
       * @example 1003
       */
      id: number
      /**
       * Format: url
       * @description The link to the logo of the Pack.
       */
      logoUrl?: string
      /**
       * Format: url
       * @description The link to the cover photo of the Pack.
       */
      coverUrl?: string
      /** @description The example images for the Pack. */
      exampleImages?: components['schemas']['PackImageFile'][]
      /**
       * @description The parent workspace for the Pack.
       * @example ws-asdf
       */
      workspaceId: string
      /** @description Publishing categories associated with this Pack. */
      categories: components['schemas']['PublishingCategory'][]
      /** @description Denotes if the pack is certified by Coda. */
      certified?: boolean
      sourceCodeVisibility?: components['schemas']['PackSourceCodeVisibility']
      /**
       * @description The name of the Pack.
       * @example Cool Geometry Formulas
       */
      name: string
      /**
       * @description The full description of the Pack.
       * @example This Pack allows users to calculate the surface area and volume of a few common 3D shapes, like cubes and pyramids.
       */
      description: string
      /**
       * @description A short version of the description of the Pack.
       * @example Calculate cool geometric formulas like surface area.
       */
      shortDescription: string
      /**
       * @description A contact email for the Pack.
       * @example user@email.com
       */
      supportEmail?: string
      /**
       * Format: url
       * @description A Terms of Service URL for the Pack.
       */
      termsOfServiceUrl?: string
      /**
       * Format: url
       * @description A Privacy Policy URL for the Pack.
       */
      privacyPolicyUrl?: string
      overallRateLimit?: components['schemas']['PackRateLimit']
      perConnectionRateLimit?: components['schemas']['PackRateLimit']
      featuredDocStatus?: components['schemas']['FeaturedDocStatus']
    }
    /** @description Summary of a Pack. */
    PackSummary: {
      /**
       * @description ID of the Pack.
       * @example 1003
       */
      id: number
      /**
       * Format: url
       * @description The link to the logo of the Pack.
       */
      logoUrl?: string
      /**
       * Format: url
       * @description The link to the cover photo of the Pack.
       */
      coverUrl?: string
      /** @description The example images for the Pack. */
      exampleImages?: components['schemas']['PackImageFile'][]
      /**
       * @description The parent workspace for the Pack.
       * @example ws-asdf
       */
      workspaceId: string
      /** @description Publishing categories associated with this Pack. */
      categories: components['schemas']['PublishingCategory'][]
      /** @description Denotes if the pack is certified by Coda. */
      certified?: boolean
      sourceCodeVisibility?: components['schemas']['PackSourceCodeVisibility']
      /**
       * @description The name of the Pack.
       * @example Cool Geometry Formulas
       */
      name: string
      /**
       * @description The full description of the Pack.
       * @example This Pack allows users to calculate the surface area and volume of a few common 3D shapes, like cubes and pyramids.
       */
      description: string
      /**
       * @description A short version of the description of the Pack.
       * @example Calculate cool geometric formulas like surface area.
       */
      shortDescription: string
      /**
       * @description A contact email for the Pack.
       * @example user@email.com
       */
      supportEmail?: string
      /**
       * Format: url
       * @description A Terms of Service URL for the Pack.
       */
      termsOfServiceUrl?: string
      /**
       * Format: url
       * @description A Privacy Policy URL for the Pack.
       */
      privacyPolicyUrl?: string
    }
    /** @description List of Pack summaries. */
    PackSummaryList: {
      items: components['schemas']['PackSummary'][]
      nextPageToken?: components['schemas']['nextPageToken']
      nextPageLink?: components['schemas']['nextPageLink'] & string
    }
    /** @description Rate limit in Pack settings. */
    PackRateLimit: {
      /**
       * @description The rate limit interval in seconds.
       * @example 3600
       */
      intervalSeconds: number
      /**
       * @description The maximum number of Pack operations that can be performed in a given interval.
       * @example 20
       */
      operationsPerInterval: number
    }
    /**
     * @description Determines how the Packs returned are sorted.
     * @enum {string}
     */
    PacksSortBy: 'title' | 'createdAt' | 'updatedAt'
    /**
     * @description Determines how the Pack listings returned are sorted.
     * @enum {string}
     */
    PackListingsSortBy:
      | 'packId'
      | 'name'
      | 'packVersion'
      | 'packVersionModifiedAt'
    /** @description Information indicating where to upload the Pack version definition. */
    PackVersionUploadInfo: {
      /**
       * @description A URL to be used for uploading a Pack version definition.
       * @example https://coda-us-west-2-prod-packs-upload.s3.amazonaws.com/packs/123/versions/1.0.0
       */
      uploadUrl: string
      /**
       * @description Key-value pairs of authorization headers to include in the upload request.
       * @example {"header1": "value1"}
       */
      headers: {
        [key: string]: string
      }
    }
    /** @description Metadata about a Pack principal. */
    PackPrincipal:
      | components['schemas']['PackUserPrincipal']
      | components['schemas']['PackWorkspacePrincipal']
      | components['schemas']['PackGlobalPrincipal']
    /**
     * @description Type of Pack permissions.
     * @enum {string}
     */
    PackPrincipalType: 'user' | 'workspace' | 'worldwide'
    /** @enum {string} */
    PackAccessType: 'view' | 'test' | 'edit' | 'admin'
    /** @description Access types for a Pack. */
    PackAccessTypes: components['schemas']['PackAccessType'][]
    PackUserPrincipal: {
      /** @enum {string} */
      type: 'user'
      email: string
    }
    PackWorkspacePrincipal: {
      /** @enum {string} */
      type: 'workspace'
      workspaceId: string
    }
    PackGlobalPrincipal: {
      /** @enum {string} */
      type: 'worldwide'
    }
    /** @description List of Pack permissions. */
    PackPermissionList: {
      items: components['schemas']['PackPermission'][]
      permissionUsers: components['schemas']['UserSummary'][]
    }
    /** @description Metadata about a Pack permission. */
    PackPermission: {
      /** @description Id for the Permission */
      id: string
      principal: components['schemas']['PackPrincipal']
      access: components['schemas']['PackAccessType']
    }
    /** @description A Pack image file. */
    PackImageFile: {
      /** @description The name of the image file. */
      filename: string
      /**
       * Format: url
       * @description The URL to the image file.
       */
      imageUrl: string
      /** @description The asset id of the Pack's image. */
      assetId: string
      /** @description The alt text for the image. */
      altText?: string
      /**
       * @description The media type of the image.
       * @example image/jpeg
       */
      mimeType?: string
    }
    /** @enum {string} */
    PackAssetType: 'logo' | 'cover' | 'exampleImage'
    /** @description Information indicating where to upload the Pack asset, and an endpoint to mark the upload as complete. */
    PackAssetUploadInfo: {
      /**
       * Format: url
       * @description A signed URL to be used for uploading a Pack asset.
       * @example https://coda-us-west-2-prod-blobs-upload.s3-accelerate.amazonaws.com/packs/123/assets/logo/e23fcb5e564f08b71183d424c2c380c0
       */
      uploadUrl: string
      /**
       * @description An endpoint to mark the upload as complete.
       * @example /packs/123/assets/e23fcb5e564f08b71183d424c2c380c0
       */
      packAssetUploadedPathName: string
      /**
       * @description Key-value pairs of authorization headers to include in the upload request.
       * @example {"header1": "value1"}
       */
      headers: {
        [key: string]: string
      }
    }
    /** @description Basic details about a configuration that can be used in conjunction with a pack */
    PackConfigurationEntry: {
      configurationId: string
      /** @description Name of the configuration */
      name: string
      /** @description Policy associated with the configuration */
      policy?: {
        [key: string]: unknown
      }
    }
    /** @description Describes restrictions that a user's organization has placed on a pack */
    PackOrganizationAccessForDocs: {
      canRequestAccess: boolean
      hasRequestedAccess: boolean
      requiresConfiguration: boolean
      allowedConfigurations?: components['schemas']['PackConfigurationEntry'][]
      incompatibleDocPermissions?: components['schemas']['Permission'][]
      incompatibleDocOwner?: components['schemas']['UserSummary']
      incompatibleDocFolder?: components['schemas']['FolderReference']
    }
    /** @description Details about a Pack version. */
    PackVersion: {
      /**
       * @description ID of the Pack.
       * @example 1003
       */
      packId: number
      /**
       * @description Developer notes.
       * @example Adding a new formula.
       */
      buildNotes: string
      /**
       * Format: date-time
       * @description Timestamp for when the version was created.
       * @example 2018-04-11T00:18:57.946Z
       */
      createdAt: string
      /**
       * @description The login ID of creation user of the Pack version.
       * @example api@coda.io
       */
      creationUserLoginId: string
      /**
       * @description The release number of the Pack version if it has one.
       * @example 2
       */
      releaseId?: number
      /**
       * @description The semantic format of the Pack version.
       * @example 1.0.3
       */
      packVersion: string
      /**
       * @description What Packs SDK version was this version built on.
       * @example 1.5.1
       */
      sdkVersion?: string
      source?: components['schemas']['PackSource']
    }
    /** @description List of Pack versions. */
    PackVersionList: {
      items: components['schemas']['PackVersion'][]
      creationUsers: components['schemas']['UserSummary'][]
      nextPageToken?: components['schemas']['nextPageToken']
      nextPageLink?: components['schemas']['nextPageLink'] & string
    }
    /** @description Details about a Pack release. */
    PackRelease: {
      /**
       * @description ID of the Packs.
       * @example 1003
       */
      packId: number
      /**
       * @description Developer notes.
       * @example The first release.
       */
      releaseNotes: string
      /**
       * Format: date-time
       * @description Timestamp for when the release was created.
       * @example 2018-04-11T00:18:57.946Z
       */
      createdAt: string
      /**
       * @description The release number of the Pack version if it has one.
       * @example 2
       */
      releaseId: number
      /**
       * @description The semantic format of the Pack version.
       * @example 1.0.3
       */
      packVersion: string
      /**
       * @description What Packs SDK version was this version built on.
       * @example 1.5.1
       */
      sdkVersion: string
    }
    /** @description List of Pack releases. */
    PackReleaseList: {
      items: components['schemas']['PackRelease'][]
      nextPageToken?: components['schemas']['nextPageToken']
      nextPageLink?: components['schemas']['nextPageLink'] & string
    }
    /** @enum {string} */
    PackSource: 'web' | 'cli'
    /** @description Information indicating where to upload the Pack source code, and an endpoint to mark the upload as complete. */
    PackSourceCodeUploadInfo: {
      /**
       * Format: url
       * @description A signed URL to be used for uploading a Pack source code.
       * @example https://coda-us-west-2-packs-upload.s3-accelerate.amazonaws.com/packUploads/123/1/main.ts
       */
      uploadUrl: string
      /**
       * @description An endpoint to mark the upload as complete.
       * @example /packs/123/versions/1/sourceCode/uploadComplete
       */
      uploadedPathName: string
      /**
       * @description Key-value pairs of authorization headers to include in the upload request.
       * @example {"header1": "value1"}
       */
      headers: {
        [key: string]: string
      }
    }
    /** @description Information indicating where to upload the Pack source code, and an endpoint to mark the upload as complete. */
    PackSourceCodeInfo: {
      files: components['schemas']['PackSourceCode'][]
    }
    /** @description Details about a Pack's source code. */
    PackSourceCode: {
      /**
       * @description name of the file
       * @example main.ts
       */
      filename: string
      /**
       * @description The URL to download the source code from
       * @example https://coda-us-west-2-packs.s3.us-west-2.amazonaws.com/packs/123/1/main.ts
       */
      url: string
    }
    /**
     * @description Widest principal a Pack is available to.
     * @enum {string}
     */
    PackDiscoverability: 'public' | 'workspace' | 'private'
    /** @description A Pack listing. */
    PackListing: {
      /**
       * @description ID of the Pack.
       * @example 1003
       */
      packId: number
      /**
       * @description The version of the Pack.
       * @example 1.0.3
       */
      packVersion: string
      /**
       * @description The current release number of the Pack if released, otherwise undefined.
       * @example 2
       */
      releaseId?: number
      /**
       * Format: date-time
       * @description The timestamp of the latest release of this Pack.
       * @example 2018-04-11T00:18:57.946Z
       */
      lastReleasedAt?: string
      /**
       * Format: url
       * @description The link to the logo of the Pack.
       */
      logoUrl: string
      /**
       * Format: url
       * @description The link to the cover photo of the Pack.
       */
      coverUrl?: string
      /** @description The example images for the Pack. */
      exampleImages?: components['schemas']['PackImageFile'][]
      /**
       * @description The name of the Pack.
       * @example Cool Geometry Formulas
       */
      name: string
      /**
       * @description The full description of the Pack.
       * @example This Pack allows users to calculate the surface area and volume of a few common 3D shapes, like cubes and pyramids.
       */
      description: string
      /**
       * @description A short version of the description of the Pack.
       * @example Calculate cool geometric formulas like surface area.
       */
      shortDescription: string
      /**
       * @description A contact email for the Pack.
       * @example user@email.com
       */
      supportEmail?: string
      /**
       * Format: url
       * @description A Terms of Service URL for the Pack.
       */
      termsOfServiceUrl?: string
      /**
       * Format: url
       * @description A Privacy Policy URL for the Pack.
       */
      privacyPolicyUrl?: string
      /** @description Publishing Categories associated with this Pack. */
      categories: components['schemas']['PublishingCategory'][]
      /** @description Makers associated with this Pack. */
      makers: components['schemas']['MakerSummary'][]
      /** @description Denotes if the pack is certified by Coda. */
      certified?: boolean
      minimumFeatureSet?: components['schemas']['FeatureSet']
      unrestrictedFeatureSet?: components['schemas']['FeatureSet']
      /**
       * @description The URL where complete metadata about the contents of the Pack version can be downloaded.
       * @example https://codahosted.io/packs/12345/1.2.3/metadata/0c892064aa5cb.json
       */
      externalMetadataUrl: string
      standardPackPlan?: components['schemas']['StandardPackPlan']
      bundledPackPlan?: components['schemas']['BundledPackPlan']
      sourceCodeVisibility?: components['schemas']['PackSourceCodeVisibility']
      /**
       * @description What Packs SDK version was this version built on.
       * @example 1.5.1
       */
      sdkVersion: string
    }
    /** @description A detailed Pack listing. */
    PackListingDetail: {
      /**
       * @description ID of the Pack.
       * @example 1003
       */
      packId: number
      /**
       * @description The version of the Pack.
       * @example 1.0.3
       */
      packVersion: string
      /**
       * @description The current release number of the Pack if released, otherwise undefined.
       * @example 2
       */
      releaseId?: number
      /**
       * Format: date-time
       * @description The timestamp of the latest release of this Pack.
       * @example 2018-04-11T00:18:57.946Z
       */
      lastReleasedAt?: string
      /**
       * Format: url
       * @description The link to the logo of the Pack.
       */
      logoUrl: string
      /**
       * Format: url
       * @description The link to the cover photo of the Pack.
       */
      coverUrl?: string
      /** @description The example images for the Pack. */
      exampleImages?: components['schemas']['PackImageFile'][]
      /**
       * @description The name of the Pack.
       * @example Cool Geometry Formulas
       */
      name: string
      /**
       * @description The full description of the Pack.
       * @example This Pack allows users to calculate the surface area and volume of a few common 3D shapes, like cubes and pyramids.
       */
      description: string
      /**
       * @description A short version of the description of the Pack.
       * @example Calculate cool geometric formulas like surface area.
       */
      shortDescription: string
      /**
       * @description A contact email for the Pack.
       * @example user@email.com
       */
      supportEmail?: string
      /**
       * Format: url
       * @description A Terms of Service URL for the Pack.
       */
      termsOfServiceUrl?: string
      /**
       * Format: url
       * @description A Privacy Policy URL for the Pack.
       */
      privacyPolicyUrl?: string
      /** @description Publishing Categories associated with this Pack. */
      categories: components['schemas']['PublishingCategory'][]
      /** @description Makers associated with this Pack. */
      makers: components['schemas']['MakerSummary'][]
      /** @description Denotes if the pack is certified by Coda. */
      certified?: boolean
      minimumFeatureSet?: components['schemas']['FeatureSet']
      unrestrictedFeatureSet?: components['schemas']['FeatureSet']
      /**
       * @description The URL where complete metadata about the contents of the Pack version can be downloaded.
       * @example https://codahosted.io/packs/12345/1.2.3/metadata/0c892064aa5cb.json
       */
      externalMetadataUrl: string
      standardPackPlan?: components['schemas']['StandardPackPlan']
      bundledPackPlan?: components['schemas']['BundledPackPlan']
      sourceCodeVisibility?: components['schemas']['PackSourceCodeVisibility']
      /**
       * @description What Packs SDK version was this version built on.
       * @example 1.5.1
       */
      sdkVersion: string
      discoverability: components['schemas']['PackDiscoverability']
      userAccess: components['schemas']['PackUserAccess']
      /** @description The URL of a Coda Help Center article with documentation about the Pack. This will only exist for select Coda-authored Packs. */
      codaHelpCenterUrl?: string
      configuration?: components['schemas']['PackConfigurationEntry']
    }
    /** @description A list of Pack listings. */
    PackListingList: {
      items: components['schemas']['PackListing'][]
      nextPageToken?: components['schemas']['nextPageToken']
      nextPageLink?: components['schemas']['nextPageLink'] & string
    }
    /** @description Metadata of a Pack system connection. */
    PackSystemConnectionMetadata:
      | components['schemas']['PackConnectionHeaderMetadata']
      | components['schemas']['PackConnectionMultiHeaderMetadata']
      | components['schemas']['PackConnectionUrlParamMetadata']
      | components['schemas']['PackConnectionHttpBasicMetadata']
      | components['schemas']['PackConnectionCustomMetadata']
      | components['schemas']['PackConnectionOauth2ClientCredentialsMetadata']
      | components['schemas']['PackConnectionGoogleServiceAccountMetadata']
    /**
     * @description The access capabilities the current user has for this Pack.
     * @example {"canEdit": false, "canTest": false, "canView": true, "canInstall": true}
     */
    PackUserAccess: {
      canEdit: boolean
      canTest: boolean
      canView: boolean
      canInstall: boolean
      canPurchase: boolean
      requiresTrial: boolean
      canConnectAccount: boolean
      organization?:
        | components['schemas']['PackOrganizationAccessForDocs']
        | components['schemas']['PackOrganizationAccessForCodaBrain']
    }
    /**
     * @description Type of context in which a Pack is being installed.
     * @enum {string}
     */
    PackListingInstallContextType: 'workspace' | 'doc'
    /**
     * @description Live or Latest version of pack
     * @enum {string}
     */
    IngestionPackReleaseChannel: 'LIVE' | 'LATEST'
    /** @description The Pack OAuth configuration metadata. */
    PackOauthConfigMetadata: {
      /** @description Masked OAuth client id. If not set, empty string will be returned. */
      maskedClientId: string
      /** @description Masked OAuth client secret. If not set, empty string will be returned. */
      maskedClientSecret: string
      /** @description Authorization URL of the OAuth provider. */
      authorizationUrl: string
      /** @description Token URL of the OAuth provider. */
      tokenUrl: string
      /** @description Optional token prefix that's used to make the API request. */
      tokenPrefix?: string
      /** @description Optional scopes of the OAuth client. */
      scopes?: string
      /** @description Redirect URI of the Pack. */
      redirectUri: string
    }
    /** @description Describes restrictions that a user's organization has placed on a pack for Coda Brain ingestions */
    PackOrganizationAccessForCodaBrain: {
      canRequestAccess: boolean
      hasRequestedAccess: boolean
      requiresConfiguration: boolean
      allowedConfigurations?: components['schemas']['PackConfigurationEntry'][]
    }
    /** @description Payload for creating a Pack. */
    CreatePackRequest: {
      /**
       * @description The parent workspace for the Pack. If unspecified, the user's default workspace will be used.
       * @example ws-asdf
       */
      workspaceId?: string
      /**
       * @description The name for the Pack.
       * @example Trigonometry
       */
      name?: string
      /**
       * @description A brief description of the Pack.
       * @example Common trigonometric functions.
       */
      description?: string
      /**
       * @description The ID of the new Pack's source, if this new Pack was forked.
       * @example 10029
       */
      sourcePackId?: number | null
    }
    /** @description Info about a Pack that was just created. */
    CreatePackResponse: {
      /**
       * @description The ID assigned to the newly-created Pack.
       * @example 123
       */
      packId: number
    }
    /** @description Payload for getting the next version of a Pack. */
    GetNextPackVersionRequest: {
      /**
       * @description The metadata for the next version of the Pack.
       * @example {"formulas": [{"description": "my formula", "name": "foo", "parameters": [], "resultType": 0}]}
       */
      proposedMetadata: string
      /**
       * @description The SDK version the metadata was built on.
       * @example 1.0.0
       */
      sdkVersion?: string
    }
    /**
     * @description Type of Pack connections.
     * @enum {string}
     */
    PackConnectionType:
      | 'header'
      | 'multiHeader'
      | 'urlParam'
      | 'httpBasic'
      | 'custom'
      | 'oauth2ClientCredentials'
      | 'googleServiceAccount'
    /**
     * @description Location of including OAuth2 client credentials in a request.
     * @enum {string}
     */
    PackOAuth2ClientCredentialsLocation: 'automatic' | 'body' | 'header'
    /** @description Credentials of a Pack connection. */
    PackSystemConnectionCredentials:
      | components['schemas']['PackConnectionHeaderCredentials']
      | components['schemas']['PackConnectionMultiHeaderCredentials']
      | components['schemas']['PackConnectionUrlParamCredentials']
      | components['schemas']['PackConnectionHttpBasicCredentials']
      | components['schemas']['PackConnectionCustomCredentials']
      | components['schemas']['PackConnectionOauth2ClientCredentials']
      | components['schemas']['PackConnectionGoogleServiceAccountCredentials']
    PackConnectionHeaderMetadata: {
      /** @enum {string} */
      type: 'header'
      maskedToken?: string
      headerName: string
      tokenPrefix: string
    }
    PackConnectionMultiHeaderMetadata: {
      /** @enum {string} */
      type: 'multiHeader'
      headers: {
        headerName: string
        maskedToken: string
        tokenPrefix?: string
      }[]
      presets: {
        headerName: string
        tokenPrefix?: string
      }[]
    }
    PackConnectionUrlParamMetadata: {
      /** @enum {string} */
      type: 'urlParam'
      params: {
        key: string
        maskedValue: string
      }[]
      domain: string
      presetKeys: string[]
    }
    PackConnectionHttpBasicMetadata: {
      /** @enum {string} */
      type: 'httpBasic'
      maskedUsername?: string
      maskedPassword?: string
    }
    PackConnectionCustomMetadata: {
      /** @enum {string} */
      type: 'custom'
      /** @description An array of objects containing the parameter key and masked value. */
      params: {
        key: string
        maskedValue: string
      }[]
      /** @description The domain corresponding to the pre-authorized network domain in the pack. */
      domain: string
      /** @description An array containing the keys of parameters specified by the authentication config. */
      presetKeys: string[]
    }
    PackConnectionOauth2ClientCredentialsMetadata: {
      /** @enum {string} */
      type: 'oauth2ClientCredentials'
      location: components['schemas']['PackOAuth2ClientCredentialsLocation']
      maskedClientId: string
      maskedClientSecret: string
    }
    PackConnectionGoogleServiceAccountMetadata: {
      /** @enum {string} */
      type: 'googleServiceAccount'
      maskedServiceAccountKey: string
    }
    PackConnectionHeaderCredentials: {
      /** @enum {string} */
      type: 'header'
      token: string
    }
    PackConnectionMultiHeaderCredentials: {
      /** @enum {string} */
      type: 'multiHeader'
      tokens: {
        key: string
        value: string
      }[]
    }
    PackConnectionUrlParamCredentials: {
      /** @enum {string} */
      type: 'urlParam'
      params: {
        key: string
        value: string
      }[]
    }
    PackConnectionHttpBasicCredentials: {
      /** @enum {string} */
      type: 'httpBasic'
      username: string
      password?: string
    }
    PackConnectionCustomCredentials: {
      /** @enum {string} */
      type: 'custom'
      params: {
        key: string
        value: string
      }[]
    }
    PackConnectionOauth2ClientCredentials: {
      /** @enum {string} */
      type: 'oauth2ClientCredentials'
      clientId: string
      clientSecret: string
    }
    PackConnectionGoogleServiceAccountCredentials: {
      /** @enum {string} */
      type: 'googleServiceAccount'
      serviceAccountKey: string
    }
    PackConnectionHeaderPatch: {
      /** @enum {string} */
      type: 'header'
      token?: string
    }
    PackConnectionMultiHeaderPatch: {
      /** @enum {string} */
      type: 'multiHeader'
      tokensToPatch?: {
        key: string
        value: string
      }[]
    }
    PackConnectionUrlParamPatch: {
      /** @enum {string} */
      type: 'urlParam'
      paramsToPatch?: {
        key: string
        value: string
      }[]
    }
    PackConnectionHttpBasicPatch: {
      /** @enum {string} */
      type: 'httpBasic'
      username?: string
      password?: string
    }
    /** @description List of grouped Pack logs. */
    GroupedPackLogsList: {
      items: components['schemas']['GroupedPackLog'][]
      nextPageToken?: components['schemas']['nextPageToken']
      nextPageLink?: components['schemas']['nextPageLink'] & string
      /** @description This flag will be set to true if the result doens't include all the related logs. */
      incompleteRelatedLogs: boolean
    }
    /** @description List of Ingestion Executions. */
    IngestionExecutionsList: {
      items: components['schemas']['IngestionExecutionContext'][]
      nextPageToken?: components['schemas']['nextPageToken']
    }
    PackConnectionCustomPatch: {
      /** @enum {string} */
      type: 'custom'
      paramsToPatch?: {
        key: string
        value: string
      }[]
    }
    PackConnectionOauth2ClientCredentialsPatch: {
      /** @enum {string} */
      type: 'oauth2ClientCredentials'
      clientId?: string
      clientSecret?: string
    }
    PackConnectionGoogleServiceAccountPatch: {
      /** @enum {string} */
      type: 'googleServiceAccount'
      serviceAccountKey?: string
    }
    /** @description List of Pack logs. */
    PackLogsList: {
      items: components['schemas']['PackLog'][]
      nextPageToken?: components['schemas']['nextPageToken']
      nextPageLink?: components['schemas']['nextPageLink'] & string
    }
    /** @description A record of grouped Pack log. */
    GroupedPackLog:
      | components['schemas']['GroupedPackInvocationLog']
      | components['schemas']['GroupedPackAuthLog']
    /** @description A record of Pack log. */
    PackLog:
      | components['schemas']['PackCustomLog']
      | components['schemas']['PackInvocationLog']
      | components['schemas']['PackFetcherLog']
      | components['schemas']['PackInternalLog']
      | components['schemas']['PackAuthLog']
      | components['schemas']['PackIngestionLifecycleLog']
      | components['schemas']['PackIngestionDebugLog']
    /** @description Logging context that comes with a Pack log. */
    PackLogContext: {
      docId: string
      packId: string
      packVersion: string
      formulaName: string
      userId: string
      connectionId: string
      /** @description A unique identifier of the Pack invocation that can be used to associate all log types generated in one call of a Pack formula. */
      requestId: string
      requestType: components['schemas']['PackLogRequestType']
      /**
       * Format: date-time
       * @description Creation time of the log.
       * @example 2018-04-11T00:18:57.946Z
       */
      createdAt: string
      /** @description Unique identifier of this log record. */
      logId: string
      /** @description Doc canvas object id where the formula was fired from. */
      docObjectId?: string
      /** @description Doc canvas row id where the formula was fired from. */
      docRowId?: string
      /** @description Doc canvas column id where the formula was fired from. */
      docColumnId?: string
      /** @description True if this is a formula invocation loading a page of a sync table, or metadata for a sync table (like creating a dynamic schema). */
      isSyncTable?: boolean
      /** @description True if this is an execution of a sync table which received a pagination parameter. */
      isContinuedSyncTable?: boolean
      /** @description If this formula invocation was for a parameter auto-complete, this names the parameter. */
      autocompleteParameterName?: string
      /** @description If this formula was invoked by something other than a user action, this should say what that was. */
      invocationSource?: string
      /** @description Key to be used in fetching log details. */
      detailsKey: string
      /** @description Unique identifier of the ingestion that triggered this log. */
      ingestionId?: string
      /** @description Unique identifier of the root ingestion that triggered this log. */
      rootIngestionId?: string
      /** @description Unique identifier of the ingestion execution that triggered this log. */
      ingestionExecutionId?: string
    }
    /** @description Pack log generated by developer's custom logging with context.logger. */
    PackCustomLog: {
      /** @enum {string} */
      type: 'custom'
      context: components['schemas']['PackLogContext']
      /**
       * @description The message that's passed into context.logger.
       * @example The formula is called!
       */
      message: string
      level: components['schemas']['LogLevel']
    }
    /** @description System logs of the invocations of the Pack. */
    PackInvocationLog: {
      /** @enum {string} */
      type: 'invocation'
      context: components['schemas']['PackLogContext']
      /** @description True if the formula returned a prior result without executing. */
      cacheHit?: boolean
      /** @description Duration of the formula exeuction in miliseconds. */
      duration?: number
      /** @description Error info if this invocation resulted in an error. */
      error?: {
        message: string
        stack?: string
      }
    }
    /** @description Grouped logs of the invocations of the Pack. */
    GroupedPackInvocationLog: {
      /** @enum {string} */
      type: 'invocation'
      invocationLog: components['schemas']['PackInvocationLog']
      relatedLogs: components['schemas']['PackLog'][]
    }
    /** @description Grouped logs of the Pack's auth requests. */
    GroupedPackAuthLog: {
      /** @enum {string} */
      type: 'auth'
      authLog: components['schemas']['PackAuthLog']
      relatedLogs: components['schemas']['PackLog'][]
    }
    /** @description System logs of Pack calls to context.fetcher. */
    PackFetcherLog: {
      /** @enum {string} */
      type: 'fetcher'
      context: components['schemas']['PackLogContext']
      /** @description The number of bytes in the HTTP request sent */
      requestSizeBytes?: number
      responseCode?: number
      /** @description The number of bytes in the HTTP response received */
      responseSizeBytes?: number
      /** @enum {string} */
      method?: 'GET' | 'POST' | 'PUT' | 'DELETE' | 'PATCH' | 'HEAD'
      /**
       * @description base URL of the fetcher request, with all query parameters stripped off.
       * @example https://coda.io/api
       */
      baseUrl?: string
      /** @description true if the fetcher request hits catche instead of actually requesting the remote service. */
      cacheHit?: boolean
      /** @description Duration of the fetcher request in miliseconds. */
      duration?: number
    }
    /** @description Coda internal logs from the packs infrastructure. Only visible to Codans. */
    PackInternalLog: {
      /** @enum {string} */
      type: 'internal'
      context: components['schemas']['PackLogContext']
      /** @description The log message. */
      message: string
      level: components['schemas']['LogLevel']
    }
    /** @description System logs of Pack authentication requests. */
    PackAuthLog: {
      /** @enum {string} */
      type: 'auth'
      context: components['schemas']['PackLogContext']
      /** @description The request path. */
      path: string
      /** @description The error message. */
      errorMessage?: string
      /** @description The error stacktrace (internal only). */
      errorStack?: string
    }
    /** @description Pack log generated by an executing ingestion. */
    PackIngestionLifecycleLog: {
      /** @enum {string} */
      type: 'ingestionLifecycle'
      context: components['schemas']['PackLogContext']
      /**
       * @description The message that's passed into context.logger.
       * @example The formula is called!
       */
      message: string
      level: components['schemas']['LogLevel']
    }
    /** @description Pack log generated by an executing ingestion. Contains metadata helpful for debugging */
    PackIngestionDebugLog: {
      /** @enum {string} */
      type: 'ingestionDebug'
      context: components['schemas']['PackLogContext']
      /**
       * @description The message that's passed into context.logger.
       * @example The formula is called!
       */
      message: string
      level: components['schemas']['LogLevel']
    }
    /**
     * @description The context request type where a Pack log is generated.
     * @enum {string}
     */
    PackLogRequestType:
      | 'unknown'
      | 'connectionNameMetadataRequest'
      | 'parameterAutocompleteMetadataRequest'
      | 'postAuthSetupMetadataRequest'
      | 'propertyOptionsMetadataRequest'
      | 'getSyncTableSchemaMetadataRequest'
      | 'getDynamicSyncTableNameMetadataRequest'
      | 'listSyncTableDynamicUrlsMetadataRequest'
      | 'searchSyncTableDynamicUrlsMetadataRequest'
      | 'getDynamicSyncTableDisplayUrlMetadataRequest'
      | 'getIdentifiersForConnectionRequest'
      | 'invokeFormulaRequest'
      | 'invokeSyncFormulaRequest'
      | 'invokeSyncUpdateFormulaRequest'
    /** @enum {string} */
    PackLogType:
      | 'custom'
      | 'fetcher'
      | 'invocation'
      | 'internal'
      | 'auth'
      | 'ingestionLifecycle'
      | 'ingestionDebug'
    /** @enum {string} */
    LogLevel: 'error' | 'warn' | 'info' | 'debug' | 'trace' | 'unknown'
    /**
     * @deprecated
     * @description Only relevant for original Coda packs.
     * @enum {string}
     */
    FeatureSet: 'Basic' | 'Pro' | 'Team' | 'Enterprise'
    /**
     * @description Workspace feature set excluding free.
     * @enum {string}
     */
    PaidFeatureSet: 'Pro' | 'Team' | 'Enterprise'
    /**
     * @description Status of featured doc in pack listing.
     * @enum {string}
     */
    FeaturedDocStatus:
      | 'docInaccessibleOrDoesNotExist'
      | 'invalidPublishedDocUrl'
    PackFormulaIdentifier: {
      /**
       * @description The Pack formula name.
       * @example SquareRoot
       */
      name: string
      type: components['schemas']['PackFormulaType']
    }
    /** @enum {string} */
    PackFormulaType: 'action' | 'formula' | 'sync' | 'metadata'
    /**
     * @description Visibility of a pack's source code.
     * @enum {string}
     */
    PackSourceCodeVisibility: 'private' | 'shared'
    /**
     * @description Currency needed to subscribe to the Pack.
     * @enum {string}
     */
    PackPlanCurrency: 'USD'
    /**
     * @description Type of pricing used to subscribe to a Pack.
     * @enum {string}
     */
    PackPlanPricingType: 'Free' | 'MonthlyDocMaker' | 'BundledWithTier'
    /** @description Pricing used when workspaces can subscribe to the Pack for free. */
    FreePackPlanPricing: {
      /** @enum {string} */
      type: 'Free'
    }
    /** @description Pricing used when workspaces can subscribe to the Pack for a monthly cost per Doc Maker. */
    MonthlyDocMakerPackPlanPricing: {
      /** @enum {string} */
      type: 'MonthlyDocMaker'
      /** @description The monthly cost of the Pack per Doc Maker. */
      amount: number
      currency: components['schemas']['PackPlanCurrency']
    }
    /** @description Pricing used when workspaces have access to the Pack for free if their workspace is at least the given tier. */
    BundledPackPlanPricing: {
      /** @enum {string} */
      type: 'BundledWithTier'
      minimumFeatureSet: components['schemas']['PaidFeatureSet']
    }
    /** @description The Pack plan to show the Pack can be subscribed to at a monthly cost per Doc Maker or for free. */
    StandardPackPlan: {
      packPlanId: string
      packId: number
      /** @description Pricing to show how workspaces can subscribe to the Pack. */
      pricing:
        | components['schemas']['FreePackPlanPricing']
        | components['schemas']['MonthlyDocMakerPackPlanPricing']
      /**
       * Format: date-time
       * @description Timestamp for when the Pack plan was created.
       * @example 2018-04-11T00:18:57.946Z
       */
      createdAt: string
    }
    /** @description The Pack plan to show the Pack can be accessed if the workspace is at least the given tier. */
    BundledPackPlan: {
      packPlanId: string
      packId: number
      pricing: components['schemas']['BundledPackPlanPricing']
      /**
       * Format: date-time
       * @description Timestamp for when the Pack plan was created.
       * @example 2018-04-11T00:18:57.946Z
       */
      createdAt: string
    }
    /** @description The request to patch pack system connection credentials. */
    PatchPackSystemConnectionRequest:
      | components['schemas']['PackConnectionHeaderPatch']
      | components['schemas']['PackConnectionMultiHeaderPatch']
      | components['schemas']['PackConnectionUrlParamPatch']
      | components['schemas']['PackConnectionHttpBasicPatch']
      | components['schemas']['PackConnectionCustomPatch']
      | components['schemas']['PackConnectionOauth2ClientCredentialsPatch']
      | components['schemas']['PackConnectionGoogleServiceAccountPatch']
    /** @description Request to set the Pack OAuth configuration. */
    SetPackOauthConfigRequest: {
      clientId?: string
      clientSecret?: string
      redirectUri?: string
    }
    /** @description The request to set pack system connection credentials. */
    SetPackSystemConnectionRequest: {
      credentials: components['schemas']['PackSystemConnectionCredentials']
    }
    /** @description Payload for registering a Pack version. */
    RegisterPackVersionRequest: {
      /**
       * @description The SHA-256 hash of the file to be uploaded.
       * @example f0e4c2f76c58916ec258f246851bea091d14d4247a2fc3e18694461b1816e13b
       */
      bundleHash: string
    }
    /** @description Payload for updating a Pack. */
    UpdatePackRequest: {
      /** @description Rate limit in Pack settings. */
      overallRateLimit?: {
        /**
         * @description The rate limit interval in seconds.
         * @example 3600
         */
        intervalSeconds: number
        /**
         * @description The maximum number of Pack operations that can be performed in a given interval.
         * @example 20
         */
        operationsPerInterval: number
      } | null
      /** @description Rate limit in Pack settings. */
      perConnectionRateLimit?: {
        /**
         * @description The rate limit interval in seconds.
         * @example 3600
         */
        intervalSeconds: number
        /**
         * @description The maximum number of Pack operations that can be performed in a given interval.
         * @example 20
         */
        operationsPerInterval: number
      } | null
      /** @description The asset id of the Pack's logo, returned by [`#PackAssetUploadComplete`](#operation/packAssetUploadComplete) endpoint. */
      logoAssetId?: string | null
      /** @description The asset id of the Pack's cover image, returned by [`#PackAssetUploadComplete`](#operation/packAssetUploadComplete) endpoint. */
      coverAssetId?: string | null
      /** @description The example images for the Pack. */
      exampleImages?:
        | {
            /** @description The asset id of the Pack's example image, returned by [`#PackAssetUploadComplete`](#operation/packAssetUploadComplete) endpoint. */
            assetId: string
            /** @description The filename for the image. */
            filename: string
            /**
             * @description The media type of the image being sent.
             * @example image/jpeg
             */
            mimeType?: string
          }[]
        | null
      sourceCodeVisibility?: components['schemas']['PackSourceCodeVisibility']
      /**
       * @description The name of the Pack.
       * @example Cool Geometry Formulas
       */
      name?: string
      /**
       * @description The full description of the Pack.
       * @example This Pack allows users to calculate the surface area and volume of a few common 3D shapes, like cubes and pyramids.
       */
      description?: string
      /**
       * @description A short version of the description of the Pack.
       * @example Calculate cool geometric formulas like surface area.
       */
      shortDescription?: string
      /**
       * @description A contact email for the Pack.
       * @example user@email.com
       */
      supportEmail?: string
      /**
       * Format: url
       * @description A Terms of Service URL for the Pack.
       */
      termsOfServiceUrl?: string
      /**
       * Format: url
       * @description A Privacy Policy URL for the Pack.
       */
      privacyPolicyUrl?: string
    }
    /** @description Confirmation of successful Pack version creation. */
    CreatePackVersionResponse: {
      deprecationWarnings?: components['schemas']['ValidationError'][]
    }
    /** @description Confirmation of successful Pack deletion. */
    DeletePackResponse: Record<string, never>
    /** @description Confirmation of successfully retrieving Pack makers. */
    ListPackMakersResponse: {
      makers: components['schemas']['Maker'][]
    }
    /** @description Payload for adding a Pack maker. */
    AddPackMakerRequest: {
      /**
       * @description The email of the Pack maker.
       * @example api@coda.io
       */
      loginId: string
    }
    /** @description Confirmation of successfully adding a Pack maker. */
    AddPackMakerResponse: Record<string, never>
    /** @description Confirmation of successfully deleting a Pack maker. */
    DeletePackMakerResponse: Record<string, never>
    /** @description Confirmation of successfully retrieving Pack categories. */
    ListPackCategoriesResponse: {
      /** @description The names of categories associated with a Pack. */
      categories: components['schemas']['PublishingCategory'][]
    }
    /** @description Payload for adding a Pack Category. */
    AddPackCategoryRequest: {
      /**
       * @description Name of the publishing category.
       * @example Project management
       */
      categoryName: string
    }
    /** @description Confirmation of successfully adding a Pack category. */
    AddPackCategoryResponse: Record<string, never>
    /** @description Confirmation of successfully deleting a Pack category. */
    DeletePackCategoryResponse: Record<string, never>
    /** @description Payload for upserting a Pack permission. */
    AddPackPermissionRequest: {
      principal: components['schemas']['PackPrincipal']
      access: components['schemas']['PackAccessType']
    }
    /** @description Confirmation of successfully upserting a Pack permission. */
    AddPackPermissionResponse: {
      /** @description The ID of the permission created or updated. */
      permissionId: string
    }
    /** @description Confirmation of successfully deleting a Pack permission. */
    DeletePackPermissionResponse: Record<string, never>
    /** @description Payload for a Pack asset upload. */
    UploadPackAssetRequest: {
      packAssetType: components['schemas']['PackAssetType']
      /**
       * @description The SHA-256 hash of the image to be uploaded.
       * @example f0e4c2f76c58916ec258f246851bea091d14d4247a2fc3e18694461b1816e13b
       */
      imageHash: string
      /**
       * @description The media type of the image being sent.
       * @example image/jpeg
       */
      mimeType: string
      /** @example image.jpg */
      filename: string
    }
    /** @description Payload for noting a Pack asset upload is complete. */
    PackAssetUploadCompleteRequest: {
      packAssetType: components['schemas']['PackAssetType']
    }
    /** @description Response for noting a Pack asset upload is complete. */
    PackAssetUploadCompleteResponse: {
      /**
       * @description An arbitrary unique identifier for this request.
       * @example abc-123-def-456
       */
      requestId: string
      /**
       * @description An identifier of this uploaded asset.
       * @example e23fcb5e564f08b71183d424c2c380c0
       */
      assetId: string
    }
    /** @description Payload for noting a Pack source code upload is complete. */
    PackSourceCodeUploadCompleteRequest: {
      /** @example main.ts */
      filename: string
      /**
       * @description A SHA-256 hash of the source code used to identify duplicate uploads.
       * @example 123456
       */
      codeHash: string
    }
    /** @description Response for noting a Pack source code upload is complete. */
    PackSourceCodeUploadCompleteResponse: {
      /**
       * @description An arbitrary unique identifier for this request.
       * @example abc-123-def-456
       */
      requestId: string
    }
    /** @description Payload for Pack version upload complete. */
    CreatePackVersionRequest: {
      /**
       * @description Developer notes of the new Pack version.
       * @example Adding a new formula HelloWorld.
       */
      notes?: string
      source?: components['schemas']['PackSource']
      /** @description Bypass Coda's protection against SDK version regression when multiple makers build versions. */
      allowOlderSdkVersion?: boolean
    }
    /** @description Payload for creating a new Pack release. */
    CreatePackReleaseRequest: {
      /**
       * @description Which semantic pack version that the release will be created on.
       * @example 1.0.0
       */
      packVersion: string
      /**
       * @description Developers notes.
       * @example The first release.
       */
      releaseNotes?: string
    }
    /** @description Payload for updating a new Pack release. */
    UpdatePackReleaseRequest: {
      /**
       * @description Notes about key features or changes in this release that the Pack maker wants to communicate to users.
       * @example The first release.
       */
      releaseNotes?: string
    }
    /** @description Payload for a Pack asset upload. */
    UploadPackSourceCodeRequest: {
      /**
       * @description The SHA-256 hash of the image to be uploaded.
       * @example f0e4c2f76c58916ec258f246851bea091d14d4247a2fc3e18694461b1816e13b
       */
      payloadHash: string
      /** @example main.ts */
      filename: string
      /** @example 1.0.0 */
      packVersion?: string
    }
    /** @description Information indicating the next Pack version definition. */
    NextPackVersionInfo: {
      /**
       * @description The next valid version for the Pack.
       * @example 2.1.0
       */
      nextVersion: string
      /** @description List of changes from the previous version. */
      findings: string[]
    }
    /** @description Info about the diff between two Pack versions. */
    PackVersionDiffs: {
      /** @description List of changes from the previous version to the next version. */
      findings: string[]
    }
    /** @description A Pack's featured doc. */
    PackFeaturedDoc: {
      doc: components['schemas']['DocReference']
      /** @description Whether or not this featured doc is pinned. */
      isPinned: boolean
      docStatus?: components['schemas']['FeaturedDocStatus']
      /**
       * Format: url
       * @description The URL of the published doc, if available.
       */
      publishedUrl?: string
    }
    /** @description Item representing a featured doc in the update Pack featured docs request. */
    PackFeaturedDocRequestItem: {
      /** @description A URL to a doc. */
      url: string
      /** @description Whether or not the current doc should be pinned. */
      isPinned?: boolean
    }
    /** @description Payload for updating featured docs for a Pack. */
    UpdatePackFeaturedDocsRequest: {
      /** @description A list of docs to set as the featured docs for a Pack. */
      items: components['schemas']['PackFeaturedDocRequestItem'][]
    }
    /** @description Confirmation of successful Pack featured docs update. */
    UpdatePackFeaturedDocsResponse: Record<string, never>
    /** @description List of a Pack's featured docs. */
    PackFeaturedDocsResponse: {
      /** @description A list of featured docs for the Pack. */
      items: components['schemas']['PackFeaturedDoc'][]
    }
    /** @description JSON schema response. */
    GetPackConfigurationJsonSchemaResponse: {
      [key: string]: unknown
    }
    /** @description Context that comes with a ingestion execution. */
    IngestionExecutionContext: {
      ingestionName: string | null
      csbIngestionExecutionId: string
      /** @description Creation time of the ingestion execution in seconds since epoch. */
      creationTimestamp: number
      parentItemId: string | null
    }
  }
  responses: {
    /** @description The request parameters did not conform to expectations. */
    BadRequestError: {
      content: {
        'application/json': {
          /**
           * @description HTTP status code of the error.
           * @example 400
           */
          statusCode: number
          /**
           * @description HTTP status message of the error.
           * @example Bad Request
           */
          statusMessage: string
          /**
           * @description Any additional context on the error, or the same as `statusMessage` otherwise.
           * @example Bad Request
           */
          message: string
        }
      }
    }
    /** @description The request parameters did not conform to expectations. */
    BadRequestWithValidationErrors: {
      content: {
        'application/json': {
          /**
           * @description HTTP status code of the error.
           * @example 400
           */
          statusCode: number
          /**
           * @description HTTP status message of the error.
           * @example Bad Request
           */
          statusMessage: string
          /**
           * @description Any additional context on the error, or the same as `statusMessage` otherwise.
           * @example Bad Request
           */
          message: string
          /** @description Detail about why this request was rejected. */
          codaDetail?: {
            validationErrors?: components['schemas']['ValidationError'][]
          }
        }
      }
    }
    /** @description The API token is invalid or has expired. */
    UnauthorizedError: {
      content: {
        'application/json': {
          /**
           * @description HTTP status code of the error.
           * @example 401
           */
          statusCode: number
          /**
           * @description HTTP status message of the error.
           * @example Unauthorized
           */
          statusMessage: string
          /**
           * @description Any additional context on the error, or the same as `statusMessage` otherwise.
           * @example Unauthorized
           */
          message: string
        }
      }
    }
    /** @description The API token does not grant access to this resource. */
    ForbiddenError: {
      content: {
        'application/json': {
          /**
           * @description HTTP status code of the error.
           * @example 403
           */
          statusCode: number
          /**
           * @description HTTP status message of the error.
           * @example Forbidden
           */
          statusMessage: string
          /**
           * @description Any additional context on the error, or the same as `statusMessage` otherwise.
           * @example Forbidden
           */
          message: string
        }
      }
    }
    /** @description The resource could not be located with the current API token. */
    NotFoundError: {
      content: {
        'application/json': {
          /**
           * @description HTTP status code of the error.
           * @example 404
           */
          statusCode: number
          /**
           * @description HTTP status message of the error.
           * @example Not Found
           */
          statusMessage: string
          /**
           * @description Any additional context on the error, or the same as `statusMessage` otherwise.
           * @example Not Found
           */
          message: string
        }
      }
    }
    /** @description The resource has been deleted. */
    GoneError: {
      content: {
        'application/json': {
          /**
           * @description HTTP status code of the error.
           * @example 410
           */
          statusCode: number
          /**
           * @description HTTP status message of the error.
           * @example Gone
           */
          statusMessage: string
          /**
           * @description Any additional context on the error, or the same as `statusMessage` otherwise.
           * @example Gone
           */
          message: string
        }
      }
    }
    /** @description Unable to process the request. */
    UnprocessableEntityError: {
      content: {
        'application/json': {
          /**
           * @description HTTP status code of the error.
           * @example 422
           */
          statusCode: number
          /**
           * @description HTTP status message of the error.
           * @example Unprocessable Entity
           */
          statusMessage: string
          /**
           * @description Any additional context on the error, or the same as `statusMessage` otherwise.
           * @example Unprocessable Entity
           */
          message: string
        }
      }
    }
    /** @description The client has sent too many requests. */
    TooManyRequestsError: {
      content: {
        'application/json': {
          /**
           * @description HTTP status code of the error.
           * @example 429
           */
          statusCode: number
          /**
           * @description HTTP status message of the error.
           * @example Too Many Requests
           */
          statusMessage: string
          /**
           * @description Any additional context on the error, or the same as `statusMessage` otherwise.
           * @example Too Many Requests
           */
          message: string
        }
      }
    }
  }
  parameters: {
    /**
     * @description Maximum number of results to return in this query.
     * @example 10
     */
    limit?: number
    /**
     * @description An opaque token used to fetch the next page of results.
     * @example eyJsaW1pd
     */
    pageToken?: string
    /**
     * @description An opaque token returned from a previous call that can be used to return results that are relevant to the query since the call where the syncToken was generated.
     *
     * @example eyJsaW1pd
     */
    syncToken?: string
    /**
     * @description ID of the doc.
     * @example AbCDeFGH
     */
    docId: string
    /** @description List of docIds to fetch. */
    docIds?: string[]
    /**
     * @description Search term used to filter down results.
     * @example Supercalifragilisticexpialidocious
     */
    query?: string
    /**
     * @description ID of a permission on a doc.
     * @example AbCDeFGH
     */
    permissionId: string
    /**
     * @description ID or name of the page. Names are discouraged because they're easily prone to being changed by users. If you're using a name, be sure to URI-encode it. If you provide a name and there are multiple pages with the same name, an arbitrary one will be selected.
     *
     * @example canvas-IjkLmnO
     */
    pageIdOrName: string
    /**
     * @description ID or name of the table. Names are discouraged because they're easily prone to being changed by users. If you're using a name, be sure to URI-encode it.
     * @example grid-pqRst-U
     */
    tableIdOrName: string
    /**
     * @description ID or name of the view. Names are discouraged because they're easily prone to being changed by users. If you're using a name, be sure to URI-encode it.
     * @example table-pqRst-U
     */
    viewIdOrName: string
    /**
     * @description ID or name of the column. Names are discouraged because they're easily prone to being changed by users. If you're using a name, be sure to URI-encode it.
     * @example c-tuVwxYz
     */
    columnIdOrName: string
    /**
     * @description ID or name of the row. Names are discouraged because they're easily prone to being changed by users. If you're using a name, be sure to URI-encode it. If there are multiple rows with the same value in the identifying column, an arbitrary one will be selected.
     *
     * @example i-tuVwxYz
     */
    rowIdOrName: string
    /**
     * @description ID or name of the formula. Names are discouraged because they're easily prone to being changed by users. If you're using a name, be sure to URI-encode it.
     * @example f-fgHijkLm
     */
    formulaIdOrName: string
    /**
     * @description ID or name of the control. Names are discouraged because they're easily prone to being changed by users. If you're using a name, be sure to URI-encode it.
     * @example ctrl-cDefGhij
     */
    controlIdOrName: string
    /**
     * @description Use column names instead of column IDs in the returned output. This is generally discouraged as it is fragile. If columns are renamed, code using original names may throw errors.
     *
     * @example true
     */
    useColumnNames?: boolean
    /**
     * @description Determines how to sort the given objects.
     * @example name
     */
    sortBy?: components['schemas']['SortBy']
    /**
     * @description ID of the request.
     * @example abc-123-def-456
     */
    requestId: string
    /**
     * @description ID of the automation rule.
     * @example grid-auto-b3Jmey6jBS
     */
    ruleId: string
    /**
     * @description Comma-separated list of table types to include in results. If omitted, includes both tables and views.
     * @example table,view
     */
    tableTypes?: components['schemas']['TableType'][]
    /**
     * @description ID of the workspace.
     * @example ws-1Ab234
     */
    workspaceId: string
    /**
     * @description ID of the workspace.
     * @example ws-1Ab234
     */
    workspaceIdInQuery?: string
    /**
     * @description Show only members that have the included roles specified in a comma-separated list.
     * @example Editor,DocMaker
     */
    includedRoles?: components['schemas']['WorkspaceUserRole'][]
    /**
     * @description ID of a Pack
     * @example 123
     */
    packId: number
    /**
     * @description Email of a Coda user.
     * @example api@coda.io
     */
    loginId: string
    /**
     * @description Name of a publishing category
     * @example Project management
     */
    categoryName: string
    /**
     * @description Semantic version of a Pack
     * @example 1.2.3
     */
    packVersion: string
    /**
     * @description Semantic version of the previous Pack version.
     * @example 1.2.3
     */
    basePackVersion: string
    /**
     * @description Semantic version of the new Pack version.
     * @example 1.2.3
     */
    targetPackVersion: string
    /** @description Unique identifier for a Pack asset. */
    packAssetId: string
    /** @description Pack asset type. */
    packAssetType: components['schemas']['PackAssetType']
    /** @description Pack access types. */
    packAccessTypes?: components['schemas']['PackAccessTypes']
    /** @description Which Pack IDs to fetch. */
    packIds?: number[]
    /** @description Only get Packs shared with users/workspaces, not publicly. */
    excludePublicPacks?: boolean
    /** @description Do not include Packs that are only shared with workspaces. */
    excludeWorkspaceAcls?: boolean
    /** @description Do not include Packs that are only shared with the user individually. */
    excludeIndividualAcls?: boolean
    /** @description Use only this workspace (not all of a user's workspaces) to check for Packs shared via workspace ACL. */
    onlyWorkspaceId?: string
    /** @description Filter to only Packs whose parent workspace is one of the given IDs. */
    parentWorkspaceIds?: string[]
    /** @description Direction to sort results in. */
    direction?: components['schemas']['SortDirection']
    /** @description Limit results to only published items. */
    isPublished?: boolean
    /** @description Show only docs owned by the user. */
    isOwner?: boolean
    /**
     * @description Limit results to activity on or after this date.
     * @example 2020-08-01
     */
    sinceDate?: string
    /**
     * @description Limit results to activity on or before this date.
     * @example 2020-08-05
     */
    untilDate?: string
    /**
     * @description Quantization period over which to view analytics. Defaults to daily.
     * @example daily
     */
    scale?: components['schemas']['AnalyticsScale']
    /** @description Use this parameter to order the doc analytics returned. */
    docAnalyticsOrderBy?: components['schemas']['DocAnalyticsOrderBy']
    /** @description Use this parameter to order the Pack analytics returned. */
    packAnalyticsOrderBy?: components['schemas']['PackAnalyticsOrderBy']
    /** @description Use this parameter to order the Pack formula analytics returned. */
    packFormulaAnalyticsOrderBy?: components['schemas']['PackFormulaAnalyticsOrderBy']
    /** @description A custom domain for a published doc. */
    customDocDomain: string
    /** @description Limit results to only published items. If false or unspecified, returns all items including published ones. */
    isPublishedNoDefault?: boolean
    /**
     * @description ID of a Pack release
     * @example 2
     */
    packReleaseId: number
    /**
     * @description ID of the root ingestion.
     * @example a4e293c4-4a85-45a4-b2ba-7f305cba2703
     */
    rootIngestionId: string
    /**
     * @description ID of the ingestion execution.
     * @example a4e293c4-4a85-45a4-b2ba-7f305cba2703
     */
    ingestionExecutionId: string
    /**
     * @description ID of the organization.
     * @example org-LxmbD9y2EU
     */
    organizationId: string
  }
  requestBodies: never
  headers: never
  pathItems: never
}

export type $defs = Record<string, never>

export type external = Record<string, never>

export interface operations {
  /**
   * Get doc categories
   * @description Gets all available doc categories.
   */
  listCategories: {
    responses: {
      /** @description List of doc categories */
      200: {
        content: {
          'application/json': components['schemas']['DocCategoryList']
        }
      }
      401: components['responses']['UnauthorizedError']
      404: components['responses']['NotFoundError']
      429: components['responses']['TooManyRequestsError']
    }
  }
  /**
   * List available docs
   * @description Returns a list of Coda docs accessible by the user. These are returned in the same order as on the docs page: reverse chronological by the latest event relevant to the user (last viewed, edited, or shared).
   */
  listDocs: {
    parameters: {
      query?: {
        /** @description Show only docs owned by the user. */
        isOwner?: boolean
        /** @description Show only published docs. */
        isPublished?: boolean
        query?: components['parameters']['query']
        /** @description Show only docs copied from the specified doc ID. */
        sourceDoc?: string
        /** @description If true, returns docs that are starred. If false, returns docs that are not starred. */
        isStarred?: boolean
        /** @description Show only docs visible within the gallery. */
        inGallery?: boolean
        /** @description Show only docs belonging to the given workspace. */
        workspaceId?: string
        /** @description Show only docs belonging to the given folder. */
        folderId?: string
        limit?: components['parameters']['limit']
        pageToken?: components['parameters']['pageToken']
      }
    }
    responses: {
      /** @description List of Coda docs matching the query. */
      200: {
        content: {
          'application/json': components['schemas']['DocList']
        }
      }
      401: components['responses']['UnauthorizedError']
      403: components['responses']['ForbiddenError']
      404: components['responses']['NotFoundError']
      429: components['responses']['TooManyRequestsError']
    }
  }
  /**
   * Create doc
   * @description Creates a new Coda doc, optionally copying an existing doc. Note that creating a doc requires you to be a Doc Maker in the applicable workspace (or be auto-promoted to one).
   */
  createDoc: {
    /** @description Parameters for creating the doc. */
    requestBody: {
      content: {
        'application/json': components['schemas']['DocCreate']
      }
    }
    responses: {
      /** @description Info about the created doc. */
      201: {
        content: {
          'application/json': components['schemas']['DocumentCreationResult']
        }
      }
      400: components['responses']['BadRequestError']
      401: components['responses']['UnauthorizedError']
      403: components['responses']['ForbiddenError']
      429: components['responses']['TooManyRequestsError']
    }
  }
  /**
   * Get info about a doc
   * @description Returns metadata for the specified doc.
   */
  getDoc: {
    parameters: {
      path: {
        docId: components['parameters']['docId']
      }
    }
    responses: {
      /** @description Basic Coda doc metadata. */
      200: {
        content: {
          'application/json': components['schemas']['Doc']
        }
      }
      401: components['responses']['UnauthorizedError']
      403: components['responses']['ForbiddenError']
      404: components['responses']['NotFoundError']
      429: components['responses']['TooManyRequestsError']
    }
  }
  /**
   * Delete doc
   * @description Deletes a doc.
   */
  deleteDoc: {
    parameters: {
      path: {
        docId: components['parameters']['docId']
      }
    }
    responses: {
      /** @description A result indicating that the doc was deleted. */
      202: {
        content: {
          'application/json': components['schemas']['DocDelete']
        }
      }
      401: components['responses']['UnauthorizedError']
      403: components['responses']['ForbiddenError']
      404: components['responses']['NotFoundError']
      429: components['responses']['TooManyRequestsError']
    }
  }
  /**
   * Update doc
   * @description Updates metadata for a doc. Note that updating a doc title requires you to be a Doc Maker in the applicable workspace.
   */
  updateDoc: {
    parameters: {
      path: {
        docId: components['parameters']['docId']
      }
    }
    /** @description Parameters for updating the doc. */
    requestBody: {
      content: {
        'application/json': components['schemas']['DocUpdate']
      }
    }
    responses: {
      /** @description Basic Coda doc metadata. */
      200: {
        content: {
          'application/json': components['schemas']['DocUpdateResult']
        }
      }
      400: components['responses']['BadRequestError']
      401: components['responses']['UnauthorizedError']
      403: components['responses']['ForbiddenError']
      404: components['responses']['NotFoundError']
      429: components['responses']['TooManyRequestsError']
    }
  }
  /**
   * Get sharing metadata
   * @description Returns metadata associated with sharing for this Coda doc.
   */
  getSharingMetadata: {
    parameters: {
      path: {
        docId: components['parameters']['docId']
      }
    }
    responses: {
      /** @description Metadata associated with sharing permissions for a doc. */
      200: {
        content: {
          'application/json': components['schemas']['AclMetadata']
        }
      }
      401: components['responses']['UnauthorizedError']
      403: components['responses']['ForbiddenError']
      404: components['responses']['NotFoundError']
      429: components['responses']['TooManyRequestsError']
    }
  }
  /**
   * List permissions
   * @description Returns a list of permissions for this Coda doc.
   */
  getPermissions: {
    parameters: {
      query?: {
        limit?: components['parameters']['limit']
        pageToken?: components['parameters']['pageToken']
      }
      path: {
        docId: components['parameters']['docId']
      }
    }
    responses: {
      /** @description List of permissions for a doc. */
      200: {
        content: {
          'application/json': components['schemas']['Acl']
        }
      }
      401: components['responses']['UnauthorizedError']
      403: components['responses']['ForbiddenError']
      404: components['responses']['NotFoundError']
      429: components['responses']['TooManyRequestsError']
    }
  }
  /**
   * Add permission
   * @description Adds a new permission to the doc.
   */
  addPermission: {
    parameters: {
      path: {
        docId: components['parameters']['docId']
      }
    }
    /** @description Parameters for adding the new permission. */
    requestBody: {
      content: {
        'application/json': components['schemas']['AddPermissionRequest']
      }
    }
    responses: {
      /** @description Confirmation that the request was applied. */
      200: {
        content: {
          'application/json': components['schemas']['AddPermissionResult']
        }
      }
      400: components['responses']['BadRequestError']
      401: components['responses']['UnauthorizedError']
      403: components['responses']['ForbiddenError']
      404: components['responses']['NotFoundError']
      429: components['responses']['TooManyRequestsError']
    }
  }
  /**
   * Delete permission
   * @description Deletes an existing permission.
   */
  deletePermission: {
    parameters: {
      path: {
        docId: components['parameters']['docId']
        permissionId: components['parameters']['permissionId']
      }
    }
    responses: {
      /** @description Confirmation that the request was applied. */
      200: {
        content: {
          'application/json': components['schemas']['DeletePermissionResult']
        }
      }
      400: components['responses']['BadRequestError']
      401: components['responses']['UnauthorizedError']
      403: components['responses']['ForbiddenError']
      404: components['responses']['NotFoundError']
      429: components['responses']['TooManyRequestsError']
    }
  }
  /**
   * Search principals
   * @description Searches for user and group principals matching the query that this doc can be shared with.
   * At most 20 results will be returned for both users and groups. If no query is given then no results are returned.
   */
  searchPrincipals: {
    parameters: {
      query?: {
        query?: components['parameters']['query']
      }
      path: {
        docId: components['parameters']['docId']
      }
    }
    responses: {
      /** @description Search results for the given query. */
      200: {
        content: {
          'application/json': components['schemas']['SearchPrincipalsResponse']
        }
      }
      400: components['responses']['BadRequestError']
      401: components['responses']['UnauthorizedError']
      403: components['responses']['ForbiddenError']
      404: components['responses']['NotFoundError']
      429: components['responses']['TooManyRequestsError']
    }
  }
  /**
   * Get ACL settings
   * @description Returns settings associated with ACLs for this Coda doc.
   */
  getAclSettings: {
    parameters: {
      path: {
        docId: components['parameters']['docId']
      }
    }
    responses: {
      /** @description Settings associated with access control for a doc. */
      200: {
        content: {
          'application/json': components['schemas']['AclSettings']
        }
      }
      401: components['responses']['UnauthorizedError']
      403: components['responses']['ForbiddenError']
      404: components['responses']['NotFoundError']
      429: components['responses']['TooManyRequestsError']
    }
  }
  /**
   * Update ACL settings
   * @description Update settings associated with ACLs for this Coda doc.
   */
  updateAclSettings: {
    parameters: {
      path: {
        docId: components['parameters']['docId']
      }
    }
    /** @description Parameters for updating the ACL settings. */
    requestBody: {
      content: {
        'application/json': components['schemas']['UpdateAclSettingsRequest']
      }
    }
    responses: {
      /** @description Settings associated with access control for a doc. */
      200: {
        content: {
          'application/json': components['schemas']['AclSettings']
        }
      }
      401: components['responses']['UnauthorizedError']
      403: components['responses']['ForbiddenError']
      404: components['responses']['NotFoundError']
      429: components['responses']['TooManyRequestsError']
    }
  }
  /**
   * Publish doc
   * @description Update publish settings for a doc.
   */
  publishDoc: {
    parameters: {
      path: {
        docId: components['parameters']['docId']
      }
    }
    /** @description Parameters for changing publish settings. */
    requestBody: {
      content: {
        'application/json': components['schemas']['DocPublish']
      }
    }
    responses: {
      /** @description Confirmation that the publish request was accepted. */
      202: {
        content: {
          'application/json': components['schemas']['PublishResult']
        }
      }
      400: components['responses']['BadRequestError']
      401: components['responses']['UnauthorizedError']
      403: components['responses']['ForbiddenError']
      404: components['responses']['NotFoundError']
      429: components['responses']['TooManyRequestsError']
    }
  }
  /**
   * Unpublish doc
   * @description Unpublishes a doc.
   */
  unpublishDoc: {
    parameters: {
      path: {
        docId: components['parameters']['docId']
      }
    }
    responses: {
      /** @description A result indicating that the doc was unpublished. */
      200: {
        content: {
          'application/json': components['schemas']['UnpublishResult']
        }
      }
      401: components['responses']['UnauthorizedError']
      403: components['responses']['ForbiddenError']
      404: components['responses']['NotFoundError']
      429: components['responses']['TooManyRequestsError']
    }
  }
  /**
   * List pages
   * @description Returns a list of pages in a Coda doc.
   */
  listPages: {
    parameters: {
      query?: {
        limit?: components['parameters']['limit']
        pageToken?: components['parameters']['pageToken']
      }
      path: {
        docId: components['parameters']['docId']
      }
    }
    responses: {
      /** @description List of pages. */
      200: {
        content: {
          'application/json': components['schemas']['PageList']
        }
      }
      401: components['responses']['UnauthorizedError']
      403: components['responses']['ForbiddenError']
      404: components['responses']['NotFoundError']
      429: components['responses']['TooManyRequestsError']
    }
  }
  /**
   * Create a page
   * @description Create a new page in a doc. Note that creating a page requires you to be a Doc Maker in the applicable workspace.
   */
  createPage: {
    parameters: {
      path: {
        docId: components['parameters']['docId']
      }
    }
    /** @description Parameters for creating a page. */
    requestBody: {
      content: {
        'application/json': components['schemas']['PageCreate']
      }
    }
    responses: {
      /** @description A result indicating that the creation request was queued for processing. */
      202: {
        content: {
          'application/json': components['schemas']['PageCreateResult']
        }
      }
      400: components['responses']['BadRequestError']
      401: components['responses']['UnauthorizedError']
      403: components['responses']['ForbiddenError']
      404: components['responses']['NotFoundError']
      429: components['responses']['TooManyRequestsError']
    }
  }
  /**
   * Get a page
   * @description Returns details about a page.
   */
  getPage: {
    parameters: {
      path: {
        docId: components['parameters']['docId']
        pageIdOrName: components['parameters']['pageIdOrName']
      }
    }
    responses: {
      /** @description Info about a page. */
      200: {
        content: {
          'application/json': components['schemas']['Page']
        }
      }
      401: components['responses']['UnauthorizedError']
      403: components['responses']['ForbiddenError']
      404: components['responses']['NotFoundError']
      410: components['responses']['GoneError']
      429: components['responses']['TooManyRequestsError']
    }
  }
  /**
   * Update a page
   * @description Update properties for a page. Note that updating a page title or icon requires you to be a Doc Maker in the applicable workspace.
   */
  updatePage: {
    parameters: {
      path: {
        docId: components['parameters']['docId']
        pageIdOrName: components['parameters']['pageIdOrName']
      }
    }
    /** @description Parameters for updating a page. */
    requestBody: {
      content: {
        'application/json': components['schemas']['PageUpdate']
      }
    }
    responses: {
      /** @description A result indicating that the update was queued for processing. */
      202: {
        content: {
          'application/json': components['schemas']['PageUpdateResult']
        }
      }
      400: components['responses']['BadRequestError']
      401: components['responses']['UnauthorizedError']
      403: components['responses']['ForbiddenError']
      404: components['responses']['NotFoundError']
      429: components['responses']['TooManyRequestsError']
    }
  }
  /**
   * Delete a page
   * @description Deletes the specified page.
   */
  deletePage: {
    parameters: {
      path: {
        docId: components['parameters']['docId']
        pageIdOrName: components['parameters']['pageIdOrName']
      }
    }
    responses: {
      /** @description A result indicating that the delete was queued for processing. */
      202: {
        content: {
          'application/json': components['schemas']['PageDeleteResult']
        }
      }
      400: components['responses']['BadRequestError']
      401: components['responses']['UnauthorizedError']
      403: components['responses']['ForbiddenError']
      404: components['responses']['NotFoundError']
      429: components['responses']['TooManyRequestsError']
    }
  }
  /**
   * Begin content export
   * @description Initiate an export of content for the given page.
   */
  beginPageContentExport: {
    parameters: {
      path: {
        docId: components['parameters']['docId']
        pageIdOrName: components['parameters']['pageIdOrName']
      }
    }
    /** @description Parameters for requesting a page content export. */
    requestBody: {
      content: {
        'application/json': components['schemas']['BeginPageContentExportRequest']
      }
    }
    responses: {
      /** @description Export page content response. */
      202: {
        content: {
          'application/json': components['schemas']['BeginPageContentExportResponse']
        }
      }
      400: components['responses']['BadRequestError']
      401: components['responses']['UnauthorizedError']
      403: components['responses']['ForbiddenError']
      404: components['responses']['NotFoundError']
      410: components['responses']['GoneError']
      429: components['responses']['TooManyRequestsError']
    }
  }
  /**
   * Content export status
   * @description Check the status of a page content export
   */
  getPageContentExportStatus: {
    parameters: {
      path: {
        docId: components['parameters']['docId']
        pageIdOrName: components['parameters']['pageIdOrName']
        requestId: components['parameters']['requestId']
      }
    }
    responses: {
      /** @description Info about the page content export request. */
      200: {
        content: {
          'application/json': components['schemas']['PageContentExportStatusResponse']
        }
      }
      401: components['responses']['UnauthorizedError']
      403: components['responses']['ForbiddenError']
      404: components['responses']['NotFoundError']
      410: components['responses']['GoneError']
      429: components['responses']['TooManyRequestsError']
    }
  }
  /**
   * List tables
   * @description Returns a list of tables in a Coda doc.
   */
  listTables: {
    parameters: {
      query?: {
        limit?: components['parameters']['limit']
        pageToken?: components['parameters']['pageToken']
        sortBy?: components['parameters']['sortBy']
        tableTypes?: components['parameters']['tableTypes']
      }
      path: {
        docId: components['parameters']['docId']
      }
    }
    responses: {
      /** @description List of tables or views in a doc. */
      200: {
        content: {
          'application/json': components['schemas']['TableList']
        }
      }
      401: components['responses']['UnauthorizedError']
      403: components['responses']['ForbiddenError']
      404: components['responses']['NotFoundError']
      429: components['responses']['TooManyRequestsError']
    }
  }
  /**
   * Get a table
   * @description Returns details about a specific table or view.
   */
  getTable: {
    parameters: {
      query?: {
        /** @description Return "detail" and "form" for the `layout` field of detail and form layouts respectively (instead of "masterDetail" for both) */
        useUpdatedTableLayouts?: boolean
      }
      path: {
        docId: components['parameters']['docId']
        tableIdOrName: components['parameters']['tableIdOrName']
      }
    }
    responses: {
      /** @description Info about a table. */
      200: {
        content: {
          'application/json': components['schemas']['Table']
        }
      }
      401: components['responses']['UnauthorizedError']
      403: components['responses']['ForbiddenError']
      404: components['responses']['NotFoundError']
      429: components['responses']['TooManyRequestsError']
    }
  }
  /**
   * List columns
   * @description Returns a list of columns in a table.
   */
  listColumns: {
    parameters: {
      query?: {
        limit?: components['parameters']['limit']
        pageToken?: components['parameters']['pageToken']
        /**
         * @description If true, returns only visible columns for the table. This parameter only applies to base tables, and not views.
         * @example true
         */
        visibleOnly?: boolean
      }
      path: {
        docId: components['parameters']['docId']
        tableIdOrName: components['parameters']['tableIdOrName']
      }
    }
    responses: {
      /** @description List of columns in the table. */
      200: {
        content: {
          'application/json': components['schemas']['ColumnList']
        }
      }
      401: components['responses']['UnauthorizedError']
      403: components['responses']['ForbiddenError']
      404: components['responses']['NotFoundError']
      429: components['responses']['TooManyRequestsError']
    }
  }
  /**
   * List table rows
   * @description Returns a list of rows in a table.
   * ### Value results
   * The `valueFormat` parameter dictates in what format the API should return values for individual cells.
   * * `simple` (default): Returns cell values as the following JSON values: `string`, `number`, or `boolean`. Array values (like multiselects) are returned as comma-delimited strings.
   * * `simpleWithArrays`: Singleton values are returned as `simple`. Array values are returned as JSON arrays and the values within are `simple` values (including nested arrays).
   * * `rich`: If applicable, returns many values with further encoding, allowing API users to have lossless access to data in Coda.
   *   * For `text` values, returns data in Markdown syntax. If the text field is simple text (e.g. has no formatting),
   *   the field will be fully escaped with triple-ticks. E.g
   *   `
   *   ```This is plain text```
   *   `
   *   * For `currency`, `lookup`, `image`, `person` and `hyperlink` values, the value will be encoded in [JSON-LD](https://json-ld.org/) format.
   *
   * ```
   *   // Currency
   *   {
   *     "@context": "http://schema.org",
   *     "@type": "MonetaryAmount",
   *     "currency": "USD",
   *     "amount": 42.42
   *   }
   *
   *   // Lookup
   *   {
   *     "@context": "http://schema.org",
   *     "@type": "StructuredValue",
   *     "additionalType": "row",
   *     "name": "Row Name",
   *     "rowId": "i-123456789",
   *     "tableId": "grid-123456789",
   *     "tableUrl": "https://coda.io/d/_d123456789/grid-123456789",
   *     "url": "https://coda.io/d/_d123456789/grid-123456789#_r42",
   *   }
   *
   *   // Hyperlink
   *   {
   *     "@context": "http://schema.org",
   *     "@type": "WebPage",
   *     "name": "Coda",
   *     "url": "https://coda.io"
   *   }
   *
   *   // Image
   *   {
   *     "@context": "http://schema.org",
   *     "@type": "ImageObject",
   *     "name": "Coda logo",
   *     "url": "https://coda.io/logo.jpg"
   *   }
   *
   *   // People
   *   {
   *     "@context": "http://schema.org",
   *     "@type": "Person",
   *     "name": "Art Vandalay",
   *     "email": "art@vandalayindustries.com"
   *   }
   * ```
   */
  listRows: {
    parameters: {
      query?: {
        /**
         * @description Query used to filter returned rows, specified as `<column_id_or_name>:<value>`. If you'd like to use a column name instead of an ID, you must quote it (e.g., `"My Column":123`). Also note that `value` is a JSON value; if you'd like to use a string, you must surround it in quotes (e.g., `"groceries"`).
         *
         * @example c-tuVwxYz:"Apple"
         */
        query?: string
        /** @description Specifies the sort order of the rows returned. If left unspecified, rows are returned by creation time ascending. "UpdatedAt" sort ordering is the order of rows based upon when they were last updated. This does not include updates to calculated values. "Natural" sort ordering is the order that the rows appear in the table view in the application. This ordering is only meaningfully defined for rows that are visible (unfiltered). Because of this, using this sort order will imply visibleOnly=true, that is, to only return visible rows. If you pass sortBy=natural and visibleOnly=false explicitly, this will result in a Bad Request error as this condition cannot be satisfied. */
        sortBy?: components['schemas']['RowsSortBy']
        useColumnNames?: components['parameters']['useColumnNames']
        /** @description The format that cell values are returned as. */
        valueFormat?: components['schemas']['ValueFormat']
        /**
         * @description If true, returns only visible rows and columns for the table.
         * @example true
         */
        visibleOnly?: boolean
        limit?: components['parameters']['limit']
        pageToken?: components['parameters']['pageToken']
        syncToken?: components['parameters']['syncToken']
      }
      path: {
        docId: components['parameters']['docId']
        tableIdOrName: components['parameters']['tableIdOrName']
      }
    }
    responses: {
      /** @description List of rows in the table. */
      200: {
        content: {
          'application/json': components['schemas']['RowList']
        }
      }
      400: components['responses']['BadRequestError']
      401: components['responses']['UnauthorizedError']
      403: components['responses']['ForbiddenError']
      404: components['responses']['NotFoundError']
      429: components['responses']['TooManyRequestsError']
    }
  }
  /**
   * Insert/upsert rows
   * @description Inserts rows into a table, optionally updating existing rows if any upsert key columns are provided. This endpoint will always return a 202, so long as the doc and table exist and are accessible (and the update is structurally valid). Row inserts/upserts are generally processed within several seconds. Note: this endpoint only works for base tables, not views.
   * When upserting, if multiple rows match the specified key column(s), they will all be updated with the specified value.
   */
  upsertRows: {
    parameters: {
      query?: {
        /**
         * @description If true, the API will not attempt to parse the data in any way.
         * @example true
         */
        disableParsing?: boolean
      }
      path: {
        docId: components['parameters']['docId']
        tableIdOrName: components['parameters']['tableIdOrName']
      }
    }
    /** @description Rows to insert or upsert. */
    requestBody: {
      content: {
        'application/json': components['schemas']['RowsUpsert']
      }
    }
    responses: {
      /** @description A result indicating that the upsert was queued for processing. */
      202: {
        content: {
          'application/json': components['schemas']['RowsUpsertResult']
        }
      }
      400: components['responses']['BadRequestError']
      401: components['responses']['UnauthorizedError']
      403: components['responses']['ForbiddenError']
      404: components['responses']['NotFoundError']
      429: components['responses']['TooManyRequestsError']
    }
  }
  /**
   * Delete multiple rows
   * @description Deletes the specified rows from the table or view. This endpoint will always return a 202. Row deletions are generally processed within several seconds.
   */
  deleteRows: {
    parameters: {
      path: {
        docId: components['parameters']['docId']
        tableIdOrName: components['parameters']['tableIdOrName']
      }
    }
    /** @description Rows to delete. */
    requestBody: {
      content: {
        'application/json': components['schemas']['RowsDelete']
      }
    }
    responses: {
      /** @description A result indicating that the delete was queued for processing. */
      202: {
        content: {
          'application/json': components['schemas']['RowsDeleteResult']
        }
      }
      400: components['responses']['BadRequestError']
      401: components['responses']['UnauthorizedError']
      403: components['responses']['ForbiddenError']
      404: components['responses']['NotFoundError']
      429: components['responses']['TooManyRequestsError']
    }
  }
  /**
   * Get a row
   * @description Returns details about a row in a table.
   */
  getRow: {
    parameters: {
      query?: {
        useColumnNames?: components['parameters']['useColumnNames']
        /** @description The format that cell values are returned as. */
        valueFormat?: components['schemas']['ValueFormat']
      }
      path: {
        docId: components['parameters']['docId']
        tableIdOrName: components['parameters']['tableIdOrName']
        rowIdOrName: components['parameters']['rowIdOrName']
      }
    }
    responses: {
      /** @description Info about a row. If this row was retrieved by name, only one matching row will be returned, with no guarantees as to which one it is. */
      200: {
        content: {
          'application/json': components['schemas']['RowDetail']
        }
      }
      401: components['responses']['UnauthorizedError']
      403: components['responses']['ForbiddenError']
      404: components['responses']['NotFoundError']
      429: components['responses']['TooManyRequestsError']
    }
  }
  /**
   * Update row
   * @description Updates the specified row in the table. This endpoint will always return a 202, so long as the row exists and is accessible (and the update is structurally valid). Row updates are generally processed within several seconds. When updating using a name as opposed to an ID, an arbitrary row will be affected.
   */
  updateRow: {
    parameters: {
      query?: {
        /**
         * @description If true, the API will not attempt to parse the data in any way.
         * @example true
         */
        disableParsing?: boolean
      }
      path: {
        docId: components['parameters']['docId']
        tableIdOrName: components['parameters']['tableIdOrName']
        rowIdOrName: components['parameters']['rowIdOrName']
      }
    }
    /** @description Row update. */
    requestBody: {
      content: {
        'application/json': components['schemas']['RowUpdate']
      }
    }
    responses: {
      /** @description A result indicating that the update was queued for processing. */
      202: {
        content: {
          'application/json': components['schemas']['RowUpdateResult']
        }
      }
      400: components['responses']['BadRequestError']
      401: components['responses']['UnauthorizedError']
      403: components['responses']['ForbiddenError']
      404: components['responses']['NotFoundError']
      429: components['responses']['TooManyRequestsError']
    }
  }
  /**
   * Delete row
   * @description Deletes the specified row from the table or view. This endpoint will always return a 202, so long as the row exists and is accessible (and the update is structurally valid). Row deletions are generally processed within several seconds. When deleting using a name as opposed to an ID, an arbitrary row will be removed.
   */
  deleteRow: {
    parameters: {
      path: {
        docId: components['parameters']['docId']
        tableIdOrName: components['parameters']['tableIdOrName']
        rowIdOrName: components['parameters']['rowIdOrName']
      }
    }
    responses: {
      /** @description A result indicating that the deletion was queued for processing. */
      202: {
        content: {
          'application/json': components['schemas']['RowDeleteResult']
        }
      }
      401: components['responses']['UnauthorizedError']
      403: components['responses']['ForbiddenError']
      404: components['responses']['NotFoundError']
      429: components['responses']['TooManyRequestsError']
    }
  }
  /**
   * Push a button
   * @description Pushes a button on a row in a table.
   * Authorization note: This action is available to API tokens that are authorized to write to the table. However, the underlying button can perform any action on the document, including writing to other tables and performing Pack actions.
   */
  pushButton: {
    parameters: {
      path: {
        docId: components['parameters']['docId']
        tableIdOrName: components['parameters']['tableIdOrName']
        rowIdOrName: components['parameters']['rowIdOrName']
        columnIdOrName: components['parameters']['columnIdOrName']
      }
    }
    responses: {
      /** @description A result indicating that the push button action was queued for processing. */
      202: {
        content: {
          'application/json': components['schemas']['PushButtonResult']
        }
      }
      400: components['responses']['BadRequestError']
      401: components['responses']['UnauthorizedError']
      403: components['responses']['ForbiddenError']
      404: components['responses']['NotFoundError']
      429: components['responses']['TooManyRequestsError']
    }
  }
  /**
   * Get a column
   * @description Returns details about a column in a table.
   */
  getColumn: {
    parameters: {
      path: {
        docId: components['parameters']['docId']
        tableIdOrName: components['parameters']['tableIdOrName']
        columnIdOrName: components['parameters']['columnIdOrName']
      }
    }
    responses: {
      /** @description Info about a column. */
      200: {
        content: {
          'application/json': components['schemas']['ColumnDetail']
        }
      }
      401: components['responses']['UnauthorizedError']
      403: components['responses']['ForbiddenError']
      404: components['responses']['NotFoundError']
      429: components['responses']['TooManyRequestsError']
    }
  }
  /**
   * List formulas
   * @description Returns a list of named formulas in a Coda doc.
   */
  listFormulas: {
    parameters: {
      query?: {
        limit?: components['parameters']['limit']
        pageToken?: components['parameters']['pageToken']
        sortBy?: components['parameters']['sortBy']
      }
      path: {
        docId: components['parameters']['docId']
      }
    }
    responses: {
      /** @description List of formulas that have names in a doc. */
      200: {
        content: {
          'application/json': components['schemas']['FormulaList']
        }
      }
      401: components['responses']['UnauthorizedError']
      403: components['responses']['ForbiddenError']
      404: components['responses']['NotFoundError']
      429: components['responses']['TooManyRequestsError']
    }
  }
  /**
   * Get a formula
   * @description Returns info on a formula.
   */
  getFormula: {
    parameters: {
      path: {
        docId: components['parameters']['docId']
        formulaIdOrName: components['parameters']['formulaIdOrName']
      }
    }
    responses: {
      /** @description Details about a formula. */
      200: {
        content: {
          'application/json': components['schemas']['Formula']
        }
      }
      401: components['responses']['UnauthorizedError']
      403: components['responses']['ForbiddenError']
      404: components['responses']['NotFoundError']
      429: components['responses']['TooManyRequestsError']
    }
  }
  /**
   * List controls
   * @description Returns a list of controls in a Coda doc.
   */
  listControls: {
    parameters: {
      query?: {
        limit?: components['parameters']['limit']
        pageToken?: components['parameters']['pageToken']
        sortBy?: components['parameters']['sortBy']
      }
      path: {
        docId: components['parameters']['docId']
      }
    }
    responses: {
      /** @description List of controls in a doc. */
      200: {
        content: {
          'application/json': components['schemas']['ControlList']
        }
      }
      401: components['responses']['UnauthorizedError']
      403: components['responses']['ForbiddenError']
      404: components['responses']['NotFoundError']
      429: components['responses']['TooManyRequestsError']
    }
  }
  /**
   * Get a control
   * @description Returns info on a control.
   */
  getControl: {
    parameters: {
      path: {
        docId: components['parameters']['docId']
        controlIdOrName: components['parameters']['controlIdOrName']
      }
    }
    responses: {
      /** @description Details about a control. */
      200: {
        content: {
          'application/json': components['schemas']['Control']
        }
      }
      401: components['responses']['UnauthorizedError']
      403: components['responses']['ForbiddenError']
      404: components['responses']['NotFoundError']
      429: components['responses']['TooManyRequestsError']
    }
  }
  /**
   * List custom doc domains
   * @description List all custom domains for a published doc.
   */
  listCustomDocDomains: {
    parameters: {
      path: {
        docId: components['parameters']['docId']
      }
    }
    responses: {
      /** @description List of custom domains for a published doc. */
      200: {
        content: {
          'application/json': components['schemas']['CustomDocDomainList']
        }
      }
      401: components['responses']['UnauthorizedError']
      403: components['responses']['ForbiddenError']
      404: components['responses']['NotFoundError']
      429: components['responses']['TooManyRequestsError']
    }
  }
  /**
   * Add custom domain
   * @description Add a custom domain to a published doc.
   */
  addCustomDocDomain: {
    parameters: {
      path: {
        docId: components['parameters']['docId']
      }
    }
    /** @description Parameters for adding a custom domain to a published doc. */
    requestBody: {
      content: {
        'application/json': components['schemas']['AddCustomDocDomainRequest']
      }
    }
    responses: {
      /** @description Confirmation that the custom domain was added to the doc. */
      202: {
        content: {
          'application/json': components['schemas']['AddCustomDocDomainResponse']
        }
      }
      401: components['responses']['UnauthorizedError']
      403: components['responses']['ForbiddenError']
      404: components['responses']['NotFoundError']
      429: components['responses']['TooManyRequestsError']
    }
  }
  /**
   * Deletes a custom domain
   * @description Deletes a custom domain from a published doc.
   */
  deleteCustomDocDomain: {
    parameters: {
      path: {
        docId: components['parameters']['docId']
        customDocDomain: components['parameters']['customDocDomain']
      }
    }
    responses: {
      /** @description A result indicating that the custom domain was deleted. */
      200: {
        content: {
          'application/json': components['schemas']['DeleteCustomDocDomainResponse']
        }
      }
      401: components['responses']['UnauthorizedError']
      403: components['responses']['ForbiddenError']
      404: components['responses']['NotFoundError']
      429: components['responses']['TooManyRequestsError']
    }
  }
  /**
   * Updates a custom domain
   * @description Updates properties of a document's custom domain.
   */
  updateCustomDocDomain: {
    parameters: {
      path: {
        docId: components['parameters']['docId']
        customDocDomain: components['parameters']['customDocDomain']
      }
    }
    /** @description Properties of a custom domain to update. */
    requestBody: {
      content: {
        'application/json': components['schemas']['UpdateCustomDocDomainRequest']
      }
    }
    responses: {
      /** @description The custom domain object with the updates applied. */
      200: {
        content: {
          'application/json': components['schemas']['UpdateCustomDocDomainResponse']
        }
      }
      401: components['responses']['UnauthorizedError']
      403: components['responses']['ForbiddenError']
      404: components['responses']['NotFoundError']
      429: components['responses']['TooManyRequestsError']
    }
  }
  /**
   * Gets custom doc domains providers
   * @description Gets the provider (ie. GoDaddy) of a custom domain.
   */
  getCustomDocDomainProvider: {
    parameters: {
      path: {
        customDocDomain: components['parameters']['customDocDomain']
      }
    }
    responses: {
      /** @description Provider of the custom domain */
      200: {
        content: {
          'application/json': components['schemas']['CustomDocDomainProviderResponse']
        }
      }
      401: components['responses']['UnauthorizedError']
      403: components['responses']['ForbiddenError']
      404: components['responses']['NotFoundError']
      429: components['responses']['TooManyRequestsError']
    }
  }
  /**
   * Get user info
   * @description Returns basic info about the current user.
   */
  whoami: {
    responses: {
      /** @description Info about the current user. */
      200: {
        content: {
          'application/json': components['schemas']['User']
        }
      }
      401: components['responses']['UnauthorizedError']
      429: components['responses']['TooManyRequestsError']
    }
  }
  /**
   * Resolve browser link
   * @description Given a browser link to a Coda object, attempts to find it and return metadata that can be used to get more info on it. Returns a 400 if the URL does not appear to be a Coda URL or a 404 if the resource cannot be located with the current credentials.
   */
  resolveBrowserLink: {
    parameters: {
      query: {
        /**
         * @description The browser link to try to resolve.
         * @example https://coda.io/d/_dAbCDeFGH/Launch-Status_sumnO
         */
        url: string
        /**
         * @description By default, attempting to resolve the Coda URL of a deleted object will result in an error. If this flag is set, the next-available object, all the way up to the doc itself, will be resolved.
         *
         * @example true
         */
        degradeGracefully?: boolean
      }
    }
    responses: {
      /** @description Metadata for the resolved resource. */
      200: {
        content: {
          'application/json': components['schemas']['ApiLink']
        }
      }
      400: components['responses']['BadRequestError']
      401: components['responses']['UnauthorizedError']
      403: components['responses']['ForbiddenError']
      404: components['responses']['NotFoundError']
      429: components['responses']['TooManyRequestsError']
    }
  }
  /**
   * Get mutation status
   * @description Get the status for an asynchronous mutation to know whether or not it has been completed. Each API endpoint that mutates a document will return a request id that you can pass to this endpoint to check the completion status. Status information is not guaranteed to be available for more than one day after the mutation was completed. It is intended to be used shortly after the request was made.
   */
  getMutationStatus: {
    parameters: {
      path: {
        requestId: components['parameters']['requestId']
      }
    }
    responses: {
      /** @description Info about the mutation. */
      200: {
        content: {
          'application/json': components['schemas']['MutationStatus']
        }
      }
      401: components['responses']['UnauthorizedError']
      404: components['responses']['NotFoundError']
      429: components['responses']['TooManyRequestsError']
    }
  }
  /**
   * Trigger automation
   * @description Triggers webhook-invoked automation
   */
  triggerWebhookAutomation: {
    parameters: {
      path: {
        docId: components['parameters']['docId']
        ruleId: components['parameters']['ruleId']
      }
    }
    /** @description Payload for webhook */
    requestBody?: {
      content: {
        'application/json': components['schemas']['WebhookTriggerPayload']
        'application/x-www-form-urlencoded': components['schemas']['WebhookTriggerPayload']
      }
    }
    responses: {
      /** @description A result indicating that the automation trigger was queued for processing. */
      202: {
        content: {
          'application/json': components['schemas']['WebhookTriggerResult']
        }
      }
      400: components['responses']['BadRequestError']
      401: components['responses']['UnauthorizedError']
      403: components['responses']['ForbiddenError']
      404: components['responses']['NotFoundError']
      422: components['responses']['UnprocessableEntityError']
      429: components['responses']['TooManyRequestsError']
    }
  }
  /**
   * List doc analytics
   * @description Returns analytics data for available docs per day.
   */
  listDocAnalytics: {
    parameters: {
      query?: {
        docIds?: components['parameters']['docIds']
        workspaceId?: components['parameters']['workspaceIdInQuery']
        query?: components['parameters']['query']
        isPublished?: components['parameters']['isPublished']
        sinceDate?: components['parameters']['sinceDate']
        untilDate?: components['parameters']['untilDate']
        scale?: components['parameters']['scale']
        pageToken?: components['parameters']['pageToken']
        orderBy?: components['parameters']['docAnalyticsOrderBy']
        direction?: components['parameters']['direction']
        /**
         * @description Maximum number of results to return in this query.
         * @example 10
         */
        limit?: number
      }
    }
    responses: {
      /** @description List of Coda doc analytics. */
      200: {
        content: {
          'application/json': components['schemas']['DocAnalyticsCollection']
        }
      }
      401: components['responses']['UnauthorizedError']
      429: components['responses']['TooManyRequestsError']
    }
  }
  /**
   * List page analytics
   * @description Returns analytics data for a given doc within the day.
   * This method will return a 401 if the given doc is not in an Enterprise workspace.
   */
  listPageAnalytics: {
    parameters: {
      query?: {
        sinceDate?: components['parameters']['sinceDate']
        untilDate?: components['parameters']['untilDate']
        pageToken?: components['parameters']['pageToken']
        /**
         * @description Maximum number of results to return in this query.
         * @example 10
         */
        limit?: number
      }
      path: {
        docId: components['parameters']['docId']
      }
    }
    responses: {
      /** @description List of page analytics for the given Coda doc. */
      200: {
        content: {
          'application/json': components['schemas']['PageAnalyticsCollection']
        }
      }
      401: components['responses']['UnauthorizedError']
      429: components['responses']['TooManyRequestsError']
    }
  }
  /**
   * Get doc analytics summary
   * @description Returns summarized analytics data for available docs.
   */
  listDocAnalyticsSummary: {
    parameters: {
      query?: {
        isPublished?: components['parameters']['isPublished']
        sinceDate?: components['parameters']['sinceDate']
        untilDate?: components['parameters']['untilDate']
        workspaceId?: components['parameters']['workspaceIdInQuery']
      }
    }
    responses: {
      /** @description Response of Coda doc summary analytics. */
      200: {
        content: {
          'application/json': components['schemas']['DocAnalyticsSummary']
        }
      }
      401: components['responses']['UnauthorizedError']
      429: components['responses']['TooManyRequestsError']
    }
  }
  /**
   * List Pack analytics
   * @description Returns analytics data for Packs the user can edit.
   */
  listPackAnalytics: {
    parameters: {
      query?: {
        packIds?: components['parameters']['packIds']
        workspaceId?: components['parameters']['workspaceIdInQuery']
        query?: components['parameters']['query']
        sinceDate?: components['parameters']['sinceDate']
        untilDate?: components['parameters']['untilDate']
        scale?: components['parameters']['scale']
        pageToken?: components['parameters']['pageToken']
        orderBy?: components['parameters']['packAnalyticsOrderBy']
        direction?: components['parameters']['direction']
        isPublished?: components['parameters']['isPublishedNoDefault']
        /**
         * @description Maximum number of results to return in this query.
         * @example 10
         */
        limit?: number
      }
    }
    responses: {
      /** @description Response of Coda Pack analytics. */
      200: {
        content: {
          'application/json': components['schemas']['PackAnalyticsCollection']
        }
      }
      401: components['responses']['UnauthorizedError']
      429: components['responses']['TooManyRequestsError']
    }
  }
  /**
   * Get Pack analytics summary
   * @description Returns summarized analytics data for Packs the user can edit.
   */
  listPackAnalyticsSummary: {
    parameters: {
      query?: {
        packIds?: components['parameters']['packIds']
        workspaceId?: components['parameters']['workspaceIdInQuery']
        isPublished?: components['parameters']['isPublishedNoDefault']
        sinceDate?: components['parameters']['sinceDate']
        untilDate?: components['parameters']['untilDate']
      }
    }
    responses: {
      /** @description Response of Coda Pack summary analytics. */
      200: {
        content: {
          'application/json': components['schemas']['PackAnalyticsSummary']
        }
      }
      401: components['responses']['UnauthorizedError']
      429: components['responses']['TooManyRequestsError']
    }
  }
  /**
   * List Pack formula analytics
   * @description Returns analytics data for Pack formulas.
   */
  listPackFormulaAnalytics: {
    parameters: {
      query?: {
        /**
         * @description A list of Pack formula names (case-sensitive) for which to retrieve analytics.
         * @example SquareRoot,CubeRoot
         */
        packFormulaNames?: string[]
        /**
         * @description A list of Pack formula types corresponding to the `packFormulaNames`. If specified, this must have the same length as `packFormulaNames`.
         * @example action,formula
         */
        packFormulaTypes?: components['schemas']['PackFormulaType'][]
        sinceDate?: components['parameters']['sinceDate']
        untilDate?: components['parameters']['untilDate']
        scale?: components['parameters']['scale']
        pageToken?: components['parameters']['pageToken']
        orderBy?: components['parameters']['packFormulaAnalyticsOrderBy']
        direction?: components['parameters']['direction']
        /**
         * @description Maximum number of results to return in this query.
         * @example 10
         */
        limit?: number
      }
      path: {
        packId: components['parameters']['packId']
      }
    }
    responses: {
      /** @description Response of Coda Pack formula analytics. */
      200: {
        content: {
          'application/json': components['schemas']['PackFormulaAnalyticsCollection']
        }
      }
      401: components['responses']['UnauthorizedError']
      429: components['responses']['TooManyRequestsError']
    }
  }
  /**
   * Get analytics last updated day
   * @description Returns days based on Pacific Standard Time when analytics were last updated.
   */
  getAnalyticsLastUpdated: {
    responses: {
      /** @description Response of analytics last updated days. */
      200: {
        content: {
          'application/json': components['schemas']['AnalyticsLastUpdatedResponse']
        }
      }
      429: components['responses']['TooManyRequestsError']
    }
  }
  /**
   * List workspace users
   * @description Returns a list of members in the given workspace. This list will be ordered with the requesting user first and then ordered by role.
   */
  listWorkspaceMembers: {
    parameters: {
      query?: {
        /**
         * @description Show only the members that match the included roles. Multiple roles can be specified with a comma-delimited list.
         * @example Editor,DocMaker
         */
        includedRoles?: components['schemas']['WorkspaceUserRole'][]
        pageToken?: components['parameters']['pageToken']
      }
      path: {
        workspaceId: components['parameters']['workspaceId']
      }
    }
    responses: {
      /** @description List of workspace members matching the query. */
      200: {
        content: {
          'application/json': components['schemas']['WorkspaceMembersList']
        }
      }
      401: components['responses']['UnauthorizedError']
      403: components['responses']['ForbiddenError']
      404: components['responses']['NotFoundError']
      429: components['responses']['TooManyRequestsError']
    }
  }
  /**
   * Updates user role
   * @description Updates the workspace user role of a user that matches the parameters. Only succeeds if the requesting user has admin permissions in the workspace.
   */
  changeUserRole: {
    parameters: {
      path: {
        workspaceId: components['parameters']['workspaceId']
      }
    }
    /** @description Parameters for changing the user role. */
    requestBody: {
      content: {
        'application/json': components['schemas']['ChangeRole']
      }
    }
    responses: {
      /** @description User's info that was updated. */
      200: {
        content: {
          'application/json': components['schemas']['ChangeRoleResult']
        }
      }
      401: components['responses']['UnauthorizedError']
      403: components['responses']['ForbiddenError']
      404: components['responses']['NotFoundError']
      429: components['responses']['TooManyRequestsError']
    }
  }
  /**
   * List workspace roles
   * @description Returns a list of the counts of users over time by role for the workspace.
   */
  listWorkspaceRoleActivity: {
    parameters: {
      path: {
        workspaceId: components['parameters']['workspaceId']
      }
    }
    responses: {
      /** @description List of role activity over time for the workspace. */
      200: {
        content: {
          'application/json': components['schemas']['GetWorkspaceRoleActivity']
        }
      }
      401: components['responses']['UnauthorizedError']
      403: components['responses']['ForbiddenError']
      404: components['responses']['NotFoundError']
      429: components['responses']['TooManyRequestsError']
    }
  }
  /**
   * List Packs
   * @description Get the list of accessible Packs.
   */
  listPacks: {
    parameters: {
      query?: {
        /**
         * @description Deprecated, use accessTypes instead. Filter to only return the Packs for which the current user has this access type
         * @example edit
         */
        accessType?: components['schemas']['PackAccessType']
        /**
         * @description Filter to only return the Packs for which the current user has these access types.
         * @example edit
         */
        accessTypes?: components['schemas']['PackAccessType'][]
        /**
         * @description The sort order of the Packs returned.
         * @example true
         */
        sortBy?: components['schemas']['PacksSortBy']
        limit?: components['parameters']['limit']
        direction?: components['parameters']['direction']
        pageToken?: components['parameters']['pageToken']
        onlyWorkspaceId?: components['parameters']['onlyWorkspaceId']
        parentWorkspaceIds?: components['parameters']['parentWorkspaceIds']
        excludePublicPacks?: components['parameters']['excludePublicPacks']
        excludeIndividualAcls?: components['parameters']['excludeIndividualAcls']
        excludeWorkspaceAcls?: components['parameters']['excludeWorkspaceAcls']
      }
    }
    responses: {
      /** @description List of Pack summaries. */
      200: {
        content: {
          'application/json': components['schemas']['PackSummaryList']
        }
      }
      400: components['responses']['BadRequestError']
      401: components['responses']['UnauthorizedError']
      429: components['responses']['TooManyRequestsError']
    }
  }
  /**
   * Create Pack
   * @description Creates a new Pack, essentially registering a new Pack ID. The contents of the Pack will be uploaded separately.
   */
  createPack: {
    /** @description Parameters for creating the Pack. */
    requestBody: {
      content: {
        'application/json': components['schemas']['CreatePackRequest']
      }
    }
    responses: {
      /** @description Info about the Pack that was just created. */
      200: {
        content: {
          'application/json': components['schemas']['CreatePackResponse']
        }
      }
      400: components['responses']['BadRequestError']
      401: components['responses']['UnauthorizedError']
      403: components['responses']['ForbiddenError']
      429: components['responses']['TooManyRequestsError']
    }
  }
  /**
   * Get a single Pack
   * @description Returns a single Pack.
   */
  getPack: {
    parameters: {
      path: {
        packId: components['parameters']['packId']
      }
    }
    responses: {
      /** @description The requested Pack. */
      200: {
        content: {
          'application/json': components['schemas']['Pack']
        }
      }
      400: components['responses']['BadRequestError']
      401: components['responses']['UnauthorizedError']
      403: components['responses']['ForbiddenError']
      404: components['responses']['NotFoundError']
      429: components['responses']['TooManyRequestsError']
    }
  }
  /**
   * Delete Pack
   * @description Delete a given Pack.
   */
  deletePack: {
    parameters: {
      path: {
        packId: components['parameters']['packId']
      }
    }
    responses: {
      /** @description Confirmation that the Pack deletion was successful. */
      200: {
        content: {
          'application/json': components['schemas']['DeletePackResponse']
        }
      }
      400: components['responses']['BadRequestError']
      401: components['responses']['UnauthorizedError']
      403: components['responses']['ForbiddenError']
      404: components['responses']['NotFoundError']
      429: components['responses']['TooManyRequestsError']
    }
  }
  /**
   * Update Pack
   * @description Update an existing Pack for non-versioned fields.
   */
  updatePack: {
    parameters: {
      path: {
        packId: components['parameters']['packId']
      }
    }
    /** @description Parameters for updating the Pack. */
    requestBody: {
      content: {
        'application/json': components['schemas']['UpdatePackRequest']
      }
    }
    responses: {
      /** @description Info about the Pack that was just updated. */
      200: {
        content: {
          'application/json': components['schemas']['Pack']
        }
      }
      400: components['responses']['BadRequestError']
      401: components['responses']['UnauthorizedError']
      403: components['responses']['ForbiddenError']
      404: components['responses']['NotFoundError']
      429: components['responses']['TooManyRequestsError']
    }
  }
  /**
   * Gets the JSON Schema for Pack configuration.
   * @description Returns a JSON Schema applicable for customizing the pack using Pack configurations.
   */
  getPackConfigurationSchema: {
    parameters: {
      path: {
        packId: components['parameters']['packId']
      }
    }
    responses: {
      /** @description Response containing the JSON Schema of the pack configuration. */
      200: {
        content: {
          'application/json': components['schemas']['GetPackConfigurationJsonSchemaResponse']
        }
      }
      400: components['responses']['BadRequestWithValidationErrors']
      401: components['responses']['UnauthorizedError']
      403: components['responses']['ForbiddenError']
      404: components['responses']['NotFoundError']
      429: components['responses']['TooManyRequestsError']
    }
  }
  /**
   * List the versions for a Pack.
   * @description Get the list of versions of a Pack.
   */
  listPackVersions: {
    parameters: {
      query?: {
        limit?: components['parameters']['limit']
        pageToken?: components['parameters']['pageToken']
      }
      path: {
        packId: components['parameters']['packId']
      }
    }
    responses: {
      /** @description List of Pack versions. */
      200: {
        content: {
          'application/json': components['schemas']['PackVersionList']
        }
      }
      400: components['responses']['BadRequestWithValidationErrors']
      401: components['responses']['UnauthorizedError']
      403: components['responses']['ForbiddenError']
      404: components['responses']['NotFoundError']
      429: components['responses']['TooManyRequestsError']
    }
  }
  /**
   * Get the next valid version for a Pack.
   * @description Get the next valid version based on the proposed metadata.
   */
  getNextPackVersion: {
    parameters: {
      path: {
        packId: components['parameters']['packId']
      }
    }
    requestBody?: {
      content: {
        'application/json': components['schemas']['GetNextPackVersionRequest']
      }
    }
    responses: {
      /** @description Next Pack version info. */
      200: {
        content: {
          'application/json': components['schemas']['NextPackVersionInfo']
        }
      }
      400: components['responses']['BadRequestWithValidationErrors']
      401: components['responses']['UnauthorizedError']
      403: components['responses']['ForbiddenError']
      404: components['responses']['NotFoundError']
      429: components['responses']['TooManyRequestsError']
    }
  }
  /**
   * Get the difference between two pack versions.
   * @description Gets information about the difference between the specified previous version and next version of a Pack.
   */
  getPackVersionDiffs: {
    parameters: {
      path: {
        packId: components['parameters']['packId']
        basePackVersion: components['parameters']['basePackVersion']
        targetPackVersion: components['parameters']['targetPackVersion']
      }
    }
    responses: {
      /** @description Diffs between the two pack versions. */
      200: {
        content: {
          'application/json': components['schemas']['PackVersionDiffs']
        }
      }
      400: components['responses']['BadRequestWithValidationErrors']
      401: components['responses']['UnauthorizedError']
      403: components['responses']['ForbiddenError']
      404: components['responses']['NotFoundError']
      429: components['responses']['TooManyRequestsError']
    }
  }
  /**
   * Register Pack version
   * @description Registers a new Pack version. This simply returns a signed URL to use for uploading the Pack version definition. Following the completion of the upload, POST to /apis/v1/packs/{packId}/versions/{packVersion} trigger the rest of the creation process.
   */
  registerPackVersion: {
    parameters: {
      path: {
        packId: components['parameters']['packId']
        packVersion: components['parameters']['packVersion']
      }
    }
    /** @description Parameters for registering the Pack. */
    requestBody: {
      content: {
        'application/json': components['schemas']['RegisterPackVersionRequest']
      }
    }
    responses: {
      /** @description The information indicating where to upload the Pack version definition. */
      200: {
        content: {
          'application/json': components['schemas']['PackVersionUploadInfo']
        }
      }
      400: components['responses']['BadRequestError']
      401: components['responses']['UnauthorizedError']
      403: components['responses']['ForbiddenError']
      404: components['responses']['NotFoundError']
      429: components['responses']['TooManyRequestsError']
    }
  }
  /**
   * Pack version upload complete
   * @description Note the completion of the upload of a Pack version bundle in order to create that Pack version.
   */
  packVersionUploadComplete: {
    parameters: {
      path: {
        packId: components['parameters']['packId']
        packVersion: components['parameters']['packVersion']
      }
    }
    /** @description Parameters for Pack version upload complete. */
    requestBody: {
      content: {
        'application/json': components['schemas']['CreatePackVersionRequest']
      }
    }
    responses: {
      /** @description Confirmation of successful Pack version creation. */
      200: {
        content: {
          'application/json': components['schemas']['CreatePackVersionResponse']
        }
      }
      400: components['responses']['BadRequestWithValidationErrors']
      401: components['responses']['UnauthorizedError']
      403: components['responses']['ForbiddenError']
      404: components['responses']['NotFoundError']
      429: components['responses']['TooManyRequestsError']
    }
  }
  /**
   * List the releases for a Pack.
   * @description Get the list of releases of a Pack.
   */
  listPackReleases: {
    parameters: {
      query?: {
        limit?: components['parameters']['limit']
        pageToken?: components['parameters']['pageToken']
      }
      path: {
        packId: components['parameters']['packId']
      }
    }
    responses: {
      /** @description List of Pack releases. */
      200: {
        content: {
          'application/json': components['schemas']['PackReleaseList']
        }
      }
      400: components['responses']['BadRequestWithValidationErrors']
      401: components['responses']['UnauthorizedError']
      403: components['responses']['ForbiddenError']
      404: components['responses']['NotFoundError']
      429: components['responses']['TooManyRequestsError']
    }
  }
  /**
   * Create a new Pack release.
   * @description Creates a new Pack release based on an existing Pack version.
   */
  createPackRelease: {
    parameters: {
      path: {
        packId: components['parameters']['packId']
      }
    }
    /** @description Parameters to create the Pack release. */
    requestBody: {
      content: {
        'application/json': components['schemas']['CreatePackReleaseRequest']
      }
    }
    responses: {
      /** @description The newly created Pack release. */
      200: {
        content: {
          'application/json': components['schemas']['PackRelease']
        }
      }
      400: components['responses']['BadRequestWithValidationErrors']
      401: components['responses']['UnauthorizedError']
      403: components['responses']['ForbiddenError']
      404: components['responses']['NotFoundError']
      429: components['responses']['TooManyRequestsError']
    }
  }
  /**
   * Update an existing Pack release.
   * @description Update details of a Pack release.
   */
  updatePackRelease: {
    parameters: {
      path: {
        packId: components['parameters']['packId']
        packReleaseId: components['parameters']['packReleaseId']
      }
    }
    /** @description Parameters to update the Pack release. */
    requestBody: {
      content: {
        'application/json': components['schemas']['UpdatePackReleaseRequest']
      }
    }
    responses: {
      /** @description The updated Pack release. */
      200: {
        content: {
          'application/json': components['schemas']['PackRelease']
        }
      }
      400: components['responses']['BadRequestWithValidationErrors']
      401: components['responses']['UnauthorizedError']
      403: components['responses']['ForbiddenError']
      404: components['responses']['NotFoundError']
      429: components['responses']['TooManyRequestsError']
    }
  }
  /**
   * Retrieve the OAuth configuration of the Pack.
   * @description Retrieve the OAuth configuration of the Pack for display purpose. Secrets will be returned with masks.
   */
  getPackOauthConfig: {
    parameters: {
      path: {
        packId: components['parameters']['packId']
      }
    }
    responses: {
      /** @description The Pack's OAuth configuration. */
      200: {
        content: {
          'application/json': components['schemas']['PackOauthConfigMetadata']
        }
      }
      400: components['responses']['BadRequestWithValidationErrors']
      401: components['responses']['UnauthorizedError']
      403: components['responses']['ForbiddenError']
      404: components['responses']['NotFoundError']
      429: components['responses']['TooManyRequestsError']
    }
  }
  /**
   * Set the OAuth configurations of the Pack.
   * @description Set the OAuth configurations of the Pack, including client id and secret.
   */
  setPackOauthConfig: {
    parameters: {
      path: {
        packId: components['parameters']['packId']
      }
    }
    /** @description Parameters to set the Pack OAuth configuration. */
    requestBody: {
      content: {
        'application/json': components['schemas']['SetPackOauthConfigRequest']
      }
    }
    responses: {
      /** @description The updated OAuth configuration. */
      200: {
        content: {
          'application/json': components['schemas']['PackOauthConfigMetadata']
        }
      }
      400: components['responses']['BadRequestWithValidationErrors']
      401: components['responses']['UnauthorizedError']
      403: components['responses']['ForbiddenError']
      404: components['responses']['NotFoundError']
      429: components['responses']['TooManyRequestsError']
    }
  }
  /**
   * Retrieve the system connection metadata of the Pack.
   * @description Retrieve the system connection metadata of the Pack.
   */
  getPackSystemConnection: {
    parameters: {
      path: {
        packId: components['parameters']['packId']
      }
    }
    responses: {
      /** @description The system connection metadata. */
      200: {
        content: {
          'application/json': components['schemas']['PackSystemConnectionMetadata']
        }
      }
      400: components['responses']['BadRequestWithValidationErrors']
      401: components['responses']['UnauthorizedError']
      403: components['responses']['ForbiddenError']
      404: components['responses']['NotFoundError']
      429: components['responses']['TooManyRequestsError']
    }
  }
  /**
   * Set the system connection credentials of the Pack.
   * @description Set the system connection credentials of the Pack.
   */
  setPackSystemConnection: {
    parameters: {
      path: {
        packId: components['parameters']['packId']
      }
    }
    /** @description Parameters to set the Pack system connection credentials. */
    requestBody: {
      content: {
        'application/json': components['schemas']['SetPackSystemConnectionRequest']
      }
    }
    responses: {
      /** @description The updated system connection. */
      200: {
        content: {
          'application/json': components['schemas']['PackSystemConnectionMetadata']
        }
      }
      400: components['responses']['BadRequestWithValidationErrors']
      401: components['responses']['UnauthorizedError']
      403: components['responses']['ForbiddenError']
      404: components['responses']['NotFoundError']
      429: components['responses']['TooManyRequestsError']
    }
  }
  /**
   * Patch the system connection credentials of the Pack.
   * @description Patch the system connection credentials of the Pack.
   */
  patchPackSystemConnection: {
    parameters: {
      path: {
        packId: components['parameters']['packId']
      }
    }
    /** @description Parameters to patch the Pack system connection credentials. */
    requestBody: {
      content: {
        'application/json': components['schemas']['PatchPackSystemConnectionRequest']
      }
    }
    responses: {
      /** @description The updated system connection. */
      200: {
        content: {
          'application/json': components['schemas']['PackSystemConnectionMetadata']
        }
      }
      400: components['responses']['BadRequestWithValidationErrors']
      401: components['responses']['UnauthorizedError']
      403: components['responses']['ForbiddenError']
      404: components['responses']['NotFoundError']
      429: components['responses']['TooManyRequestsError']
    }
  }
  /**
   * List permissions for a Pack
   * @description Get user, workspace, and/or global permissions for a given Pack.
   */
  getPackPermissions: {
    parameters: {
      path: {
        packId: components['parameters']['packId']
      }
    }
    responses: {
      /** @description List of Pack permissions. */
      200: {
        content: {
          'application/json': components['schemas']['PackPermissionList']
        }
      }
      400: components['responses']['BadRequestWithValidationErrors']
      401: components['responses']['UnauthorizedError']
      403: components['responses']['ForbiddenError']
      404: components['responses']['NotFoundError']
      429: components['responses']['TooManyRequestsError']
    }
  }
  /**
   * Add a permission for Pack
   * @description Create or modify user, workspace, or global permissions for a given Pack.
   */
  addPackPermission: {
    parameters: {
      path: {
        packId: components['parameters']['packId']
      }
    }
    /** @description Parameters for creating/updating Pack permissions. */
    requestBody: {
      content: {
        'application/json': components['schemas']['AddPackPermissionRequest']
      }
    }
    responses: {
      /** @description Confirmation of successfully upserting a Pack permission. */
      200: {
        content: {
          'application/json': components['schemas']['AddPackPermissionResponse']
        }
      }
      400: components['responses']['BadRequestWithValidationErrors']
      401: components['responses']['UnauthorizedError']
      403: components['responses']['ForbiddenError']
      404: components['responses']['NotFoundError']
      429: components['responses']['TooManyRequestsError']
    }
  }
  /**
   * Delete a permission for Pack
   * @description Delete user, workspace, or global permissions for a given Pack.
   */
  deletePackPermission: {
    parameters: {
      path: {
        packId: components['parameters']['packId']
        permissionId: components['parameters']['permissionId']
      }
    }
    responses: {
      /** @description Confirmation of successfully deleting a Pack permission. */
      200: {
        content: {
          'application/json': components['schemas']['DeletePackPermissionResponse']
        }
      }
      400: components['responses']['BadRequestWithValidationErrors']
      401: components['responses']['UnauthorizedError']
      403: components['responses']['ForbiddenError']
      404: components['responses']['NotFoundError']
      429: components['responses']['TooManyRequestsError']
    }
  }
  /**
   * List makers for Pack
   * @description List makers for a given pack.
   */
  listPackMakers: {
    parameters: {
      path: {
        packId: components['parameters']['packId']
      }
    }
    responses: {
      /** @description Confirmation of successfully retrieving Pack makers */
      200: {
        content: {
          'application/json': components['schemas']['ListPackMakersResponse']
        }
      }
      400: components['responses']['BadRequestWithValidationErrors']
      401: components['responses']['UnauthorizedError']
      403: components['responses']['ForbiddenError']
      404: components['responses']['NotFoundError']
      429: components['responses']['TooManyRequestsError']
    }
  }
  /**
   * Add a maker for Pack
   * @description Set a maker for a given Pack. Used to display makers for a pack in the corresponding packs page.
   */
  addPackMaker: {
    parameters: {
      path: {
        packId: components['parameters']['packId']
      }
    }
    /** @description Payload for adding a Pack maker. */
    requestBody: {
      content: {
        'application/json': components['schemas']['AddPackMakerRequest']
      }
    }
    responses: {
      /** @description Confirmation of successfully adding a Pack maker. */
      200: {
        content: {
          'application/json': components['schemas']['AddPackMakerResponse']
        }
      }
      400: components['responses']['BadRequestWithValidationErrors']
      401: components['responses']['UnauthorizedError']
      403: components['responses']['ForbiddenError']
      404: components['responses']['NotFoundError']
      429: components['responses']['TooManyRequestsError']
    }
  }
  /**
   * Delete a maker for Pack
   * @description Delete a maker for a given Pack, who will not be displayed in the corresponding packs page.
   */
  deletePackMaker: {
    parameters: {
      path: {
        packId: components['parameters']['packId']
        loginId: components['parameters']['loginId']
      }
    }
    responses: {
      /** @description Confirmation of successfully deleting a Pack maker. */
      200: {
        content: {
          'application/json': components['schemas']['DeletePackMakerResponse']
        }
      }
      400: components['responses']['BadRequestWithValidationErrors']
      401: components['responses']['UnauthorizedError']
      403: components['responses']['ForbiddenError']
      404: components['responses']['NotFoundError']
      429: components['responses']['TooManyRequestsError']
    }
  }
  /**
   * List categories for Pack
   * @description List publishing categories for a given pack.
   */
  listPackCategories: {
    parameters: {
      path: {
        packId: components['parameters']['packId']
      }
    }
    responses: {
      /** @description Confirmation of successfully retrieving Pack categories */
      200: {
        content: {
          'application/json': components['schemas']['ListPackCategoriesResponse']
        }
      }
      400: components['responses']['BadRequestWithValidationErrors']
      401: components['responses']['UnauthorizedError']
      403: components['responses']['ForbiddenError']
      404: components['responses']['NotFoundError']
      429: components['responses']['TooManyRequestsError']
    }
  }
  /**
   * Add a category for Pack
   * @description Add a publishing category for a given pack.
   */
  addPackCategory: {
    parameters: {
      path: {
        packId: components['parameters']['packId']
      }
    }
    /** @description Payload for adding a Pack category. */
    requestBody: {
      content: {
        'application/json': components['schemas']['AddPackCategoryRequest']
      }
    }
    responses: {
      /** @description Confirmation of successfully adding a Pack category */
      200: {
        content: {
          'application/json': components['schemas']['AddPackCategoryResponse']
        }
      }
      400: components['responses']['BadRequestWithValidationErrors']
      401: components['responses']['UnauthorizedError']
      403: components['responses']['ForbiddenError']
      404: components['responses']['NotFoundError']
      429: components['responses']['TooManyRequestsError']
    }
  }
  /**
   * Delete a category for Pack
   * @description Delete a publishing category for a given pack.
   */
  deletePackCategory: {
    parameters: {
      path: {
        packId: components['parameters']['packId']
        categoryName: components['parameters']['categoryName']
      }
    }
    responses: {
      /** @description Confirmation of successfully deleting a Pack category */
      200: {
        content: {
          'application/json': components['schemas']['DeletePackCategoryResponse']
        }
      }
      400: components['responses']['BadRequestWithValidationErrors']
      401: components['responses']['UnauthorizedError']
      403: components['responses']['ForbiddenError']
      404: components['responses']['NotFoundError']
      429: components['responses']['TooManyRequestsError']
    }
  }
  /**
   * Upload a Pack asset.
   * @description Request a signed s3 URL to upload your Pack asset.
   */
  uploadPackAsset: {
    parameters: {
      path: {
        packId: components['parameters']['packId']
      }
    }
    /** @description Parameters to specify the asset being uploaded. */
    requestBody: {
      content: {
        'application/json': components['schemas']['UploadPackAssetRequest']
      }
    }
    responses: {
      /** @description The information indicating where to upload the Pack asset. */
      200: {
        content: {
          'application/json': components['schemas']['PackAssetUploadInfo']
        }
      }
      400: components['responses']['BadRequestWithValidationErrors']
      401: components['responses']['UnauthorizedError']
      403: components['responses']['ForbiddenError']
      404: components['responses']['NotFoundError']
      429: components['responses']['TooManyRequestsError']
    }
  }
  /**
   * Upload Pack source code.
   * @description Request a signed s3 URL to upload your Pack source code.
   */
  uploadPackSourceCode: {
    parameters: {
      path: {
        packId: components['parameters']['packId']
      }
    }
    /** @description Parameters to specify the source code being uploaded. */
    requestBody: {
      content: {
        'application/json': components['schemas']['UploadPackSourceCodeRequest']
      }
    }
    responses: {
      /** @description The information indicating where to upload the Pack source code. */
      200: {
        content: {
          'application/json': components['schemas']['PackSourceCodeUploadInfo']
        }
      }
      400: components['responses']['BadRequestWithValidationErrors']
      401: components['responses']['UnauthorizedError']
      403: components['responses']['ForbiddenError']
      404: components['responses']['NotFoundError']
      429: components['responses']['TooManyRequestsError']
    }
  }
  /**
   * Pack asset upload complete
   * @description Note the completion of the upload of a Pack asset.
   */
  packAssetUploadComplete: {
    parameters: {
      path: {
        packId: components['parameters']['packId']
        packAssetId: components['parameters']['packAssetId']
        packAssetType: components['parameters']['packAssetType']
      }
    }
    responses: {
      /** @description Confirmation of successful Pack asset creation. */
      200: {
        content: {
          'application/json': components['schemas']['PackAssetUploadCompleteResponse']
        }
      }
      400: components['responses']['BadRequestWithValidationErrors']
      401: components['responses']['UnauthorizedError']
      403: components['responses']['ForbiddenError']
      404: components['responses']['NotFoundError']
      429: components['responses']['TooManyRequestsError']
    }
  }
  /**
   * Pack source code upload complete
   * @description Note the completion of the upload of a Pack source code.
   */
  packSourceCodeUploadComplete: {
    parameters: {
      path: {
        packId: components['parameters']['packId']
        packVersion: components['parameters']['packVersion']
      }
    }
    /** @description Parameters to specify the source code being uploaded. */
    requestBody: {
      content: {
        'application/json': components['schemas']['PackSourceCodeUploadCompleteRequest']
      }
    }
    responses: {
      /** @description Confirmation of successful Pack asset creation. */
      200: {
        content: {
          'application/json': components['schemas']['PackSourceCodeUploadCompleteResponse']
        }
      }
      400: components['responses']['BadRequestWithValidationErrors']
      401: components['responses']['UnauthorizedError']
      403: components['responses']['ForbiddenError']
      404: components['responses']['NotFoundError']
      429: components['responses']['TooManyRequestsError']
    }
  }
  /**
   * get the source code for a Pack version.
   * @description Get temporary links used to download the source code for the given packId and version
   */
  getPackSourceCode: {
    parameters: {
      path: {
        packId: components['parameters']['packId']
        packVersion: components['parameters']['packVersion']
      }
    }
    responses: {
      /** @description The source code associated with the given packId/version */
      200: {
        content: {
          'application/json': components['schemas']['PackSourceCodeInfo']
        }
      }
      400: components['responses']['BadRequestWithValidationErrors']
      401: components['responses']['UnauthorizedError']
      403: components['responses']['ForbiddenError']
      404: components['responses']['NotFoundError']
      429: components['responses']['TooManyRequestsError']
    }
  }
  /**
   * List the Pack listings accessible to a user.
   * @description Get listings of public Packs and Packs created by you.
   */
  listPackListings: {
    parameters: {
      query?: {
        packAccessTypes?: components['parameters']['packAccessTypes']
        packIds?: components['parameters']['packIds']
        onlyWorkspaceId?: components['parameters']['onlyWorkspaceId']
        parentWorkspaceIds?: components['parameters']['parentWorkspaceIds']
        excludePublicPacks?: components['parameters']['excludePublicPacks']
        excludeWorkspaceAcls?: components['parameters']['excludeWorkspaceAcls']
        excludeIndividualAcls?: components['parameters']['excludeIndividualAcls']
        /** @description Specify a sort order for the returned Pack listings returned. */
        sortBy?: components['schemas']['PackListingsSortBy']
        /** @description Deprecated: use sortBy instead. */
        orderBy?: components['schemas']['PackListingsSortBy']
        direction?: components['parameters']['direction']
        limit?: components['parameters']['limit']
        pageToken?: components['parameters']['pageToken']
        /**
         * @description Type of installation context for which Pack information is being requested.
         * @example workspace
         */
        installContext?: components['schemas']['PackListingInstallContextType']
      }
    }
    responses: {
      /** @description Public Pack listings and Pack listings created by you. */
      200: {
        content: {
          'application/json': components['schemas']['PackListingList']
        }
      }
      400: components['responses']['BadRequestWithValidationErrors']
      401: components['responses']['UnauthorizedError']
      403: components['responses']['ForbiddenError']
      404: components['responses']['NotFoundError']
      429: components['responses']['TooManyRequestsError']
    }
  }
  /**
   * Get detailed listing information for a Pack.
   * @description Get detailed listing information for a Pack.
   */
  getPackListing: {
    parameters: {
      query?: {
        /**
         * @description ID of the target workspace (if applicable) for checking installation privileges.
         * @example ws-1Ab234
         */
        workspaceId?: string
        /**
         * @description ID of the target document for checking installation privileges
         * @example fleHfrkw3L
         */
        docId?: string
        /**
         * @description Type of installation context for which Pack information is being requested.
         * @example workspace
         */
        installContext?: components['schemas']['PackListingInstallContextType']
        /**
         * @description Release channel for which Pack information is being requested.
         * @example LIVE
         */
        releaseChannel?: components['schemas']['IngestionPackReleaseChannel']
      }
      path: {
        packId: components['parameters']['packId']
      }
    }
    responses: {
      /** @description The Pack listing detail. */
      200: {
        content: {
          'application/json': components['schemas']['PackListingDetail']
        }
      }
      400: components['responses']['BadRequestWithValidationErrors']
      401: components['responses']['UnauthorizedError']
      403: components['responses']['ForbiddenError']
      404: components['responses']['NotFoundError']
      429: components['responses']['TooManyRequestsError']
    }
  }
  /**
   * Retrieve the logs of a Pack.
   * @description Retrieve the logs of a Pack for debugging purpose.
   */
  listPackLogs: {
    parameters: {
      query?: {
        /**
         * @description Maximum number of results to return in this query.
         * @example 10
         */
        limit?: number
        pageToken?: components['parameters']['pageToken']
        /**
         * @description Only return logs of the given types.
         * @example fetcher,custom
         */
        logTypes?: components['schemas']['PackLogType'][]
        /**
         * @description Only return logs before the given time (non-inclusive).
         *
         * @example 2018-04-11T00:18:57.946Z
         */
        beforeTimestamp?: string
        /**
         * @description Only return logs after the given time (non-inclusive).
         *
         * @example 2018-04-11T00:18:57.946Z
         */
        afterTimestamp?: string
        /** @description Specifies if the logs will be returned in time desc or asc. Default is desc. */
        order?: 'asc' | 'desc'
        /**
         * @description A search query that follows Lucene syntax.
         *
         * @example context.doc_id:"fleHfrkw3L" AND event.action:"FormulaRequest"
         */
        q?: string
        /**
         * @description Only return logs matching provided request IDs.
         * @example 416faabf,4127faag
         */
        requestIds?: string[]
      }
      path: {
        packId: components['parameters']['packId']
        docId: components['parameters']['docId']
      }
    }
    responses: {
      /** @description Pack logs. */
      200: {
        content: {
          'application/json': components['schemas']['PackLogsList']
        }
      }
      400: components['responses']['BadRequestWithValidationErrors']
      401: components['responses']['UnauthorizedError']
      403: components['responses']['ForbiddenError']
      404: components['responses']['NotFoundError']
      429: components['responses']['TooManyRequestsError']
    }
  }
  /**
   * Retrieve the logs of a Ingestion.
   * @description Retrieve the logs of a Ingestion for debugging purpose.
   */
  listIngestionLogs: {
    parameters: {
      query?: {
        /**
         * @description Maximum number of results to return in this query.
         * @example 10
         */
        limit?: number
        pageToken?: components['parameters']['pageToken']
        /**
         * @description Only return logs of the given types.
         * @example fetcher,custom
         */
        logTypes?: components['schemas']['PackLogType'][]
        /**
         * @description ID of the ingestion execution.
         * @example a4e293c4-4a85-45a4-b2ba-7f305cba2703
         */
        ingestionExecutionId?: string
        /**
         * @description Only return logs before the given time (non-inclusive).
         *
         * @example 2018-04-11T00:18:57.946Z
         */
        beforeTimestamp?: string
        /**
         * @description Only return logs after the given time (non-inclusive).
         *
         * @example 2018-04-11T00:18:57.946Z
         */
        afterTimestamp?: string
        /** @description Specifies if the logs will be returned in time desc or asc. Default is desc. */
        order?: 'asc' | 'desc'
        /**
         * @description A search query that follows Lucene syntax.
         *
         * @example context.doc_id:"fleHfrkw3L" AND event.action:"FormulaRequest"
         */
        q?: string
        /**
         * @description Only return logs matching provided request IDs.
         * @example 416faabf,4127faag
         */
        requestIds?: string[]
      }
      path: {
        packId: components['parameters']['packId']
        organizationId: components['parameters']['organizationId']
        rootIngestionId: components['parameters']['rootIngestionId']
      }
    }
    responses: {
      /** @description Pack logs. */
      200: {
        content: {
          'application/json': components['schemas']['PackLogsList']
        }
      }
      400: components['responses']['BadRequestWithValidationErrors']
      401: components['responses']['UnauthorizedError']
      403: components['responses']['ForbiddenError']
      404: components['responses']['NotFoundError']
      429: components['responses']['TooManyRequestsError']
    }
  }
  /**
   * Retrieve the grouped logs of a Pack.
   * @description Retrieve the grouped logs of a Pack for debugging purpose.
   */
  listGroupedPackLogs: {
    parameters: {
      query?: {
        /**
         * @description Maximum number of results to return in this query.
         * @example 10
         */
        limit?: number
        pageToken?: components['parameters']['pageToken']
        /**
         * @description Only return logs before the given time (non-inclusive).
         *
         * @example 2018-04-11T00:18:57.946Z
         */
        beforeTimestamp?: string
        /**
         * @description Only return logs after the given time (non-inclusive).
         *
         * @example 2018-04-11T00:18:57.946Z
         */
        afterTimestamp?: string
        /** @description Specifies if the logs will be returned in time desc or asc. Default is desc. */
        order?: 'asc' | 'desc'
        /**
         * @description A search query that follows Lucene syntax.
         *
         * @example context.doc_id:"fleHfrkw3L" AND event.action:"FormulaRequest"
         */
        q?: string
      }
      path: {
        packId: components['parameters']['packId']
        docId: components['parameters']['docId']
      }
    }
    responses: {
      /** @description Grouped pack logs. */
      200: {
        content: {
          'application/json': components['schemas']['GroupedPackLogsList']
        }
      }
      400: components['responses']['BadRequestWithValidationErrors']
      401: components['responses']['UnauthorizedError']
      403: components['responses']['ForbiddenError']
      404: components['responses']['NotFoundError']
      429: components['responses']['TooManyRequestsError']
    }
  }
  /**
   * Retrieve the grouped logs of a Pack for a specific ingestionExecutionId.
   * @description Retrieve the grouped logs of a Pack for debugging purpose.
   */
  listGroupedIngestionLogs: {
    parameters: {
      query?: {
        /**
         * @description Maximum number of results to return in this query.
         * @example 10
         */
        limit?: number
        pageToken?: components['parameters']['pageToken']
        /**
         * @description Only return logs before the given time (non-inclusive).
         *
         * @example 2018-04-11T00:18:57.946Z
         */
        beforeTimestamp?: string
        /**
         * @description Only return logs after the given time (non-inclusive).
         *
         * @example 2018-04-11T00:18:57.946Z
         */
        afterTimestamp?: string
        /** @description Specifies if the logs will be returned in time desc or asc. Default is desc. */
        order?: 'asc' | 'desc'
        /**
         * @description A search query that follows Lucene syntax.
         *
         * @example context.doc_id:"fleHfrkw3L" AND event.action:"FormulaRequest"
         */
        q?: string
      }
      path: {
        packId: components['parameters']['packId']
        organizationId: components['parameters']['organizationId']
        rootIngestionId: components['parameters']['rootIngestionId']
        ingestionExecutionId: components['parameters']['ingestionExecutionId']
      }
    }
    responses: {
      /** @description Grouped pack logs. */
      200: {
        content: {
          'application/json': components['schemas']['GroupedPackLogsList']
        }
      }
      400: components['responses']['BadRequestWithValidationErrors']
      401: components['responses']['UnauthorizedError']
      403: components['responses']['ForbiddenError']
      404: components['responses']['NotFoundError']
      429: components['responses']['TooManyRequestsError']
    }
  }
  /**
   * Retrieve a list of ingestion execution ids for the given root ingestion id.
   * @description Retrieve the ingestion execution ids of a root ingestion for debugging purpose.
   */
  listIngestionExecutions: {
    parameters: {
      query?: {
        /**
         * @description Maximum number of results to return in this query.
         * @example 10
         */
        limit?: number
        pageToken?: components['parameters']['pageToken']
        /**
         * @description Only return logs before the given time (non-inclusive).
         *
         * @example 2018-04-11T00:18:57.946Z
         */
        beforeTimestamp?: string
        /**
         * @description Only return logs after the given time (non-inclusive).
         *
         * @example 2018-04-11T00:18:57.946Z
         */
        afterTimestamp?: string
        /** @description Specifies if the logs will be returned in time desc or asc. Default is desc. */
        order?: 'asc' | 'desc'
        /**
         * @description A search query that follows Lucene syntax.
         *
         * @example context.doc_id:"fleHfrkw3L" AND event.action:"FormulaRequest"
         */
        q?: string
      }
      path: {
        packId: components['parameters']['packId']
        organizationId: components['parameters']['organizationId']
        rootIngestionId: components['parameters']['rootIngestionId']
      }
    }
    responses: {
      /** @description list of ingestion execution contexts. */
      200: {
        content: {
          'application/json': components['schemas']['IngestionExecutionsList']
        }
      }
      400: components['responses']['BadRequestWithValidationErrors']
      401: components['responses']['UnauthorizedError']
      403: components['responses']['ForbiddenError']
      404: components['responses']['NotFoundError']
      429: components['responses']['TooManyRequestsError']
    }
  }
  /**
   * List featured docs for a Pack
   * @description Returns a list of featured doc ids for a Pack.
   */
  listPackFeaturedDocs: {
    parameters: {
      path: {
        packId: components['parameters']['packId']
      }
    }
    responses: {
      /** @description The featured docs for a Pack. */
      200: {
        content: {
          'application/json': components['schemas']['PackFeaturedDocsResponse']
        }
      }
      400: components['responses']['BadRequestError']
      401: components['responses']['UnauthorizedError']
      403: components['responses']['ForbiddenError']
      404: components['responses']['NotFoundError']
      429: components['responses']['TooManyRequestsError']
    }
  }
  /**
   * Update featured docs for a Pack
   * @description Create or replace the featured docs for a Pack.
   */
  updatePackFeaturedDocs: {
    parameters: {
      path: {
        packId: components['parameters']['packId']
      }
    }
    /** @description Parameters for updating the Pack's featured docs. */
    requestBody: {
      content: {
        'application/json': components['schemas']['UpdatePackFeaturedDocsRequest']
      }
    }
    responses: {
      /** @description Update Pack's featured docs success response */
      200: {
        content: {
          'application/json': components['schemas']['UpdatePackFeaturedDocsResponse']
        }
      }
      400: components['responses']['BadRequestError']
      401: components['responses']['UnauthorizedError']
      403: components['responses']['ForbiddenError']
      404: components['responses']['NotFoundError']
      429: components['responses']['TooManyRequestsError']
    }
  }
}

export interface oasTypes {
  components: components
  external: external
  operations: operations
  paths: paths
  webhooks: webhooks
}

export default oasTypes
